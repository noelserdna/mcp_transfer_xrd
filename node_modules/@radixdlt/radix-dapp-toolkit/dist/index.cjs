"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../connect-button/dist/connect-button.js
var connect_button_exports = {};
__export(connect_button_exports, {
  ConnectButton: () => I,
  RadixRcfmPage: () => h
});
var import_lit, import_decorators, import_class_map, import_style_map, import_class_map2, Me, R, Ce, ye, pe, U, me, $, ze, we, Z, C, ve, Te, G, Le, ke, H, _, fe, w, ee, Se, Ee, te, ie, oe, z, A, Ze, Oe, O, y, re, ae, ne, se, ge, Pe, Ge, ue, Ue, Ye, V, v, ce, We, Qe, xe, Y, Ae, Be, Ne, Re, He, k, N, Ve, Xe, j, x, Je, Fe, be, W, Ke, qe, $e, F, _e, et, f, b, tt, it, ot, P, m, de, Ie, De, rt, at, S, D, nt, st, gt, he, Q, ct, dt, X, T, It, lt, p, I, Mt, pt, je, B, ut, xt, At, J, L, Nt, bt, E, h;
var init_connect_button = __esm({
  "../connect-button/dist/connect-button.js"() {
    "use strict";
    import_lit = require("lit");
    import_decorators = require("lit/decorators.js");
    import_class_map = require("lit/directives/class-map.js");
    import_style_map = require("lit/directives/style-map.js");
    import_class_map2 = require("lit-html/directives/class-map.js");
    Me = import_lit.css`:host{--color-radix-green-1:#00ab84;--color-radix-green-2:#00c389;--color-radix-green-3:#21ffbe;--color-radix-blue-1:#060f8f;--color-radix-blue-2:#052cc0;--color-radix-blue-3:#20e4ff;--color-light:#ffffff;--color-dark:#000000;--color-accent-red:#ef4136;--color-accent-blue:#00aeef;--color-accent-yellow:#fff200;--color-alert:#e59700;--color-radix-error-red-1:#c82020;--color-radix-error-red-2:#fcebeb;--color-grey-1:#003057;--color-grey-2:#8a8fa4;--color-grey-3:#ced0d6;--color-grey-4:#e2e5ed;--color-grey-5:#f4f5f9}`;
    R = import_lit.css`:host{font-family:'IBM Plex Sans',system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Open Sans','Helvetica Neue',sans-serif}:host([mode=light]){--radix-popover-background:#e4e4e4;--radix-popover-border-color:var(--color-grey-3);--radix-popover-text-color:var(--color-grey-1);--radix-popover-tabs-background:color-mix(
      in srgb,
      var(--color-grey-2) 15%,
      transparent
    );--radix-popover-tabs-button-active-background:var(--color-light);--radix-link-color:var(--color-radix-blue-2);--radix-card-background:var(--color-light);--radix-card-text-color:var(--color-grey-1);--radix-card-text-dimmed-color:var(--color-grey-2);--radix-card-inverted-background:var(--color-grey-1);--radix-card-inverted-text-color:var(--color-light);--radix-avatar-border-color:var(--color-grey-5);--radix-mask-background:color-mix(
      in srgb,
      var(--color-light) 50%,
      transparent
    );--radix-button-background:color-mix(
      in srgb,
      var(--color-light) 70%,
      transparent
    );--radix-button-background-hover:var(--color-light);--radix-button-background-pressed:var(--color-grey-5);--radix-button-text-color:var(--color-radix-blue-2);--radix-button-disabled-background:color-mix(
      in srgb,
      var(--color-light) 80%,
      transparent
    );--radix-button-disabled-text-color:var(--color-grey-3);color:var(--color-grey-1)}:host([mode=dark]){--radix-popover-background:#5c5c5c;--radix-popover-text-color:var(--color-light);--radix-popover-tabs-background:color-mix(
      in srgb,
      var(--color-dark) 60%,
      transparent
    );--radix-popover-tabs-button-active-text-color:var(--color-light);--radix-popover-tabs-button-active-background:#494949;--radix-link-color:var(--color-white);--radix-card-background:#494949;--radix-card-text-color:var(--color-light);--radix-card-text-dimmed-color:var(--color-grey-3);--radix-card-inverted-background:var(--color-grey-5);--radix-card-inverted-text-color:var(--color-grey-1);--radix-avatar-border-color:#656565;--radix-mask-background:color-mix(
      in srgb,
      var(--color-dark) 40%,
      transparent
    );--radix-button-background:color-mix(
      in srgb,
      var(--color-dark) 40%,
      transparent
    );--radix-button-background-hover:var(--color-dark);--radix-button-background-pressed:#414141;--radix-button-text-color:var(--color-light);--radix-button-disabled-background:color-mix(
      in srgb,
      var(--color-dark) 40%,
      transparent
    );--radix-button-disabled-text-color:color-mix(
      in srgb,
      var(--color-light) 20%,
      transparent
    );color:var(--color-light)}:host([theme=radix-blue]){--radix-connect-button-background:var(--color-radix-blue-2);--radix-connect-button-background-hover:var(--color-radix-blue-1);--radix-connect-button-border-color:var(--color-radix-blue-2);--radix-connect-button-text-color:var(--color-light)}:host([theme=black]){--radix-connect-button-background:var(--color-dark);--radix-connect-button-background-hover:#3e3e3e;--radix-connect-button-border-color:var(--color-dark);--radix-connect-button-text-color:var(--color-light)}:host([theme=white-with-outline]){--radix-connect-button-background:var(--color-light);--radix-connect-button-background-hover:var(--color-grey-5);--radix-connect-button-border-color:var(--color-dark);--radix-connect-button-text-color:var(--color-dark)}:host([theme=white]){--radix-connect-button-background:var(--color-light);--radix-connect-button-background-hover:var(--color-grey-5);--radix-connect-button-border-color:var(--color-light);--radix-connect-button-text-color:var(--color-dark)}`;
    Ce = Object.defineProperty;
    ye = Object.getOwnPropertyDescriptor;
    pe = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? ye(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && Ce(i, r, e), e;
    };
    U = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.active = "sharing";
      }
      onClick(t, i) {
        this.dispatchEvent(
          new CustomEvent("onClick", {
            detail: { value: t, event: i },
            bubbles: true,
            composed: true
          })
        );
      }
      render() {
        return import_lit.html`<div class="tabs"><button @click="${(t) => this.onClick("sharing", t)}" class="${(0, import_class_map.classMap)({
          active: this.active === "sharing"
        })}">Sharing</button> <button @click="${(t) => this.onClick("requests", t)}" class="${(0, import_class_map.classMap)({
          active: this.active === "requests"
        })}">Requests</button><div class="active-indicator"></div></div>`;
      }
    };
    U.styles = [
      import_lit.css`:host{display:block;width:100%;user-select:none}.tabs{width:calc(100% - 10px);display:grid;grid-template-columns:1fr 1fr;justify-content:space-between;padding:5px;border-radius:12px;position:relative;background:var(--radix-popover-tabs-background)}button{border:unset;font-size:14px;background:0 0;text-align:center;flex:1;border-radius:8px;font-weight:600;color:var(--radix-popover-text-color);width:100%;height:32px;z-index:1;margin:0;padding:0}button:not(.active){cursor:pointer}.active-indicator{width:calc(50% - 5px);height:32px;border-radius:8px;position:absolute;box-shadow:0 4px 5px 0 #0000001a;background:var(--radix-popover-tabs-button-active-background);top:5px;transition:transform 125ms cubic-bezier(.45,0,.55,1)}:host([active=sharing]) .active-indicator{transform:translateX(5px)}:host([active=requests]) .active-indicator{transform:translateX(calc(100% + 5px))}button:focus,button:focus-visible{outline:0 auto -webkit-focus-ring-color}`
    ];
    pe([
      (0, import_decorators.property)({
        type: String,
        reflect: true
      })
    ], U.prototype, "active", 2);
    U = pe([
      (0, import_decorators.customElement)("radix-tabs-menu")
    ], U);
    me = (t) => {
      if (typeof btoa == "function")
        return btoa(t);
      if (typeof Buffer == "function")
        return Buffer.from(t, "utf-8").toString("base64");
      throw new Error("Failed to determine the platform specific encoder");
    };
    $ = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8xNzU4XzE0NjkpIj4KICAgICAgICA8cGF0aAogICAgICAgICAgICBkPSJNMTkgNi40MUwxNy41OSA1TDEyIDEwLjU5TDYuNDEgNUw1IDYuNDFMMTAuNTkgMTJMNSAxNy41OUw2LjQxIDE5TDEyIDEzLjQxTDE3LjU5IDE5TDE5IDE3LjU5TDEzLjQxIDEyTDE5IDYuNDFaIgogICAgICAgICAgICBmaWxsPSIjMzIzMjMyIiAvPgogICAgPC9nPgogICAgPGRlZnM+CiAgICAgICAgPGNsaXBQYXRoIGlkPSJjbGlwMF8xNzU4XzE0NjkiPgogICAgICAgICAgICA8cmVjdCB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9IndoaXRlIiAvPgogICAgICAgIDwvY2xpcFBhdGg+CiAgICA8L2RlZnM+Cjwvc3ZnPgogICAg";
    ze = Object.defineProperty;
    we = Object.getOwnPropertyDescriptor;
    Z = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? we(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && ze(i, r, e), e;
    };
    C = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.connected = false, this.compact = false, this.isMobile = false, this.showCloseButton = false, this.svgBorder = `data:image/svg+xml;base64,${me('<svg width="352" height="352" viewBox="0 0 352 352" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13 1.5H339V0.5H13V1.5ZM350.5 13V339H351.5V13H350.5ZM339 350.5H13V351.5H339V350.5ZM1.5 339V13H0.5V339H1.5ZM13 350.5C6.64873 350.5 1.5 345.351 1.5 339H0.5C0.5 345.904 6.09644 351.5 13 351.5V350.5ZM350.5 339C350.5 345.351 345.351 350.5 339 350.5V351.5C345.904 351.5 351.5 345.904 351.5 339H350.5ZM339 1.5C345.351 1.5 350.5 6.64873 350.5 13H351.5C351.5 6.09644 345.904 0.5 339 0.5V1.5ZM13 0.5C6.09644 0.5 0.5 6.09644 0.5 13H1.5C1.5 6.64873 6.64873 1.5 13 1.5V0.5Z" fill="url(#gradient)"/><defs><linearGradient id="gradient" x1="340.017" y1="27.6666" x2="36.936" y2="352.447" gradientUnits="userSpaceOnUse"><stop stop-color="#CE0D98"/><stop offset="0.210873" stop-color="#052CC0"/><stop offset="0.479167" stop-color="#20E4FF"/><stop offset="0.729604" stop-color="#052CC0"/><stop offset="1" stop-color="#21FFBE"/></linearGradient></defs></svg>')}`;
      }
      closePopover() {
        this.dispatchEvent(
          new CustomEvent("onClosePopover", {
            bubbles: true,
            composed: true
          })
        );
      }
      closeButton() {
        return import_lit.html`<button id="close-button" @click="${() => {
          this.closePopover();
        }}"></button>`;
      }
      render() {
        return import_lit.html`<style>:host([connected]){border-image:url('${this.svgBorder}') 10/10px stretch;border-image-outset:1px}</style><div id="radix-popover-content">${this.showCloseButton ? this.closeButton() : ""}<slot></slot></div>`;
      }
    };
    C.styles = [
      R,
      import_lit.css`:host{user-select:none;display:inline-flex;background-position:center top;background-repeat:no-repeat;justify-content:center;align-items:flex-start;background:var(--radix-popover-background);box-sizing:border-box;max-height:100vh;border-radius:12px;padding:12px;border:1px solid var(--radix-popover-border-color);box-shadow:0 11px 35px 0 #00000047}:host([isMobile]){max-width:100%;max-height:calc(100% - 5px)}#radix-popover-content{width:344px;display:flex;justify-content:flex-start;align-items:center;flex-direction:column;overflow:auto}#close-button{-webkit-mask-image:url('${(0, import_lit.unsafeCSS)($)}');mask-image:url('${(0, import_lit.unsafeCSS)($)}');background-color:var(--radix-card-text-color);width:24px;height:24px;background-repeat:no-repeat;align-self:flex-start;margin-bottom:10px;cursor:pointer}#close-button:hover{opacity:.8}@-webkit-keyframes slide-bottom{0%{-webkit-transform:translateY(-10px);transform:translateY(-10px);opacity:0}100%{-webkit-transform:translateY(0);transform:translateY(0);opacity:1}}@keyframes slide-bottom{0%{-webkit-transform:translateY(-10px);transform:translateY(-10px);opacity:0}100%{-webkit-transform:translateY(0);transform:translateY(0);opacity:1}}@-webkit-keyframes slide-up{0%{-webkit-transform:translateY(0);transform:translateY(0);opacity:1}100%{-webkit-transform:translateY(-10px);transform:translateY(-10px);opacity:0}}@keyframes slide-up{0%{-webkit-transform:translateY(0);transform:translateY(0);opacity:1}100%{-webkit-transform:translateY(-10px);transform:translateY(-10px);opacity:0}}:host(.hide){pointer-events:none;-webkit-animation:slide-up .2s cubic-bezier(.25,.46,.45,.94) both;animation:slide-up .2s cubic-bezier(.25,.46,.45,.94) both}:host(.show){-webkit-animation:slide-bottom .2s cubic-bezier(.25,.46,.45,.94) both;animation:slide-bottom .2s cubic-bezier(.25,.46,.45,.94) both}`
    ];
    Z([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], C.prototype, "connected", 2);
    Z([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], C.prototype, "compact", 2);
    Z([
      (0, import_decorators.property)({
        type: Boolean,
        reflect: true
      })
    ], C.prototype, "isMobile", 2);
    Z([
      (0, import_decorators.property)({
        type: Boolean,
        reflect: true
      })
    ], C.prototype, "showCloseButton", 2);
    C = Z([
      (0, import_decorators.customElement)("radix-popover")
    ], C);
    ve = 32;
    Te = 32;
    G = 138;
    Le = Object.defineProperty;
    ke = Object.getOwnPropertyDescriptor;
    H = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? ke(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && Le(i, r, e), e;
    };
    _ = import_lit.html`<div class="loading-spinner-container"><div class="loading-spinner"></div></div>`;
    fe = import_lit.css`.loading-spinner-container{display:flex}@container (max-width: ${G - 16}px){margin-right:0}.loading-spinner{width:22px;height:22px;min-width:22px;min-height:22px;border:2px solid var(--radix-connect-button-text-color);border-left-color:color-mix(in srgb,var(--radix-connect-button-text-color) 30%,transparent);border-top-color:color-mix(in srgb,var(--radix-connect-button-text-color) 30%,transparent);border-bottom-color:color-mix(in srgb,var(--radix-connect-button-text-color) 30%,transparent);border-radius:50%;display:inline-block;box-sizing:border-box;animation:rotation 1s linear infinite;align-self:center}@keyframes rotation{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}`;
    w = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.size = 48, this.weight = 5, this.color = "var(--color-grey-2)";
      }
      render() {
        return import_lit.html`<div class="loading-spinner-container"><div class="loading-spinner" style="${(0, import_style_map.styleMap)({
          width: `${this.size}px`,
          height: `${this.size}px`,
          minWidth: `${this.size}px`,
          minHeight: `${this.size}px`,
          border: `${this.weight}px solid color-mix(in srgb, ${this.color} 30%, transparent)`,
          borderBottomColor: this.color
        })}"></div></div>`;
      }
    };
    w.styles = [
      import_lit.css`.loading-spinner-container{display:flex}.loading-spinner{border-radius:50%;display:inline-block;box-sizing:border-box;animation:rotation 1s linear infinite;align-self:center}@keyframes rotation{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}`
    ];
    H([
      (0, import_decorators.property)({
        type: Number
      })
    ], w.prototype, "size", 2);
    H([
      (0, import_decorators.property)({
        type: Number
      })
    ], w.prototype, "weight", 2);
    H([
      (0, import_decorators.property)({
        type: String
      })
    ], w.prototype, "color", 2);
    w = H([
      (0, import_decorators.customElement)("radix-loading-spinner")
    ], w);
    ee = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxNiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTUuNzYzNzEgMTEuNzE4M0M1LjUxNDM0IDExLjcxODMgNS4yNzcyNiAxMS41OTg2IDUuMTI4NjIgMTEuMzkyNUwyLjAyNDQyIDcuMDcwOTdIMFY1LjQ5NzU4SDIuNDI0ODhDMi42NzY3MSA1LjQ5NzU4IDIuOTEyNTYgNS42MTg1MiAzLjA1OTk3IDUuODIzMzdMNS41OTY2NCA5LjM1MzkxTDkuNDY3MzcgMC40NzEzOThDOS41OTI2NiAwLjE4NTEwNCA5Ljg3Mzk3IDAgMTAuMTg0OCAwSDE1LjAyMzVWMS41NzMzOEgxMC42OTdMNi40ODExIDExLjI0NjlDNi4zNjgwOSAxMS41MDYxIDYuMTI2MDkgMTEuNjgzOCA1Ljg0NjAxIDExLjcxMzRDNS44MjAyMSAxMS43MTcxIDUuNzkxOTYgMTEuNzE4MyA1Ljc2MzcxIDExLjcxODNaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K";
    Se = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTM4IDQyIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogICAgPGcgZmlsdGVyPSJ1cmwoI3RvcC1sZWZ0LXRlYWwpIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSI+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTAuNDA2MzI5IC0zNC40OTU3QzE2LjYxMSAtNDEuODMzMSAzNC42MTc0IC0zNy4wMjU4IDQwLjYyNSAtMjMuNzU4M0M0Ni42MzI1IC0xMC40OTA4IDM4LjM2NjEgNi4yMTI4NiAyMi4xNjE1IDEzLjU1MDNDNS45NTY4NiAyMC44ODc3IC00Mi41MTI3IC0xLjE3MzYgLTQ4LjUyMDIgLTE0LjQ0MTFDLTU0LjUyNzcgLTI3LjcwODcgLTE1Ljc5ODMgLTI3LjE1ODMgMC40MDYzMjkgLTM0LjQ5NTdaIgogICAgICAgICAgICBmaWxsPSIjMjFGRkJFIiAvPgoKICAgICAgICA8ZmlsdGVyIGlkPSJ0b3AtbGVmdC10ZWFsIiB4PSItNzkuMzQzIiB5PSItNjguMTI1NCIgd2lkdGg9IjE1MiIgaGVpZ2h0PSIxMTMiCiAgICAgICAgICAgIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMTUuMDk3OSIgLz4KICAgICAgICA8L2ZpbHRlcj4KICAgIDwvZz4KCgogICAgPGcgZmlsdGVyPSJ1cmwoI2JvdHRvbS1yaWdodC1henVyZSkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIj4KICAgICAgICA8cGF0aAogICAgICAgICAgICBkPSJNNzcuOTQ4MiAyOC40NjdDODYuNzM2MiAyMi4wODY5IDk4LjA5NSAyMi43NDc4IDEwMy4zMTkgMjkuOTQzQzEwOC41NDIgMzcuMTM4MiAxMDUuNjUzIDQ4LjE0MzIgOTYuODY0OSA1NC41MjMzQzg4LjA3NjggNjAuOTAzNCA1Ni4zNzk5IDUzLjY3MDMgNTEuMTU2MiA0Ni40NzUxQzQ1LjkzMjUgMzkuMjc5OCA2OS4xNjAxIDM0Ljg0NzEgNzcuOTQ4MiAyOC40NjdaIgogICAgICAgICAgICBmaWxsPSIjMjBFNEZGIiAvPgoKICAgICAgICA8ZmlsdGVyIGlkPSJib3R0b20tcmlnaHQtYXp1cmUiIHg9IjI2LjM5OTciIHk9IjAuMDgyNzcxMyIgd2lkdGg9IjEwMyIgaGVpZ2h0PSI4MSIKICAgICAgICAgICAgZmlsdGVyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiPgogICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxMiIgLz4KICAgICAgICA8L2ZpbHRlcj4KICAgIDwvZz4KCgogICAgPGcgZmlsdGVyPSJ1cmwoI2JvdHRvbS1sZWZ0LWJsdWUpIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSI+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTE2LjE0MjEgMjkuNTA5QzI2LjkyNjYgMzQuMDQyNyAzMi41MTE2IDQ1LjIyOTIgMjguNjE2NCA1NC40OTQ5QzI0LjcyMTMgNjMuNzYwNiAxMi44MjExIDY3LjU5NjYgMi4wMzY1OCA2My4wNjNDLTguNzQ3OTIgNTguNTI5MyAtMTkuMjc4MSAyNC4wOTA0IC0xNS4zODMgMTQuODI0N0MtMTEuNDg3OCA1LjU1OTAzIDUuMzU3NjUgMjQuOTc1NCAxNi4xNDIxIDI5LjUwOVoiCiAgICAgICAgICAgIGZpbGw9IiMwNjBGOEYiIC8+CgogICAgICAgIDxmaWx0ZXIgaWQ9ImJvdHRvbS1sZWZ0LWJsdWUiIHg9Ii0zNi4yMTA3IiB5PSItNy42NDk0MSIgd2lkdGg9Ijg2IiBoZWlnaHQ9IjkzIgogICAgICAgICAgICBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEwIiAvPgogICAgICAgIDwvZmlsdGVyPgogICAgPC9nPgoKICAgIDxnIGZpbHRlcj0idXJsKCNib3R0b20tcmlnaHQtcHVycGxlKSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiPgogICAgICAgIDxwYXRoCiAgICAgICAgICAgIGQ9Ik0xMjAuMTM1IDE2LjI2MTNDMTAzLjU3IDE3LjMyMDkgODkuNDM4MiA3LjE4NTI1IDg4LjU3MDcgLTYuMzc3MThDODcuNzAzMiAtMTkuOTM5NiAxMDAuNDI4IC0zMS43OTMgMTE2Ljk5MyAtMzIuODUyNkMxMzMuNTU4IC0zMy45MTIxIDE2OC41ODkgMS4zMzIzMiAxNjkuNDU2IDE0Ljg5NDdDMTcwLjMyNCAyOC40NTcyIDEzNi42OTkgMTUuMjAxOCAxMjAuMTM1IDE2LjI2MTNaIgogICAgICAgICAgICBmaWxsPSIjRkY0M0NBIiAvPgoKICAgICAgICA8ZmlsdGVyIGlkPSJib3R0b20tcmlnaHQtcHVycGxlIiB4PSI0OC41Mjg5IiB5PSItNzIuODc1OSIgd2lkdGg9IjE2MSIgaGVpZ2h0PSIxMzQiCiAgICAgICAgICAgIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMjAiIC8+CiAgICAgICAgPC9maWx0ZXI+CiAgICA8L2c+Cjwvc3ZnPgogICAg";
    Ee = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNDIgNDIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8Zz4KICAgICAgICA8cGF0aCBmaWx0ZXI9InVybCgjdG9wLWxlZnQtdGVhbCkiCiAgICAgICAgICAgIGQ9Ik0tNS4wMjMyMyAtMTUuMTI2NUMzLjYwMTggLTE5LjU0MTMgMTQuMTAyOCAtMTQuMzU5NyAxOC40MzE1IC0zLjU1Mjk5QzIyLjc2MDEgNy4yNTM2OCAxOS4yNzcyIDE5LjU5MzEgMTAuNjUyMiAyNC4wMDc5QzIuMDI3MTMgMjguNDIyNyAtMjYuODg0NiA3LjM3NTg3IC0zMS4yMTMzIC0zLjQzMDhDLTM1LjU0MTkgLTE0LjIzNzUgLTEzLjY0ODMgLTEwLjcxMTcgLTUuMDIzMjMgLTE1LjEyNjVaIgogICAgICAgICAgICBmaWxsPSIjMjFGRkJFIiAvPgogICAgICAgIDxmaWx0ZXIgaWQ9InRvcC1sZWZ0LXRlYWwiIHg9Ii01MS43NzM3IiB5PSItMzYuNzAxOSIgd2lkdGg9IjkyLjA2NTQiIGhlaWdodD0iODEuMzA5NiIKICAgICAgICAgICAgZmlsdGVyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiPgogICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxMCIgLz4KICAgICAgICA8L2ZpbHRlcj4KICAgIDwvZz4KICAgIDxnPgogICAgICAgIDxwYXRoIGZpbHRlcj0idXJsKCNib3R0b20tcmlnaHQtYXp1cmUpIgogICAgICAgICAgICBkPSJNMjYuNjA3OSAyOS40NjdDMzQuMzgyIDIzLjA4NjkgNDQuNDMwMiAyMy43NDc3IDQ5LjA1MTIgMzAuOTQzQzUzLjY3MjEgMzguMTM4MiA1MS4xMTYgNDkuMTQzMiA0My4zNDIgNTUuNTIzM0MzNS41Njc5IDYxLjkwMzQgNy41MjgzNiA1NC42NzAzIDIuOTA3NCA0Ny40NzUxQy0xLjcxMzU3IDQwLjI3OTggMTguODMzOSAzNS44NDcxIDI2LjYwNzkgMjkuNDY3WiIKICAgICAgICAgICAgZmlsbD0iIzIwRTRGRiIgLz4KICAgICAgICA8ZmlsdGVyIGlkPSJib3R0b20tcmlnaHQtYXp1cmUiIHg9Ii0xNy43NjE4IiB5PSI1LjA4Mjc2IiB3aWR0aD0iODkuMTE0NSIgaGVpZ2h0PSI3Mi45IgogICAgICAgICAgICBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEwIiAvPgogICAgICAgIDwvZmlsdGVyPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZmlsdGVyPSJ1cmwoI2JvdHRvbS1sZWZ0LWJsdWUpIgogICAgICAgICAgICBkPSJNMTQuMjc5NiAyOS41MDlDMjMuODE5NyAzNC4wNDI3IDI4Ljc2MDIgNDUuMjI5MiAyNS4zMTQ1IDU0LjQ5NDlDMjEuODY4OCA2My43NjA1IDExLjM0MTcgNjcuNTk2NiAxLjgwMTU4IDYzLjA2M0MtNy43Mzg1NSA1OC41MjkzIC0xNy4wNTM3IDI0LjA5MDQgLTEzLjYwOCAxNC44MjQ3Qy0xMC4xNjIzIDUuNTU5MDQgNC43Mzk0NSAyNC45NzU0IDE0LjI3OTYgMjkuNTA5WiIKICAgICAgICAgICAgZmlsbD0iIzA2MEY4RiIgLz4KICAgICAgICA8ZmlsdGVyIGlkPSJib3R0b20tbGVmdC1ibHVlIiB4PSItMzQuMzQwMiIgeT0iLTcuNjQ5NDEiIHdpZHRoPSI4MC43NTE5IiBoZWlnaHQ9IjkyLjYxNzIiCiAgICAgICAgICAgIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMTAiIC8+CiAgICAgICAgPC9maWx0ZXI+CiAgICA8L2c+CiAgICA8Zz4KICAgICAgICA8cGF0aCBmaWx0ZXI9InVybCgjdG9wLXJpZ2h0LXB1cnBsZSkiCiAgICAgICAgICAgIGQ9Ik01NC4yNDk4IDI3LjQwMDFDMzkuNTA5MSAyOC40NjU5IDI2Ljk4NjUgMTkuMjA0IDI2LjI3OTggNi43MTI5NkMyNS41NzMgLTUuNzc4MDQgMzYuOTQ5NyAtMTYuNzY4IDUxLjY5MDMgLTE3LjgzMzhDNjYuNDMxIC0xOC44OTk3IDk3LjQyNDYgMTMuMzgzMSA5OC4xMzE0IDI1Ljg3NDFDOTguODM4MSAzOC4zNjUxIDY4Ljk5MDQgMjYuMzM0MiA1NC4yNDk4IDI3LjQwMDFaIgogICAgICAgICAgICBmaWxsPSIjRkY0M0NBIiAvPgogICAgICAgIDxmaWx0ZXIgaWQ9InRvcC1yaWdodC1wdXJwbGUiIHg9IjYuMjQ4NTIiIHk9Ii0zNy44NTk2IiB3aWR0aD0iMTExLjg5NSIgaGVpZ2h0PSI4OS40NTA2IgogICAgICAgICAgICBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEwIiAvPgogICAgICAgIDwvZmlsdGVyPgogICAgPC9nPgo8L3N2Zz4KICAgIA==";
    te = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyMiAyMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMC40IiB5PSIwLjQiIHdpZHRoPSIyMS4yIiBoZWlnaHQ9IjIxLjIiIHJ4PSIxMC42IiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjAuOCIvPgo8bWFzayBpZD0ibWFzazBfMTg5N18xODg5IiBzdHlsZT0ibWFzay10eXBlOmFscGhhIiBtYXNrVW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4PSIwIiB5PSIwIiB3aWR0aD0iMjIiIGhlaWdodD0iMjIiPgo8cmVjdCB4PSIwLjI0OTc1NiIgeT0iMC41IiB3aWR0aD0iMjEuNTExIiBoZWlnaHQ9IjIxLjUxMSIgcng9IjEwLjc1NTUiIGZpbGw9IiNGNEY1RjkiLz4KPC9tYXNrPgo8ZyBtYXNrPSJ1cmwoI21hc2swXzE4OTdfMTg4OSkiPgo8Y2lyY2xlIG9wYWNpdHk9IjAuMiIgY3g9IjguODc0MDIiIGN5PSI5LjEyNSIgcj0iMy45NzUiIHN0cm9rZT0iI0NFRDBENiIgc3Ryb2tlLXdpZHRoPSIwLjgiLz4KPGNpcmNsZSBvcGFjaXR5PSIwLjIiIGN4PSIxMy4xMjQzIiBjeT0iOS4xMjUiIHI9IjMuOTc1IiBzdHJva2U9IiNDRUQwRDYiIHN0cm9rZS13aWR0aD0iMC44Ii8+CjxwYXRoIG9wYWNpdHk9IjAuMiIgZD0iTTIxLjM0OTMgMjEuNUMyMS4zNDkzIDI1LjMwMzQgMTguNDMwNiAyOC4zNSAxNC44NzQzIDI4LjM1QzExLjMxOCAyOC4zNSA4LjM5OTI3IDI1LjMwMzQgOC4zOTkyNyAyMS41QzguMzk5MjcgMTcuNjk2NiAxMS4zMTggMTQuNjUgMTQuODc0MyAxNC42NUMxOC40MzA2IDE0LjY1IDIxLjM0OTMgMTcuNjk2NiAyMS4zNDkzIDIxLjVaIiBzdHJva2U9IiNDRUQwRDYiIHN0cm9rZS13aWR0aD0iMC44Ii8+CjxwYXRoIG9wYWNpdHk9IjAuMiIgZD0iTTEzLjM0OTUgMjEuNUMxMy4zNDk1IDI1LjMwMzQgMTAuNDMwOCAyOC4zNSA2Ljg3NDUxIDI4LjM1QzMuMzE4MjIgMjguMzUgMC4zOTk1MTIgMjUuMzAzNCAwLjM5OTUxMiAyMS41QzAuMzk5NTEyIDE3LjY5NjYgMy4zMTgyMiAxNC42NSA2Ljg3NDUxIDE0LjY1QzEwLjQzMDggMTQuNjUgMTMuMzQ5NSAxNy42OTY2IDEzLjM0OTUgMjEuNVoiIHN0cm9rZT0iI0NFRDBENiIgc3Ryb2tlLXdpZHRoPSIwLjgiLz4KPGNpcmNsZSBjeD0iMTEiIGN5PSI5IiByPSI0LjEiIHN0cm9rZT0id2hpdGUiIHN0cm9rZS13aWR0aD0iMC44Ii8+CjxwYXRoIGQ9Ik0xNy4zNDkzIDIxLjVDMTcuMzQ5MyAyNS4zMDM0IDE0LjQzMDYgMjguMzUgMTAuODc0MyAyOC4zNUM3LjMxNzk4IDI4LjM1IDQuMzk5MjcgMjUuMzAzNCA0LjM5OTI3IDIxLjVDNC4zOTkyNyAxNy42OTY2IDcuMzE3OTggMTQuNjUgMTAuODc0MyAxNC42NUMxNC40MzA2IDE0LjY1IDE3LjM0OTMgMTcuNjk2NiAxNy4zNDkzIDIxLjVaIiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjAuOCIvPgo8L2c+Cjwvc3ZnPgo=";
    ie = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjEiIGhlaWdodD0iMjEiIHZpZXdCb3g9IjAgMCAyMSAyMSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoCiAgICAgICAgZD0iTTEwLjUgMC41QzQuOTggMC41IDAuNSA0Ljk4IDAuNSAxMC41QzAuNSAxNi4wMiA0Ljk4IDIwLjUgMTAuNSAyMC41QzE2LjAyIDIwLjUgMjAuNSAxNi4wMiAyMC41IDEwLjVDMjAuNSA0Ljk4IDE2LjAyIDAuNSAxMC41IDAuNVpNMTAuNSAxOC41QzYuMDkgMTguNSAyLjUgMTQuOTEgMi41IDEwLjVDMi41IDYuMDkgNi4wOSAyLjUgMTAuNSAyLjVDMTQuOTEgMi41IDE4LjUgNi4wOSAxOC41IDEwLjVDMTguNSAxNC45MSAxNC45MSAxOC41IDEwLjUgMTguNVpNMTUuMDkgNi4wOEw4LjUgMTIuNjdMNS45MSAxMC4wOUw0LjUgMTEuNUw4LjUgMTUuNUwxNi41IDcuNUwxNS4wOSA2LjA4WiIKICAgICAgICBmaWxsPSJ3aGl0ZSIgLz4KPC9zdmc+CiAgICA=";
    oe = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjMiIGhlaWdodD0iMjMiIHZpZXdCb3g9IjAgMCAyMyAyMyIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoCiAgICAgICAgZD0iTTE1Ljk2ODkgOC41MjA4N0wxNC40NzkzIDcuMDMxMjNMMTEuNSAxMC4wMTA1TDguNTIwNzIgNy4wMzEyM0w3LjAzMTA4IDguNTIwODdMMTAuMDEwNCAxMS41MDAxTDcuMDMxMDggMTQuNDc5NEw4LjUyMDcyIDE1Ljk2OTFMMTEuNSAxMi45ODk4TDE0LjQ3OTMgMTUuOTY5MUwxNS45Njg5IDE0LjQ3OTRMMTIuOTg5NiAxMS41MDAxTDE1Ljk2ODkgOC41MjA4N1pNMTguOTQ4MiA0LjA1MTk1QzE0Ljg0NDIgLTAuMDUyMDAyNCA4LjE1NTc2IC0wLjA1MjAwMjcgNC4wNTE4MSA0LjA1MTk1Qy0wLjA1MjE0NTMgOC4xNTU5IC0wLjA1MjE0NTYgMTQuODQ0NCA0LjA1MTgxIDE4Ljk0ODNDOC4xNTU3NiAyMy4wNTIzIDE0Ljg0NDIgMjMuMDUyMyAxOC45NDgyIDE4Ljk0ODNDMjMuMDUyMSAxNC44NDQ0IDIzLjA1MjEgOC4xNTU5MSAxOC45NDgyIDQuMDUxOTVaTTUuNTQxNDUgMTcuNDU4N0MyLjI1Njc5IDE0LjE3NCAyLjI1Njc5IDguODI2MjQgNS41NDE0NSA1LjU0MTU5QzguODI2MSAyLjI1Njk0IDE0LjE3MzkgMi4yNTY5NCAxNy40NTg2IDUuNTQxNTlDMjAuNzQzMiA4LjgyNjI0IDIwLjc0MzIgMTQuMTc0IDE3LjQ1ODYgMTcuNDU4N0MxNC4xNzM5IDIwLjc0MzMgOC44MjYxIDIwLjc0MzMgNS41NDE0NSAxNy40NTg3WiIKICAgICAgICBmaWxsPSJ3aGl0ZSIgLz4KPC9zdmc+CiAgICA=";
    z = {
      pending: "pending",
      success: "success",
      error: "error",
      default: "default"
    };
    A = {
      fail: "fail",
      ignored: "ignored",
      pending: "pending",
      success: "success",
      timedOut: "timedOut",
      cancelled: "cancelled",
      /**
       * Pending commit status is for preauthorization which was signed but not yet successfully committed to the network
       */
      pendingCommit: "pendingCommit"
    };
    Ze = Object.defineProperty;
    Oe = Object.getOwnPropertyDescriptor;
    O = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? Oe(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && Ze(i, r, e), e;
    };
    y = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.status = z.default, this.connected = false, this.fullWidth = false, this.theme = "radix-blue";
      }
      onClick(t) {
        this.dispatchEvent(
          new CustomEvent("onClick", {
            detail: t,
            bubbles: true,
            composed: true
          })
        );
      }
      connectedCallback() {
        super.connectedCallback(), setTimeout(() => {
          const t = this.shadowRoot.querySelector("button");
          this.resizeObserver = new ResizeObserver(() => {
            this.dispatchEvent(
              new CustomEvent("onResize", {
                bubbles: true,
                composed: false,
                detail: t
              })
            );
          }), this.resizeObserver.observe(t);
        });
      }
      disconnectedCallback() {
        var i;
        super.disconnectedCallback();
        const t = this.shadowRoot.querySelector("button");
        (i = this.resizeObserver) == null || i.unobserve(t);
      }
      render() {
        const t = () => this.status === z.pending && this.connected ? import_lit.html`${_} <slot></slot>` : this.status === z.pending ? _ : !this.connected && ["success", "error"].includes(this.status) ? "" : import_lit.html`<slot></slot>`, i = this.status !== "pending" && !this.connected, r = this.connected;
        return import_lit.html`
      <button
        @click=${this.onClick}
        class=${(0, import_class_map.classMap)({
          logo: i,
          gradient: r
        })}
        aria-label="Radix Connect Button"
      >
        ${t()}
      </button>
    `;
      }
    };
    y.styles = [
      R,
      fe,
      import_lit.css`
      :host {
        width: max(var(--radix-connect-button-width, 138px), 40px);
        min-width: 40px;
        display: flex;
        justify-content: flex-end;
        container-type: inline-size;
        user-select: none;
      }

      :host([full-width]) > button {
        width: 100%;
      }

      :host([full-width]) {
        width: 100%;
        display: inline-block;
      }

      ::slotted(*) {
        overflow: hidden;
        display: block;
        white-space: nowrap;
        text-overflow: ellipsis;
        text-align: left;
        width: auto;
      }

      .gradient ::slotted(*) {
        padding: 0 4px;
      }

      button {
        width: max(var(--radix-connect-button-width, 138px), 40px);
        height: var(--radix-connect-button-height, 40px);
        min-width: ${Te}px;
        min-height: ${ve}px;
        border-radius: var(--radix-connect-button-border-radius, 0);
        background-color: var(--radix-connect-button-background);
        border: 1px solid var(--radix-connect-button-border-color);
        color: var(--radix-connect-button-text-color);
        font-size: 14px;
        align-content: center;
        align-items: center;
        font-family: inherit;
        cursor: pointer;
        font-weight: 600;
        transition: background-color 0.1s cubic-bezier(0.45, 0, 0.55, 1);

        display: flex;
        gap: 3px;
        justify-content: center;
        padding: 0 10px;
      }

      button::before {
        min-height: 0.94em;
        min-width: 1.25em;
        display: block;
        -webkit-mask-position: center right;
        mask-position: center right;
        mask-repeat: no-repeat;
        -webkit-mask-repeat: no-repeat;
        background-color: var(--radix-connect-button-text-color);
        width: 16px;
      }

      button:hover {
        background-color: var(--radix-connect-button-background-hover);
      }

      button.logo::before {
        content: '';
        mask-image: url(${(0, import_lit.unsafeCSS)(ee)});
        -webkit-mask-image: url(${(0, import_lit.unsafeCSS)(ee)});
      }

      button.gradient.logo::before {
        background-color: var(--color-light);
      }

      :host([status='pending']) > button.gradient::before {
        display: none;
      }

      button.gradient {
        border: 1px solid transparent;
        background-repeat: no-repeat;
        background-origin: border-box;
        background-size: cover;
        background-position: center;
        background-color: var(--color-radix-blue-2);
        color: var(--color-light);
        background-image: url(${(0, import_lit.unsafeCSS)(Se)});
        padding-right: 7px;
      }

      button.gradient::before {
        content: '';
        background-color: var(--color-light);
      }

      :host([status='default']) > button.gradient::before {
        mask-image: url(${(0, import_lit.unsafeCSS)(te)});
        -webkit-mask-image: url(${(0, import_lit.unsafeCSS)(te)});
        width: 22px;
        min-width: 22px;
        height: 22px;
        -webkit-mask-position: center;
        mask-position: center;
      }

      :host([status='success']) > button::before {
        mask-image: url(${(0, import_lit.unsafeCSS)(ie)});
        -webkit-mask-image: url(${(0, import_lit.unsafeCSS)(ie)});
        width: 22px;
        min-width: 22px;
        height: 22px;
        -webkit-mask-position: center;
        mask-position: center;
      }

      :host([status='error']) > button::before {
        mask-image: url(${(0, import_lit.unsafeCSS)(oe)});
        -webkit-mask-image: url(${(0, import_lit.unsafeCSS)(oe)});
        width: 22px;
        min-width: 22px;
        height: 22px;
        -webkit-mask-position: center;
        mask-position: center;
      }

      button.gradient:hover {
        background-color: var(--color-radix-blue-1);
      }

      button:focus,
      button:focus-visible {
        outline: 0px auto -webkit-focus-ring-color;
      }

      @container (width < ${G - 0.1}px) {
        button {
          width: var(--radix-connect-button-height, 40px);
          max-width: ${G}px;
          max-height: ${G}px;
          justify-content: center;
          padding: 0;
        }
        button::before {
          -webkit-mask-position: center;
          mask-position: center;
        }
        button.gradient {
          background-image: url(${(0, import_lit.unsafeCSS)(Ee)});
          padding: 0;
        }
        button.logo::before {
          font-size: 16px;
        }
        ::slotted(*) {
          display: none;
        }
      }
    `
    ];
    O([
      (0, import_decorators.property)({
        type: String,
        reflect: true
      })
    ], y.prototype, "status", 2);
    O([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], y.prototype, "connected", 2);
    O([
      (0, import_decorators.property)({
        type: Boolean,
        reflect: true
      })
    ], y.prototype, "fullWidth", 2);
    O([
      (0, import_decorators.property)({
        type: String,
        reflect: true
      })
    ], y.prototype, "theme", 2);
    y = O([
      (0, import_decorators.customElement)("radix-button")
    ], y);
    re = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNCAyNSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8xMDU5Xzg3NikiPgogICAgICAgIDxwYXRoCiAgICAgICAgICAgIGQ9Ik0xMiAyLjVDNi40OCAyLjUgMiA2Ljk4IDIgMTIuNUMyIDE4LjAyIDYuNDggMjIuNSAxMiAyMi41QzE3LjUyIDIyLjUgMjIgMTguMDIgMjIgMTIuNUMyMiA2Ljk4IDE3LjUyIDIuNSAxMiAyLjVaTTEyIDIwLjVDNy41OCAyMC41IDQgMTYuOTIgNCAxMi41QzQgOC4wOCA3LjU4IDQuNSAxMiA0LjVDMTYuNDIgNC41IDIwIDguMDggMjAgMTIuNUMyMCAxNi45MiAxNi40MiAyMC41IDEyIDIwLjVaIgogICAgICAgICAgICBmaWxsPSIjMDAzMDU3IiAvPgogICAgPC9nPgogICAgPGRlZnM+CiAgICAgICAgPGNsaXBQYXRoIGlkPSJjbGlwMF8xMDU5Xzg3NiI+CiAgICAgICAgICAgIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMC41KSIgLz4KICAgICAgICA8L2NsaXBQYXRoPgogICAgPC9kZWZzPgo8L3N2Zz4KICAgIA==";
    ae = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzYxNF8yODQ4KSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMiAxMkMyIDYuNDggNi40OCAyIDEyIDJDMTcuNTIgMiAyMiA2LjQ4IDIyIDEyQzIyIDE3LjUyIDE3LjUyIDIyIDEyIDIyQzYuNDggMjIgMiAxNy41MiAyIDEyWk03LjgxNjYxIDEyLjAwMDlMMTAuMjQ5MSAxNC40MzM0TDE2LjQyNjYgOC4yNjE3MkwxNy4yNDkxIDkuMDg0MjJMMTAuMjQ5MSAxNi4wODQyTDYuOTg4MjggMTIuODIzNEw3LjgxNjYxIDEyLjAwMDlaIiBmaWxsPSIjMDAzMDU3Ii8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfNjE0XzI4NDgiPgo8cmVjdCB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==";
    ne = "data:image/svg+xml;base64,Cjxzdmcgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0xMiwxQTExLDExLDAsMSwwLDIzLDEyLDExLDExLDAsMCwwLDEyLDFabTAsMTlhOCw4LDAsMSwxLDgtOEE4LDgsMCwwLDEsMTIsMjBaIiBvcGFjaXR5PSIuMjUiLz4KPHBhdGggZD0iTTEwLjE0LDEuMTZhMTEsMTEsMCwwLDAtOSw4LjkyQTEuNTksMS41OSwwLDAsMCwyLjQ2LDEyLDEuNTIsMS41MiwwLDAsMCw0LjExLDEwLjdhOCw4LDAsMCwxLDYuNjYtNi42MUExLjQyLDEuNDIsMCwwLDAsMTIsMi42OWgwQTEuNTcsMS41NywwLDAsMCwxMC4xNCwxLjE2WiIvPgo8L3N2Zz4=";
    se = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIj4KICA8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfNjE0XzI4NDkpIj4KICAgIDxwYXRoIGQ9Ik0xMiAyQzYuNDggMiAyIDYuNDggMiAxMkMyIDE3LjUyIDYuNDggMjIgMTIgMjJDMTcuNTIgMjIgMjIgMTcuNTIgMjIgMTJDMjIgNi40OCAxNy41MiAyIDEyIDJaTSAxMS4xOTQzIDEyIEwgOCA4LjgwNTcxIEwgOC44MDU3MSA4IEwgMTIgMTEuMTk0MyBMIDE1LjE5NDMgOCBMIDE2IDguODA1NzEgTCAxMi44MDU3IDEyIEwgMTYgMTUuMTk0MyBMIDE1LjE5NDMgMTYgTCAxMiAxMi44MDU3IEwgOC44MDU3MSAxNiBMIDggMTUuMTk0MyBaIiBmaWxsPSIjOEE4RkE0Ii8+CiAgPC9nPgogIDxkZWZzPgogICAgPGNsaXBQYXRoIGlkPSJjbGlwMF82MTRfMjg0OSI+CiAgICAgIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiLz4KICAgIDwvY2xpcFBhdGg+CiAgPC9kZWZzPgo8L3N2Zz4=";
    ge = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzI4MjJfMTkzMykiPgo8cGF0aCBkPSJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJDMiAxNy41MiA2LjQ4IDIyIDEyIDIyQzE3LjUyIDIyIDIyIDE3LjUyIDIyIDEyQzIyIDYuNDggMTcuNTIgMiAxMiAyWk0xNyAxM0g3VjExSDE3VjEzWiIgZmlsbD0iIzAwMzA1NyIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzI4MjJfMTkzMyI+CjxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K";
    Pe = (t) => {
      const i = /* @__PURE__ */ new Date();
      return t.getDate() == i.getDate() && t.getMonth() == i.getMonth() && t.getFullYear() == i.getFullYear();
    };
    Ge = (t) => {
      const i = /* @__PURE__ */ new Date();
      return i.setDate(i.getDate() - 1), t.getDate() == i.getDate() && t.getMonth() == i.getMonth() && t.getFullYear() == i.getFullYear();
    };
    ue = (t, i = " ") => {
      const r = new Date(Number(t)), o = Pe(r), e = Ge(r), a = r.toLocaleTimeString("en-Gb", {
        // en-GB is causing midnight to be 00:00
        hour: "numeric",
        minute: "numeric",
        hour12: false
      });
      return o ? `Today${i}${a}` : e ? `Yesterday${i}${a}` : `${r.getDate()} ${r.toLocaleString("en-US", {
        month: "short"
      })}${i}${a}`;
    };
    Ue = Object.defineProperty;
    Ye = Object.getOwnPropertyDescriptor;
    V = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? Ye(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && Ue(i, r, e), e;
    };
    v = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.header = "";
      }
      render() {
        const t = () => this.timestamp ? import_lit.html`<div class="timestamp">${ue(this.timestamp)}</div>` : "", i = `${this.icon ? "30px" : ""} 1fr ${this.timestamp ? "42px" : ""}`;
        return import_lit.html`<div class="card" style="${(0, import_style_map.styleMap)({ gridTemplateColumns: i })}"><i></i><div class="content"><span>${this.header}</span><slot></slot></div>${t()}</div>`;
      }
    };
    v.styles = [
      import_lit.css`:host{background-color:var(--radix-card-background);color:var(--radix-card-text-color);display:block;padding:11px 20px;user-select:none;border-radius:12px;width:100%;box-sizing:border-box}:host(.inverted){background-color:var(--radix-card-inverted-background);color:var(--radix-card-inverted-text-color)}:host(.inverted) .card i::before{background-color:var(--radix-card-inverted-text-color)}:host(.dimmed) .card i::before{background-color:var(--radix-card-text-dimmed-color)}:host(.dimmed) .content{color:var(--radix-card-text-dimmed-color)}.timestamp{text-align:right;color:var(--radix-card-text-dimmed-color);font-size:12px}.card{display:grid;align-items:center;column-gap:10px}i::before{content:'';display:block;-webkit-mask-size:cover;mask-size:cover;background-color:var(--radix-card-text-color)}span{display:block;font-weight:600;font-size:14px}p{margin:0}:host([icon=unchecked]) i::before{-webkit-mask-image:url('${(0, import_lit.unsafeCSS)(re)}');mask-image:url('${(0, import_lit.unsafeCSS)(re)}');width:24px;height:24px}:host([icon=pending]) i::before{-webkit-mask-image:url('${(0, import_lit.unsafeCSS)(ne)}');mask-image:url('${(0, import_lit.unsafeCSS)(ne)}');width:24px;height:24px;transform-origin:center;animation:spinner .75s infinite linear}@keyframes spinner{100%{transform:rotate(360deg)}}:host([icon=ignored]) i::before{-webkit-mask-image:url('${(0, import_lit.unsafeCSS)(ge)}');mask-image:url('${(0, import_lit.unsafeCSS)(ge)}');width:24px;height:24px}:host([icon=checked]) i::before{-webkit-mask-image:url('${(0, import_lit.unsafeCSS)(ae)}');mask-image:url('${(0, import_lit.unsafeCSS)(ae)}');width:24px;height:24px}:host([icon=error]) i::before{-webkit-mask-image:url('${(0, import_lit.unsafeCSS)(se)}');mask-image:url('${(0, import_lit.unsafeCSS)(se)}');width:24px;height:24px}`
    ];
    V([
      (0, import_decorators.property)({
        type: String,
        reflect: true
      })
    ], v.prototype, "icon", 2);
    V([
      (0, import_decorators.property)({
        type: String
      })
    ], v.prototype, "header", 2);
    V([
      (0, import_decorators.property)({
        type: String,
        reflect: true
      })
    ], v.prototype, "timestamp", 2);
    v = V([
      (0, import_decorators.customElement)("radix-card")
    ], v);
    ce = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIHZpZXdCb3g9IjAgMCAxNiAxNyIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzE0MDNfMTI3MSkiPgo8cGF0aCBkPSJNNS45OTkzNSAzLjgzMzk4VjUuMTY3MzJIMTAuMzkyN0wyLjY2NjAyIDEyLjg5NEwzLjYwNjAyIDEzLjgzNEwxMS4zMzI3IDYuMTA3MzJWMTAuNTAwN0gxMi42NjZWMy44MzM5OEg1Ljk5OTM1WiIgZmlsbD0iIzhBOEZBNCIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzE0MDNfMTI3MSI+CjxyZWN0IHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMC41KSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=";
    We = Object.defineProperty;
    Qe = Object.getOwnPropertyDescriptor;
    xe = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? Qe(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && We(i, r, e), e;
    };
    Y = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.displayText = "";
      }
      render() {
        return import_lit.html`<span class="link">${this.displayText} <i class="icon-north-east-arrow"></i></span>`;
      }
    };
    Y.styles = [
      import_lit.css`.link{color:var(--radix-link-color);font-weight:600;text-decoration:none;display:flex;gap:4px;align-items:center;font-size:14px;cursor:pointer}.icon-north-east-arrow::before{content:'';display:block;-webkit-mask-size:cover;mask-size:cover;background-color:var(--radix-card-text-dimmed-color);-webkit-mask-image:url('${(0, import_lit.unsafeCSS)(ce)}');mask-image:url('${(0, import_lit.unsafeCSS)(ce)}');width:16px;height:16px}`
    ];
    xe([
      (0, import_decorators.property)({
        type: String
      })
    ], Y.prototype, "displayText", 2);
    Y = xe([
      (0, import_decorators.customElement)("radix-link")
    ], Y);
    Ae = "data:image/png;base64,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";
    Be = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTMiIHZpZXdCb3g9IjAgMCAxMyAxMyIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIG9wYWNpdHk9IjAuOCI+CiAgICAgICAgPHBhdGggb3BhY2l0eT0iMC44IgogICAgICAgICAgICBkPSJNOC4xMjQ5OCAwLjU0MTc0OEgyLjE2NjY1QzEuNTcwODEgMC41NDE3NDggMS4wODMzMSAxLjAyOTI1IDEuMDgzMzEgMS42MjUwOFY4LjY2Njc1QzEuMDgzMzEgOC45NjQ2NiAxLjMyNzA2IDkuMjA4NDEgMS42MjQ5OCA5LjIwODQxQzEuOTIyOSA5LjIwODQxIDIuMTY2NjUgOC45NjQ2NiAyLjE2NjY1IDguNjY2NzVWMi4xNjY3NUMyLjE2NjY1IDEuODY4ODMgMi40MTA0IDEuNjI1MDggMi43MDgzMSAxLjYyNTA4SDguMTI0OThDOC40MjI5IDEuNjI1MDggOC42NjY2NSAxLjM4MTMzIDguNjY2NjUgMS4wODM0MUM4LjY2NjY1IDAuNzg1NDk4IDguNDIyOSAwLjU0MTc0OCA4LjEyNDk4IDAuNTQxNzQ4Wk0xMC4yOTE2IDIuNzA4NDFINC4zMzMzMUMzLjczNzQ4IDIuNzA4NDEgMy4yNDk5OCAzLjE5NTkxIDMuMjQ5OTggMy43OTE3NVYxMS4zNzUxQzMuMjQ5OTggMTEuOTcwOSAzLjczNzQ4IDEyLjQ1ODQgNC4zMzMzMSAxMi40NTg0SDEwLjI5MTZDMTAuODg3NSAxMi40NTg0IDExLjM3NSAxMS45NzA5IDExLjM3NSAxMS4zNzUxVjMuNzkxNzVDMTEuMzc1IDMuMTk1OTEgMTAuODg3NSAyLjcwODQxIDEwLjI5MTYgMi43MDg0MVpNOS43NDk5OCAxMS4zNzUxSDQuODc0OThDNC41NzcwNiAxMS4zNzUxIDQuMzMzMzEgMTEuMTMxMyA0LjMzMzMxIDEwLjgzMzRWNC4zMzM0MUM0LjMzMzMxIDQuMDM1NSA0LjU3NzA2IDMuNzkxNzUgNC44NzQ5OCAzLjc5MTc1SDkuNzQ5OThDMTAuMDQ3OSAzLjc5MTc1IDEwLjI5MTYgNC4wMzU1IDEwLjI5MTYgNC4zMzM0MVYxMC44MzM0QzEwLjI5MTYgMTEuMTMxMyAxMC4wNDc5IDExLjM3NTEgOS43NDk5OCAxMS4zNzUxWiIKICAgICAgICAgICAgZmlsbD0id2hpdGUiIC8+CiAgICA8L2c+Cjwvc3ZnPgogICAg";
    Ne = (t) => t ? `${t.slice(0, 4)}...${t.slice(
      t.length - 6,
      t.length
    )}` : "";
    Re = Object.defineProperty;
    He = Object.getOwnPropertyDescriptor;
    k = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? He(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && Re(i, r, e), e;
    };
    N = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.address = "", this.label = "", this.appearanceId = 0, this.tooltipVisible = false, this.copiedTooltipTimeout = 1500;
      }
      disconnectedCallback() {
        this.setTimeoutInstance && clearTimeout(this.setTimeoutInstance), super.disconnectedCallback();
      }
      render() {
        return import_lit.html`<span class="label">${this.label}</span> <a class="address" target="_blank" href="${`${this.address}`}" @click="${(t) => {
          t.preventDefault(), this.dispatchEvent(
            new CustomEvent("onLinkClick", {
              bubbles: true,
              composed: true,
              detail: { type: "account", data: this.address }
            })
          );
        }}">${Ne(this.address)} <button aria-label="Copied!" class="${(0, import_class_map.classMap)({
          "tooltip-wrapper": true,
          "tooltip-visible": this.tooltipVisible
        })}"><i @click="${(t) => {
          t.preventDefault(), t.stopImmediatePropagation(), navigator.clipboard.writeText(this.address), this.tooltipVisible = true, this.setTimeoutInstance = setTimeout(() => {
            this.tooltipVisible = false;
          }, this.copiedTooltipTimeout);
        }}"></i></button></a>`;
      }
    };
    N.styles = [
      import_lit.css`:host{display:flex;width:100%;box-sizing:border-box;justify-content:space-between;margin-top:.5rem;border-radius:12px;color:var(--color-light);font-size:14px;height:40px;align-items:center;padding:0 20px}.tooltip-wrapper{all:unset;display:inline-flex;position:relative}.tooltip-wrapper::after,.tooltip-wrapper::before{transition:opacity .1s ease-out .2s}.tooltip-wrapper::after{background:#000;color:#fff;border-radius:8px;content:attr(aria-label);padding:.5rem 1rem;position:absolute;white-space:nowrap;z-index:10;opacity:0;pointer-events:none;transform:translate(-70%,-30%);bottom:100%}.tooltip-wrapper::before{content:'';position:absolute;z-index:10;opacity:0;pointer-events:none;width:0;height:0;border:8px solid transparent;border-top-color:#000;transform:translate(-15%,25%);bottom:100%}.tooltip-wrapper.tooltip-visible::after,.tooltip-wrapper.tooltip-visible::before{opacity:1}.label{font-weight:600;color:var(--color-light);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-right:10px}a{color:var(--color-light);display:flex;align-items:center;gap:4px;opacity:.8;font-size:12px}i{background-image:url('${(0, import_lit.unsafeCSS)(Be)}');display:inline-block;background-repeat:no-repeat;background-size:cover;background-position:center bottom;width:13px;height:13px}.label,a,i{text-shadow:0 4px 3px rgba(0,0,0,.08)}:host([appearanceId='0']){background:linear-gradient(276.58deg,#01e2a0 -.6%,#052cc0 102.8%)}:host([appearanceId='1']){background:linear-gradient(276.33deg,#ff43ca -14.55%,#052cc0 102.71%)}:host([appearanceId='2']){background:linear-gradient(276.33deg,#20e4ff -14.55%,#052cc0 102.71%)}:host([appearanceId='3']){background:linear-gradient(94.8deg,#00ab84 -1.2%,#052cc0 103.67%)}:host([appearanceId='4']){background:linear-gradient(94.62deg,#ce0d98 -10.14%,#052cc0 104.1%)}:host([appearanceId='5']){background:linear-gradient(276.33deg,#052cc0 -14.55%,#0dcae4 102.71%)}:host([appearanceId='6']){background:linear-gradient(90.89deg,#003057 -2.21%,#03d597 102.16%)}:host([appearanceId='7']){background:linear-gradient(276.23deg,#f31dbe -2.1%,#003057 102.67%)}:host([appearanceId='8']){background:linear-gradient(276.48deg,#003057 -.14%,#052cc0 102.77%)}:host([appearanceId='9']){background:linear-gradient(276.32deg,#1af4b5 -5.15%,#0ba97d 102.7%)}:host([appearanceId='10']){background:linear-gradient(276.23deg,#e225b3 -2.1%,#7e0d5f 102.67%)}:host([appearanceId='11']){background:linear-gradient(276.48deg,#1f48e2 -.14%,#040b72 102.77%)}`
    ];
    k([
      (0, import_decorators.property)({
        type: String
      })
    ], N.prototype, "address", 2);
    k([
      (0, import_decorators.property)({
        type: String
      })
    ], N.prototype, "label", 2);
    k([
      (0, import_decorators.property)({
        type: Number,
        reflect: true
      })
    ], N.prototype, "appearanceId", 2);
    k([
      (0, import_decorators.state)()
    ], N.prototype, "tooltipVisible", 2);
    k([
      (0, import_decorators.state)()
    ], N.prototype, "setTimeoutInstance", 2);
    N = k([
      (0, import_decorators.customElement)("radix-account")
    ], N);
    Ve = Object.defineProperty;
    Xe = Object.getOwnPropertyDescriptor;
    j = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? Xe(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && Ve(i, r, e), e;
    };
    x = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.type = "dataRequest", this.status = "pending", this.showCancel = false, this.showIgnore = false, this.timestamp = "", this.id = "", this.hash = "";
      }
      render() {
        const t = this.getIconFromStatus(), i = this.getStylingFromStatus(), r = {
          sendTransaction: {
            pending: "Pending Transaction",
            fail: "Transaction Failed",
            cancelled: "Transaction Cancelled",
            ignored: "Transaction Ignored",
            success: "Send transaction",
            pendingCommit: "",
            timedOut: "",
            content: import_lit.html`${this.renderHash()} ${this.status === "pending" ? import_lit.html`<div class="request-content">Open your Radix Wallet app to review the transaction ${this.showCancel ? import_lit.html`<div class="cancel" @click="${this.onCancel}">Cancel</div>` : import_lit.html`<div class="cancel" @click="${this.onIgnore}">Ignore</div>`}</div>` : ""}`
          },
          preAuthorizationRequest: {
            pending: "Preauthorization Pending",
            fail: "Preauthorization Failed",
            cancelled: "Preauthorization Cancelled",
            success: "Preauthorization Request",
            ignored: "Preauthorization Ignored",
            pendingCommit: "Preauthorization Lookup",
            timedOut: "Preauthorization Timed Out",
            content: import_lit.html`${this.renderHash()} ${this.status === "pending" ? import_lit.html`<div class="request-content">Open your Radix Wallet app to review the preauthorization ${this.showCancel ? import_lit.html`<div class="cancel" @click="${this.onCancel}">Cancel</div>` : import_lit.html`<div class="cancel" @click="${this.onIgnore}">Ignore</div>`}</div>` : this.status === A.pendingCommit ? import_lit.html`<div class="request-content"><div class="cancel" @click="${this.onIgnore}">Ignore</div></div>` : ""}`
          },
          dataRequest: {
            pending: "Data Request Pending",
            fail: "Data Request Rejected",
            cancelled: "Data Request Rejected",
            ignored: "",
            pendingCommit: "",
            timedOut: "",
            success: "Data Request",
            content: this.getRequestContentTemplate(
              "Open Your Radix Wallet App to complete the request"
            )
          },
          loginRequest: {
            pending: "Login Request Pending",
            fail: "Login Request Rejected",
            cancelled: "Login Request Rejected",
            success: "Login Request",
            ignored: "",
            pendingCommit: "",
            timedOut: "",
            content: this.getRequestContentTemplate(
              "Open Your Radix Wallet App to complete the request"
            )
          },
          proofRequest: {
            pending: "Proof Request Pending",
            fail: "Proof Request Rejected",
            cancelled: "Proof Request Rejected",
            success: "Proof Request",
            ignored: "",
            pendingCommit: "",
            timedOut: "",
            content: this.getRequestContentTemplate(
              "Open Your Radix Wallet App to complete the request"
            )
          }
        };
        return import_lit.html`<radix-card icon="${t}" class="${i}" timestamp="${this.timestamp}" header="${r[this.type][this.status]}">${r[this.type].content}</radix-card>`;
      }
      getRequestContentTemplate(t) {
        return this.status === A.pending ? import_lit.html`<div class="request-content">${t} ${this.showCancel ? import_lit.html`<div class="cancel" @click="${this.onCancel}">Cancel</div>` : ""}</div>` : "";
      }
      hasErrorIcon(t) {
        return [
          A.cancelled,
          A.fail,
          A.ignored
        ].includes(t);
      }
      hasPendingIcon(t) {
        return [A.pending, A.pendingCommit].includes(
          t
        );
      }
      hasIgnoredIcon(t) {
        return [A.ignored, A.timedOut].includes(t);
      }
      getIconFromStatus() {
        return this.hasPendingIcon(this.status) ? "pending" : this.hasIgnoredIcon(this.status) ? "ignored" : this.hasErrorIcon(this.status) ? "error" : "checked";
      }
      getStylingFromStatus() {
        return (0, import_class_map.classMap)({
          dimmed: this.hasErrorIcon(this.status),
          inverted: this.status === "pending"
        });
      }
      onCancel(t) {
        this.dispatchEvent(
          new CustomEvent("onCancelRequestItem", {
            detail: {
              ...t,
              id: this.id
            },
            bubbles: true,
            composed: true
          })
        );
      }
      onIgnore(t) {
        this.dispatchEvent(
          new CustomEvent("onIgnoreTransactionItem", {
            detail: {
              ...t,
              id: this.id
            },
            bubbles: true,
            composed: true
          })
        );
      }
      renderHash() {
        return this.hash ? import_lit.html`<div class="transaction"><span class="text-dimmed">ID:</span><radix-link displayText="${Ne(this.hash)}" @click="${(t) => {
          t.preventDefault(), this.dispatchEvent(
            new CustomEvent("onLinkClick", {
              bubbles: true,
              composed: true,
              detail: {
                type: this.type === "sendTransaction" ? "transaction" : "subintent",
                data: this.hash
              }
            })
          );
        }}"></radix-link></div>` : "";
      }
    };
    x.styles = [
      import_lit.css`:host{display:flex;width:100%}.text-dimmed{color:var(--radix-card-text-dimmed-color);margin-right:5px}.transaction{font-weight:600;text-decoration:none;display:flex;align-items:center;font-size:14px}.cancel{cursor:pointer;text-decoration:underline}.request-content{margin-top:5px;display:flex;flex-direction:column;gap:10px;font-size:14px}`
    ];
    j([
      (0, import_decorators.property)({
        type: String
      })
    ], x.prototype, "type", 2);
    j([
      (0, import_decorators.property)({
        type: String
      })
    ], x.prototype, "status", 2);
    j([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], x.prototype, "showCancel", 2);
    j([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], x.prototype, "showIgnore", 2);
    j([
      (0, import_decorators.property)({
        type: String
      })
    ], x.prototype, "timestamp", 2);
    j([
      (0, import_decorators.property)({
        type: String
      })
    ], x.prototype, "id", 2);
    j([
      (0, import_decorators.property)({
        type: String
      })
    ], x.prototype, "hash", 2);
    x = j([
      (0, import_decorators.customElement)("radix-request-card")
    ], x);
    Je = Object.defineProperty;
    Fe = Object.getOwnPropertyDescriptor;
    be = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? Fe(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && Je(i, r, e), e;
    };
    W = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.requestItems = [];
      }
      render() {
        return (this.requestItems || []).map(
          (t) => import_lit.html`<radix-request-card type="${t.type}" status="${t.status}" id="${t.interactionId}" hash="${t.transactionIntentHash || ""}" ?showCancel="${t.showCancel}" timestamp="${t.createdAt}"></radix-request-card>`
        );
      }
    };
    W.styles = [
      R,
      import_lit.css`:host{display:flex;flex-direction:column;gap:10px}`
    ];
    be([
      (0, import_decorators.property)({ type: Array })
    ], W.prototype, "requestItems", 2);
    W = be([
      (0, import_decorators.customElement)("radix-request-cards")
    ], W);
    Ke = Object.defineProperty;
    qe = Object.getOwnPropertyDescriptor;
    $e = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? qe(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && Ke(i, r, e), e;
    };
    F = class extends import_lit.LitElement {
      render() {
        return import_lit.html`<button><slot></slot></button>`;
      }
    };
    F.styles = [
      import_lit.css`button{transition:background-color .1s cubic-bezier(.45,0,.55,1);border-radius:12px;border:none;background:var(--radix-button-background);color:var(--radix-button-text-color);font-size:14px;font-weight:600;padding:11px;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:5px}button:hover{background:var(--radix-button-background-hover)}button:active{background:var(--radix-button-background-pressed)}:host(.primary) button{background:var(--color-radix-blue-2);color:var(--color-light)}:host(.full) button{width:100%}:host(.disabled) button,:host(.primary.disabled) button{background:var(--radix-button-disabled-background);color:var(--radix-button-disabled-text-color);cursor:default;pointer-events:none}`
    ];
    F = $e([
      (0, import_decorators.customElement)("radix-themed-button")
    ], F);
    _e = Object.defineProperty;
    et = Object.getOwnPropertyDescriptor;
    f = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? et(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && _e(i, r, e), e;
    };
    b = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.isMobile = false, this.status = z.default, this.isWalletLinked = false, this.isExtensionAvailable = false, this.requestItems = [];
      }
      render() {
        let t = this.renderConnectTemplate();
        return !this.isExtensionAvailable && !this.isMobile ? t = this.renderCeNotInstalledTemplate() : !this.isWalletLinked && !this.isMobile ? t = this.renderCeNotLinkedTemplate() : this.status === z.pending && (t = this.renderRequestItemsTemplate()), import_lit.html`<div class="wrapper connect-your-wallet"><img width="44" height="44" src="${Ae}" alt="Radix Logo"> <span class="text connect">Connect Your Radix Wallet</span></div>${t}`;
      }
      renderRequestItemsTemplate() {
        return import_lit.html`<radix-request-cards class="request-cards" .requestItems="${this.requestItems}"></radix-request-cards>`;
      }
      connectNowButtonTemplate() {
        const t = (!this.isExtensionAvailable || !this.isWalletLinked) && !this.isMobile, i = this.isMobile ? import_lit.html`<div class="cta-link"><radix-link displayText="Don't have the Radix Wallet?" @click="${() => {
          this.dispatchEvent(
            new CustomEvent("onLinkClick", {
              bubbles: true,
              composed: true,
              detail: { type: "getWallet" }
            })
          );
        }}"></radix-link></div>` : import_lit.html``;
        return import_lit.html`<radix-themed-button class="${(0, import_class_map.classMap)({
          full: true,
          primary: true,
          disabled: t
        })}" @click="${() => {
          t || this.dispatchEvent(
            new CustomEvent("onConnect", {
              bubbles: true,
              composed: true
            })
          );
        }}">Connect Now</radix-themed-button>${i}`;
      }
      renderCeNotInstalledTemplate() {
        return import_lit.html`<div class="info">Before you can connect your Radix Wallet, you need the Radix Connector browser extension.</div><div class="cta-link"><radix-link displayText="Download and Setup Guide" @click="${() => {
          this.dispatchEvent(
            new CustomEvent("onLinkClick", {
              bubbles: true,
              composed: true,
              detail: { type: "setupGuide" }
            })
          );
        }}"></radix-link></div>${this.connectNowButtonTemplate()}`;
      }
      renderCeNotLinkedTemplate() {
        return import_lit.html`<div class="info">To connect your Radix Wallet, you need to link it to your Radix Connector browser extension using a QR code.</div><radix-themed-button class="primary full" @click="${() => {
          this.dispatchEvent(
            new CustomEvent("onLinkClick", {
              bubbles: true,
              composed: true,
              detail: { type: "showQrCode" }
            })
          );
        }}">Open QR Code to Link Wallet</radix-themed-button><div class="cta-link"><radix-link displayText="Download and Setup Guide" @click="${() => {
          this.dispatchEvent(
            new CustomEvent("onLinkClick", {
              bubbles: true,
              composed: true,
              detail: { type: "setupGuide" }
            })
          );
        }}"></radix-link></div>${this.connectNowButtonTemplate()}`;
      }
      renderConnectTemplate() {
        return import_lit.html`${this.connectNowButtonTemplate()}`;
      }
    };
    b.styles = [
      import_lit.css`:host{width:100%;box-sizing:border-box}.wrapper.connect-your-wallet{display:flex;align-items:center;margin:12px .5rem 1.5rem;line-height:23px;justify-content:center;gap:12px}.request-cards{display:block;max-height:410px;overflow-y:auto}.card{margin-bottom:10px}.info{margin-bottom:20px;padding:0 20px;font-size:14px;line-height:18px;text-align:center}.cta-link{display:flex;justify-content:center;margin:25px 0}.text.connect{color:var(--color-text-primary);font-size:18px;width:7.2rem;font-weight:600;text-align:left}.subtitle{color:var(--radix-card-text-dimmed-color)}.mobile-wrapper{display:flex;flex-direction:column;text-align:center;align-items:center;margin-bottom:18px;margin-top:25px;font-size:14px}.mobile-wrapper .header{font-size:18px;font-weight:600;margin-bottom:5px}.mobile-wrapper .content{font-size:16px;margin-bottom:5px}`
    ];
    f([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], b.prototype, "isMobile", 2);
    f([
      (0, import_decorators.property)({
        type: String
      })
    ], b.prototype, "status", 2);
    f([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], b.prototype, "isWalletLinked", 2);
    f([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], b.prototype, "isExtensionAvailable", 2);
    f([
      (0, import_decorators.property)({
        type: Array
      })
    ], b.prototype, "requestItems", 2);
    b = f([
      (0, import_decorators.customElement)("radix-not-connected-page")
    ], b);
    tt = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMC43MjcyNzMiIHk9IjAuNzI3MjczIiB3aWR0aD0iNjIuNTQ1NSIgaGVpZ2h0PSI2Mi41NDU1IiByeD0iMzEuMjcyNyIgZmlsbD0iI0UyRTVFRCIgc3Ryb2tlPSIjQ0VEMEQ2IiBzdHJva2Utd2lkdGg9IjEuNDU0NTUiLz4KPG1hc2sgaWQ9Im1hc2swXzExMjgxXzQxNDAiIHN0eWxlPSJtYXNrLXR5cGU6YWxwaGEiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjAiIHk9IjEiIHdpZHRoPSI2NCIgaGVpZ2h0PSI2NCAiPgo8cmVjdCB4PSIwLjcyNjU2MiIgeT0iMS4zMzUwOCIgd2lkdGg9IjYyLjU3NzQiIGhlaWdodD0iNjIuNTc3NCIgcng9IjMxLjI4ODciIGZpbGw9IiNGNEY1RjkiLz4KPC9tYXNrPgo8ZyBtYXNrPSJ1cmwoI21hc2swXzExMjgxXzQxNDApIj4KPGNpcmNsZSBvcGFjaXR5PSIwLjIiIGN4PSIyNS44MTcxIiBjeT0iMjYuNTQ1NSIgcj0iMTIiIHN0cm9rZT0iI0NFRDBENiIgc3Ryb2tlLXdpZHRoPSIxLjQ1NDU1Ii8+CjxjaXJjbGUgb3BhY2l0eT0iMC4yIiBjeD0iMzguMTgwNCIgY3k9IjI2LjU0NTUiIHI9IjEyIiBzdHJva2U9IiNDRUQwRDYiIHN0cm9rZS13aWR0aD0iMS40NTQ1NSIvPgo8cGF0aCBvcGFjaXR5PSIwLjIiIGQ9Ik02Mi41NDQyIDYyLjU0NTVDNjIuNTQ0MiA3My44Mjg5IDUzLjg3OTYgODIuOTA5MSA0My4yNzE1IDgyLjkwOTFDMzIuNjYzNCA4Mi45MDkxIDIzLjk5ODggNzMuODI4OSAyMy45OTg4IDYyLjU0NTVDMjMuOTk4OCA1MS4yNjIxIDMyLjY2MzQgNDIuMTgxOSA0My4yNzE1IDQyLjE4MTlDNTMuODc5NiA0Mi4xODE5IDYyLjU0NDIgNTEuMjYyMSA2Mi41NDQyIDYyLjU0NTVaIiBzdHJva2U9IiNDRUQwRDYiIHN0cm9rZS13aWR0aD0iMS40NTQ1NSIvPgo8cGF0aCBvcGFjaXR5PSIwLjIiIGQ9Ik0zOS4yNzE3IDYyLjU0NTVDMzkuMjcxNyA3My44Mjg5IDMwLjYwNzEgODIuOTA5MSAxOS45OTkgODIuOTA5MUM5LjM5MDkgODIuOTA5MSAwLjcyNjI5NiA3My44Mjg5IDAuNzI2Mjk2IDYyLjU0NTVDMC43MjYyOTYgNTEuMjYyMSA5LjM5MDkgNDIuMTgxOSAxOS45OTkgNDIuMTgxOUMzMC42MDcxIDQyLjE4MTkgMzkuMjcxNyA1MS4yNjIxIDM5LjI3MTcgNjIuNTQ1NVoiIHN0cm9rZT0iI0NFRDBENiIgc3Ryb2tlLXdpZHRoPSIxLjQ1NDU1Ii8+CjxjaXJjbGUgY3g9IjMxLjk5OTEiIGN5PSIyNi4xODE5IiByPSIxMi4zNjM2IiBmaWxsPSIjRTJFNUVEIiBmaWxsLW9wYWNpdHk9IjAuNSIgc3Ryb2tlPSIjQ0VEMEQ2IiBzdHJva2Utd2lkdGg9IjEuNDU0NTUiLz4KPHBhdGggZD0iTTUwLjkwODUgNjIuNTQ1NUM1MC45MDg1IDczLjgyODkgNDIuMjQzOSA4Mi45MDkxIDMxLjYzNTcgODIuOTA5MUMyMS4wMjc2IDgyLjkwOTEgMTIuMzYzIDczLjgyODkgMTIuMzYzIDYyLjU0NTVDMTIuMzYzIDUxLjI2MjEgMjEuMDI3NiA0Mi4xODE5IDMxLjYzNTcgNDIuMTgxOUM0Mi4yNDM5IDQyLjE4MTkgNTAuOTA4NSA1MS4yNjIxIDUwLjkwODUgNjIuNTQ1NVoiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xMTI4MV80MTQwKSIgc3Ryb2tlPSIjQ0VEMEQ2IiBzdHJva2Utd2lkdGg9IjEuNDU0NTUiLz4KPC9nPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzExMjgxXzQxNDAiIHgxPSIzMS42MzU3IiB5MT0iNDUuMDkxIiB4Mj0iMzEuNjM1NyIgeTI9IjU3LjgxODIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0UyRTVFRCIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNFMkU1RUQiIHN0b3Atb3BhY2l0eT0iMCIvPgo8L2xpbmVhckdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo=";
    it = Object.defineProperty;
    ot = Object.getOwnPropertyDescriptor;
    P = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? ot(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && it(i, r, e), e;
    };
    m = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.persona = "", this.personaData = [];
      }
      render() {
        return import_lit.html`<radix-card><div class="${(0, import_class_map.classMap)({
          center: (this.personaData || []).length < 2,
          "persona-card": true
        })}"><div class="placeholder"><div class="${(0, import_class_map.classMap)({
          avatar: !!this.avatarUrl
        })}" style="${(0, import_style_map.styleMap)({
          backgroundImage: `url(${(0, import_lit.unsafeCSS)(this.avatarUrl)})`
        })}"></div></div><div class="content"><span class="persona">${this.persona}</span><ul>${(this.personaData || []).map((t) => import_lit.html`<li>${t}</li>`)}</ul></div></div></radix-card>`;
      }
    };
    m.styles = [
      import_lit.css`:host{display:flex;width:100%}.avatar{background-size:cover;background-repeat:no-repeat;background-position:center;border-radius:50%;width:60px;height:60px;align-self:center;border:2px solid var(--radix-avatar-border-color)}.placeholder{width:64px;height:64px;background-image:url('${(0, import_lit.unsafeCSS)(tt)}')}.persona-card{display:grid;gap:20px;align-items:flex-start;grid-template-columns:1fr 230px}.persona-card.center{align-items:center}.persona{font-size:14px;font-weight:600;text-overflow:ellipsis;overflow:hidden;display:block;white-space:nowrap}ul{margin-top:5px;margin-bottom:0;padding-inline-start:20px}li{font-size:12px;word-break:break-word;line-height:18px}`
    ];
    P([
      (0, import_decorators.property)({
        type: String,
        reflect: true
      })
    ], m.prototype, "icon", 2);
    P([
      (0, import_decorators.property)({
        type: String
      })
    ], m.prototype, "persona", 2);
    P([
      (0, import_decorators.property)({
        type: String
      })
    ], m.prototype, "avatarUrl", 2);
    P([
      (0, import_decorators.property)({
        type: Array
      })
    ], m.prototype, "personaData", 2);
    m = P([
      (0, import_decorators.customElement)("radix-persona-card")
    ], m);
    de = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkiIGhlaWdodD0iMTgiIHZpZXdCb3g9IjAgMCAxOSAxOCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8xMTg4XzQyOCkiPgogICAgICAgIDxwYXRoCiAgICAgICAgICAgIGQ9Ik0xMy43Mzc4IDQuNzYyNUMxMi42NTAzIDMuNjc1IDExLjE1NzggMyA5LjUwMDMxIDNDNi4xODUzMSAzIDMuNTA3ODEgNS42ODUgMy41MDc4MSA5QzMuNTA3ODEgMTIuMzE1IDYuMTg1MzEgMTUgOS41MDAzMSAxNUMxMi4yOTc4IDE1IDE0LjYzMDMgMTMuMDg3NSAxNS4yOTc4IDEwLjVIMTMuNzM3OEMxMy4xMjI4IDEyLjI0NzUgMTEuNDU3OCAxMy41IDkuNTAwMzEgMTMuNUM3LjAxNzgxIDEzLjUgNS4wMDAzMSAxMS40ODI1IDUuMDAwMzEgOUM1LjAwMDMxIDYuNTE3NSA3LjAxNzgxIDQuNSA5LjUwMDMxIDQuNUMxMC43NDUzIDQuNSAxMS44NTUzIDUuMDE3NSAxMi42NjUzIDUuODM1TDEwLjI1MDMgOC4yNUgxNS41MDAzVjNMMTMuNzM3OCA0Ljc2MjVaIgogICAgICAgICAgICBmaWxsPSIjMDUyQ0MwIiAvPgogICAgPC9nPgogICAgPGRlZnM+CiAgICAgICAgPGNsaXBQYXRoIGlkPSJjbGlwMF8xMTg4XzQyOCI+CiAgICAgICAgICAgIDxyZWN0IHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuNSkiIC8+CiAgICAgICAgPC9jbGlwUGF0aD4KICAgIDwvZGVmcz4KPC9zdmc+CiAgICA=";
    Ie = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHZpZXdCb3g9IjAgMCAxOCAxOCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8xMTg4XzQyNCkiPgogICAgICAgIDxwYXRoCiAgICAgICAgICAgIGQ9Ik0xMi43NSA1LjI1TDExLjY5MjUgNi4zMDc1TDEzLjYyNzUgOC4yNUg2VjkuNzVIMTMuNjI3NUwxMS42OTI1IDExLjY4NUwxMi43NSAxMi43NUwxNi41IDlMMTIuNzUgNS4yNVpNMyAzLjc1SDlWMi4yNUgzQzIuMTc1IDIuMjUgMS41IDIuOTI1IDEuNSAzLjc1VjE0LjI1QzEuNSAxNS4wNzUgMi4xNzUgMTUuNzUgMyAxNS43NUg5VjE0LjI1SDNWMy43NVoiCiAgICAgICAgICAgIGZpbGw9IiMwNTJDQzAiIC8+CiAgICA8L2c+CiAgICA8ZGVmcz4KICAgICAgICA8Y2xpcFBhdGggaWQ9ImNsaXAwXzExODhfNDI0Ij4KICAgICAgICAgICAgPHJlY3Qgd2lkdGg9IjE4IiBoZWlnaHQ9IjE4IiBmaWxsPSJ3aGl0ZSIgLz4KICAgICAgICA8L2NsaXBQYXRoPgogICAgPC9kZWZzPgo8L3N2Zz4KICAgIA==";
    De = import_lit.css`:host{width:100%}.header{font-size:12px;font-weight:400;margin:15px 0;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;width:100%;text-align:center}.content{width:100%;overflow-y:auto;overflow-x:hidden;margin-bottom:0;position:relative;min-height:100px;padding-bottom:10px;mask-image:linear-gradient(0deg,transparent 0,#000 10px);max-height:min(calc(100vh - 270px),360px)}`;
    rt = Object.defineProperty;
    at = Object.getOwnPropertyDescriptor;
    S = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? at(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && rt(i, r, e), e;
    };
    D = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.avatarUrl = "", this.persona = "", this.dAppName = "", this.personaData = [], this.accounts = [];
      }
      onUpdateData(t) {
        this.dispatchEvent(
          new CustomEvent("onUpdateData", {
            detail: t,
            bubbles: true,
            composed: true
          })
        );
      }
      onLogout(t) {
        this.dispatchEvent(
          new CustomEvent("onLogout", {
            detail: t,
            bubbles: true,
            composed: true
          })
        );
      }
      render() {
        var t, i;
        return import_lit.html`<div class="header">Sharing with ${this.dAppName || "dApp"}</div><div class="content"><radix-persona-card avatarUrl="${this.avatarUrl}" persona="${this.persona}" .personaData="${this.personaData}"></radix-persona-card><div>${(this.accounts || []).map(
          ({ label: r, address: o, appearanceId: e }) => import_lit.html`<radix-account label="${r}" address="${o}" appearanceId="${e}"></radix-account>`
        )}</div></div><div class="buttons"><radix-themed-button class="${(0, import_class_map.classMap)({
          full: true,
          disabled: ((t = this.accounts) == null ? void 0 : t.length) === 0
        })}" @click="${this.onUpdateData}"><div class="${(0, import_class_map.classMap)({
          icon: true,
          "update-data": true,
          disabled: ((i = this.accounts) == null ? void 0 : i.length) === 0
        })}"></div>Update Account Sharing</radix-themed-button><radix-themed-button class="full" @click="${this.onLogout}"><div class="icon logout"></div>Log Out</radix-themed-button></div>`;
      }
    };
    D.styles = [
      De,
      import_lit.css`:host{width:100%}.icon::before{content:'';-webkit-mask-position:center;mask-position:center;-webkit-mask-size:cover;mask-size:cover;background:var(--radix-button-text-color);display:block;width:20px;height:20px}.icon.disabled::before{background:var(--radix-button-disabled-text-color)}.buttons{display:grid;bottom:0;width:100%;grid-template-columns:1fr 115px;grid-gap:10px;width:100%;padding-top:10px;align-items:end}.update-data::before{-webkit-mask-image:url('${(0, import_lit.unsafeCSS)(de)}');mask-image:url('${(0, import_lit.unsafeCSS)(de)}')}.logout::before{-webkit-mask-image:url('${(0, import_lit.unsafeCSS)(Ie)}');mask-image:url('${(0, import_lit.unsafeCSS)(Ie)}')}`
    ];
    S([
      (0, import_decorators.property)({
        type: String
      })
    ], D.prototype, "avatarUrl", 2);
    S([
      (0, import_decorators.property)({
        type: String
      })
    ], D.prototype, "persona", 2);
    S([
      (0, import_decorators.property)({
        type: String
      })
    ], D.prototype, "dAppName", 2);
    S([
      (0, import_decorators.property)({
        type: Array
      })
    ], D.prototype, "personaData", 2);
    S([
      (0, import_decorators.property)({
        type: Array
      })
    ], D.prototype, "accounts", 2);
    D = S([
      (0, import_decorators.customElement)("radix-sharing-page")
    ], D);
    nt = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzc1IiBoZWlnaHQ9IjU1OSIgdmlld0JveD0iMCAwIDM3NSA1NTkiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8yXzUzKSI+CjxwYXRoIGQ9Ik0wIDBIMzc1VjU1OUgwVjBaIiBmaWxsPSJ3aGl0ZSIvPgo8cmVjdCB3aWR0aD0iMzc1IiBoZWlnaHQ9IjU1OSIgZmlsbD0iIzA1MkNDMCIvPgo8bWFzayBpZD0ibWFzazBfMl81MyIgc3R5bGU9Im1hc2stdHlwZTphbHBoYSIgbWFza1VuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeD0iMCIgeT0iMCIgd2lkdGg9IjM3NSIgaGVpZ2h0PSI1NTkiPgo8cmVjdCB3aWR0aD0iMzc1IiBoZWlnaHQ9IjU1OSIgZmlsbD0iIzA1MkNDMCIvPgo8L21hc2s+CjxnIG1hc2s9InVybCgjbWFzazBfMl81MykiPgo8ZyBmaWx0ZXI9InVybCgjZmlsdGVyMF9mXzJfNTMpIj4KPHBhdGggZD0iTTE0OC42NTkgLTM5NS4xMzJDMTQ2LjY1MSAtNDczLjIzOSAyMTguMDY2IC0zODkuODg2IDMwOC4xNjkgLTIwOC45NTZDMzk4LjI3MSAtMjguMDI2NSA0NzIuOTQyIDE4MS45NjUgNDc0Ljk0OSAyNjAuMDcyQzQ3Ni45NTcgMzM4LjE4IDIzMi44OTUgLTUuOTMyMTggMTQyLjc5MiAtMTg2Ljg2MkM1Mi42ODkzIC0zNjcuNzkxIDE1MC42NjYgLTMxNy4wMjQgMTQ4LjY1OSAtMzk1LjEzMloiIGZpbGw9IiMyMEU0RkYiLz4KPC9nPgo8ZyBmaWx0ZXI9InVybCgjZmlsdGVyMV9mXzJfNTMpIj4KPHBhdGggZD0iTTExNC41ODIgNDUwLjgyNEMxNzQuNzcgMzQ1Ljk1NiAyMzAuMzU4IDUxNi45NTYgMjM4Ljc0MSA4MzIuNzYzQzI0Ny4xMjUgMTE0OC41NyAxNzQuNzY5IDU0Ny42MzIgMTE0LjU4MSA2NTIuNUM1NC4zOTI5IDc1Ny4zNjggLTU2LjkzMDUgMTAzNi42OSAtNjUuMzE0MSA3MjAuODc4Qy03My42OTc2IDQwNS4wNzEgNTQuMzkzOCA1NTUuNjkxIDExNC41ODIgNDUwLjgyNFoiIGZpbGw9IiMwNjBGOEYiLz4KPC9nPgo8ZyBmaWx0ZXI9InVybCgjZmlsdGVyMl9mXzJfNTMpIj4KPHBhdGggZD0iTS04MC4yMjgyIDY4NS4yODJDLTEwNC41NDggODk1LjQwOSAtMjAwLjA5NiA4MzYuOTM4IC0yMjAuMDYxIDY4NS4yODFDLTI0MC4wMjUgNTMzLjYyMyAtMzYxLjg4MiA2NjUuNDYyIC0zMzcuNTYyIDQ1NS4zMzVDLTMxMy4yNDIgMjQ1LjIwNyAxMDYuNDc0IDE1MC4xNzcgMTI2LjQzOSAzMDEuODM0QzE0Ni40MDQgNDUzLjQ5MiAtNTUuOTA4NCA0NzUuMTU0IC04MC4yMjgyIDY4NS4yODJaIiBmaWxsPSIjMjFGRkJFIi8+CjwvZz4KPC9nPgo8ZyBmaWx0ZXI9InVybCgjZmlsdGVyM19mXzJfNTMpIj4KPHBhdGggZD0iTTM2Ny43NTQgMTY4LjI0NEMzNzQuMTIzIDM5LjMyMjEgNTExLjI1NCA4MC43NDQxIDUxMS4yNTQgMTE1LjI0NEM1NjYuMzk2IDI5NC4wMzIgNDc3LjI3NCA1MzkuMjU5IDQ3MC45MDUgNjY4LjE4MUM0NjQuNTM2IDc5Ny4xMDMgMzAwLjIgNTU5LjAxOSAyNDUuMDU4IDM4MC4yMzFDMTg5LjkxNiAyMDEuNDQyIDM2MS4zODUgMjk3LjE2NiAzNjcuNzU0IDE2OC4yNDRaIiBmaWxsPSIjRkY0M0NBIi8+CjwvZz4KPC9nPgo8ZGVmcz4KPGZpbHRlciBpZD0iZmlsdGVyMF9mXzJfNTMiIHg9Ii00NS4zNzI0IiB5PSItNTc0LjQ0NiIgd2lkdGg9IjY3MC4zMzQiIGhlaWdodD0iOTk1Ljg3IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBoaWMiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9InNoYXBlIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249Ijc1IiByZXN1bHQ9ImVmZmVjdDFfZm9yZWdyb3VuZEJsdXJfMl81MyIvPgo8L2ZpbHRlcj4KPGZpbHRlciBpZD0iZmlsdGVyMV9mXzJfNTMiIHg9Ii0xMTkuNTUzIiB5PSIzNjYuMTEyIiB3aWR0aD0iNDEyLjgwNyIgaGVpZ2h0PSI2MTMuMjA0IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBoaWMiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9InNoYXBlIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjI2LjkyMzMiIHJlc3VsdD0iZWZmZWN0MV9mb3JlZ3JvdW5kQmx1cl8yXzUzIi8+CjwvZmlsdGVyPgo8ZmlsdGVyIGlkPSJmaWx0ZXIyX2ZfMl81MyIgeD0iLTQ5MC43NTciIHk9Ijc3LjUyIiB3aWR0aD0iNzY4LjU3OSIgaGVpZ2h0PSI4OTQuMzA1IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBoaWMiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9InNoYXBlIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249Ijc1IiByZXN1bHQ9ImVmZmVjdDFfZm9yZWdyb3VuZEJsdXJfMl81MyIvPgo8L2ZpbHRlcj4KPGZpbHRlciBpZD0iZmlsdGVyM19mXzJfNTMiIHg9Ijg0LjE0NjgiIHk9Ii02OS42MTcxIiB3aWR0aD0iNTk1LjAyNyIgaGVpZ2h0PSI5MjQuNTIzIiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBoaWMiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9InNoYXBlIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249Ijc1IiByZXN1bHQ9ImVmZmVjdDFfZm9yZWdyb3VuZEJsdXJfMl81MyIvPgo8L2ZpbHRlcj4KPGNsaXBQYXRoIGlkPSJjbGlwMF8yXzUzIj4KPHBhdGggZD0iTTAgMEgzNzVWNTU5SDBWMFoiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==";
    st = Object.defineProperty;
    gt = Object.getOwnPropertyDescriptor;
    he = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? gt(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && st(i, r, e), e;
    };
    Q = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.isBranded = false;
      }
      render() {
        return import_lit.html`<slot></slot>`;
      }
    };
    Q.styles = [
      import_lit.css`:host{position:fixed;top:0;left:0;right:unset;height:100%;width:100%;padding:16px;box-sizing:border-box;backdrop-filter:blur(3px);-webkit-backdrop-filter:blur(3px);display:flex;align-items:center;justify-content:center;transition:opacity .2s;background:var(--radix-mask-background);z-index:2147483647}:host([isBranded]){align-items:flex-start;background:#000;background-image:url('${(0, import_lit.unsafeCSS)(nt)}');background-size:cover}:host(.hide){opacity:0;pointer-events:none}:host(.show){opacity:1}`
    ];
    he([
      (0, import_decorators.property)({
        type: Boolean,
        reflect: true
      })
    ], Q.prototype, "isBranded", 2);
    Q = he([
      (0, import_decorators.customElement)("radix-mask")
    ], Q);
    ct = Object.defineProperty;
    dt = Object.getOwnPropertyDescriptor;
    X = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? dt(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && ct(i, r, e), e;
    };
    T = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.requestItems = [], this.dAppName = "", this.loggedInTimestamp = "";
      }
      render() {
        return import_lit.html`<div class="header">Connected to ${this.dAppName || "dApp"}</div><slot name="subheader"></slot>${this.loggedInTimestamp ? import_lit.html`<div class="subheader">Since logged in: ${ue(this.loggedInTimestamp, ", ")}</div>` : ""}<div class="content"><radix-request-cards .requestItems="${this.requestItems}"></radix-request-cards></div>`;
      }
    };
    T.styles = [
      De,
      import_lit.css`.subheader{color:var(--radix-card-text-dimmed-color);margin-top:-12px;margin-bottom:15px;text-align:center;font-size:12px}`
    ];
    X([
      (0, import_decorators.property)({ type: Array })
    ], T.prototype, "requestItems", 2);
    X([
      (0, import_decorators.property)({
        type: String
      })
    ], T.prototype, "dAppName", 2);
    X([
      (0, import_decorators.property)({
        type: String
      })
    ], T.prototype, "loggedInTimestamp", 2);
    T = X([
      (0, import_decorators.customElement)("radix-requests-page")
    ], T);
    It = Object.defineProperty;
    lt = Object.getOwnPropertyDescriptor;
    p = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? lt(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && It(i, r, e), e;
    };
    I = class extends import_lit.LitElement {
      constructor() {
        super(), this.theme = "radix-blue", this.dAppName = "", this.personaLabel = "", this.connected = false, this.status = z.default, this.loggedInTimestamp = "", this.showPopoverMenu = false, this.requestItems = [], this.accounts = [], this.personaData = [], this.isMobile = false, this.isWalletLinked = false, this.isExtensionAvailable = false, this.fullWidth = false, this.activeTab = "sharing", this.mode = "light", this.avatarUrl = "", this.compact = false, this.pristine = true, this.fontGoogleApiHref = "https://fonts.googleapis.com/css?family=IBM+Plex+Sans:400,600", this.initialBodyOverflow = document.body.style.overflow, this.injectFontCSS(), this.windowClickEventHandler = (t) => {
          this.showPopoverMenu && (this.contains(t.target) || (this.showPopoverMenu = false));
        }, document.addEventListener("click", this.windowClickEventHandler);
      }
      get hasSharedData() {
        return !!(this.accounts.length || this.personaData.length);
      }
      attributeChangedCallback(t, i, r) {
        super.attributeChangedCallback(t, i, r), t === "showpopovermenu" && (this.pristine = false, this.toggleBodyOverflow());
      }
      connectedCallback() {
        super.connectedCallback(), window.dispatchEvent(new Event("onConnectButtonRender")), this.dispatchEvent(
          new CustomEvent("onRender", {
            bubbles: true,
            composed: true
          })
        );
      }
      disconnectedCallback() {
        document.removeEventListener("click", this.windowClickEventHandler), this.dispatchEvent(
          new CustomEvent("onDestroy", {
            bubbles: true,
            composed: true
          })
        );
      }
      injectFontCSS() {
        if (this.shouldSkipFontInjection())
          return;
        const t = document.createElement("link");
        t.setAttribute("rel", "stylesheet"), t.setAttribute("href", this.fontGoogleApiHref), document.head.append(t);
      }
      shouldSkipFontInjection() {
        return !!document.head.querySelector(
          `link[href|="${this.fontGoogleApiHref}"]`
        ) || document.fonts.check("16px IBM Plex Sans");
      }
      togglePopoverMenu() {
        this.pristine = false, this.showPopoverMenu = !this.showPopoverMenu, this.toggleBodyOverflow(), this.showPopoverMenu && this.dispatchEvent(
          new CustomEvent("onShowPopover", {
            bubbles: true,
            composed: true
          })
        );
      }
      toggleBodyOverflow() {
        this.isMobile && (document.body.style.overflow = this.showPopoverMenu && this.isMobile ? "hidden" : this.initialBodyOverflow);
      }
      connectButtonTemplate() {
        const t = this.connected ? this.personaLabel : "Connect";
        return import_lit.html`<radix-button status="${this.status}" theme="${this.theme}" ?connected="${this.connected}" ?fullWidth="${this.fullWidth}" @onClick="${this.togglePopoverMenu}" @onResize="${(i) => {
          this.compact = i.detail.offsetWidth === 40;
        }}"><div>${t}</div></radix-button>`;
      }
      connectTemplate() {
        if (!this.connected)
          return import_lit.html`<radix-not-connected-page status="${this.status}" ?isMobile="${this.isMobile}" .requestItems="${this.requestItems}" ?isWalletLinked="${this.isWalletLinked}" ?isExtensionAvailable="${this.isExtensionAvailable}"></radix-not-connected-page>`;
      }
      renderSharingTemplate() {
        return import_lit.html`<radix-sharing-page dAppName="${this.dAppName}" avatarUrl="${this.avatarUrl}" persona="${this.personaLabel}" .personaData="${(this.personaData || []).map((t) => t.value)}" .accounts="${this.accounts}" @onLogout="${() => {
          this.dispatchEvent(
            new CustomEvent("onDisconnect", {
              bubbles: true,
              composed: true
            })
          );
        }}" @onUpdateData="${() => {
          this.accounts.length && this.dispatchEvent(
            new CustomEvent("onUpdateSharedAccounts", {
              bubbles: true,
              composed: true
            })
          );
        }}"></radix-sharing-page>`;
      }
      renderRequestItemsTemplate() {
        return import_lit.html`<radix-requests-page loggedInTimestamp="${this.loggedInTimestamp}" dAppName="${this.dAppName}" .requestItems="${this.requestItems}"></radix-requests-page>`;
      }
      get showPopoverCloseButton() {
        return this.isMobile;
      }
      popoverTemplate() {
        return this.pristine ? "" : import_lit.html`<radix-popover ?isMobile="${this.isMobile}" ?connected="${this.connected}" ?compact="${this.compact}" ?showCloseButton="${this.showPopoverCloseButton}" @onClosePopover="${() => {
          this.togglePopoverMenu();
        }}" class="${(0, import_class_map2.classMap)({
          show: this.showPopoverMenu,
          hide: !this.showPopoverMenu,
          popoverPosition: !this.isMobile
        })}">${this.renderPopoverContentTemplate()}</radix-popover>`;
      }
      renderPopoverContentTemplate() {
        return this.connected ? import_lit.html`<radix-tabs-menu active="${this.activeTab}" @onClick="${(t) => {
          this.activeTab = t.detail.value;
        }}"></radix-tabs-menu>${this.activeTab === "sharing" ? this.renderSharingTemplate() : this.renderRequestItemsTemplate()}` : this.connectTemplate();
      }
      render() {
        return import_lit.html`${this.connectButtonTemplate()} ${this.isMobile ? import_lit.html`<radix-mask class="${(0, import_class_map2.classMap)({
          show: this.showPopoverMenu,
          hide: !this.showPopoverMenu
        })}">${this.popoverTemplate()}</radix-mask>` : this.popoverTemplate()}`;
      }
    };
    I.styles = [
      Me,
      R,
      import_lit.css`:root{font-family:'IBM Plex Sans';margin:0;font-size:16px;line-height:24px;font-weight:400;color-scheme:light dark;color:rgba(255,255,255,.87);font-synthesis:none;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-text-size-adjust:100%}:host{all:initial;text-align:left;font-family:'IBM Plex Sans';position:relative;z-index:1000;display:inline-block}.mobile-wrapper{display:flex;flex-direction:column;text-align:center;align-items:center;margin-bottom:18px;margin-top:25px;font-size:14px}.mobile-wrapper .header{font-size:18px;font-weight:600;margin-bottom:5px}.mobile-wrapper .content{font-size:16px;margin-bottom:5px}.popoverPosition{position:absolute;top:calc(100% + .5rem);right:0}`
    ];
    p([
      (0, import_decorators.property)({
        type: String
      })
    ], I.prototype, "theme", 2);
    p([
      (0, import_decorators.property)({ type: String })
    ], I.prototype, "dAppName", 2);
    p([
      (0, import_decorators.property)({ type: String })
    ], I.prototype, "personaLabel", 2);
    p([
      (0, import_decorators.property)({ type: Boolean })
    ], I.prototype, "connected", 2);
    p([
      (0, import_decorators.property)({
        type: String
      })
    ], I.prototype, "status", 2);
    p([
      (0, import_decorators.property)({ type: String })
    ], I.prototype, "loggedInTimestamp", 2);
    p([
      (0, import_decorators.property)({ type: Boolean, reflect: true })
    ], I.prototype, "showPopoverMenu", 2);
    p([
      (0, import_decorators.property)({ type: Array })
    ], I.prototype, "requestItems", 2);
    p([
      (0, import_decorators.property)({ type: Array })
    ], I.prototype, "accounts", 2);
    p([
      (0, import_decorators.property)({
        type: Array
      })
    ], I.prototype, "personaData", 2);
    p([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], I.prototype, "isMobile", 2);
    p([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], I.prototype, "isWalletLinked", 2);
    p([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], I.prototype, "isExtensionAvailable", 2);
    p([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], I.prototype, "fullWidth", 2);
    p([
      (0, import_decorators.property)({
        type: String
      })
    ], I.prototype, "activeTab", 2);
    p([
      (0, import_decorators.property)({ type: String, reflect: true })
    ], I.prototype, "mode", 2);
    p([
      (0, import_decorators.property)({ type: String })
    ], I.prototype, "avatarUrl", 2);
    p([
      (0, import_decorators.property)({ type: Boolean, state: true })
    ], I.prototype, "compact", 2);
    I = p([
      (0, import_decorators.customElement)("radix-connect-button")
    ], I);
    Mt = Object.defineProperty;
    pt = Object.getOwnPropertyDescriptor;
    je = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? pt(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && Mt(i, r, e), e;
    };
    B = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.header = "Radix Wallet Connector";
      }
      render() {
        return import_lit.html`<div class="radix-wallet-connector-card"><div class="radix-wallet-connector-card__logo"><img width="78" height="78" src="${Ae}" alt="Radix Wallet Connector Logo"></div><div class="radix-wallet-connector-card__header">${this.header}</div><slot></slot></div>`;
      }
    };
    B.styles = [
      import_lit.css`.radix-wallet-connector-card{background:#fff;padding:24px;border-radius:16px;position:relative;margin-top:60px;text-align:center;box-shadow:0 4px 7px 0 #00000040}.radix-wallet-connector-card__logo{position:absolute;left:0;right:0}.radix-wallet-connector-card__logo img{width:78px;height:78px;transform:translateY(-66px);box-shadow:0 4px 10px 0 rgba(0,0,0,.25);border-radius:16px}.radix-wallet-connector-card__header{margin-top:32px;margin-bottom:24px;font-size:18px;color:var(--color-grey-2)}`
    ];
    je([
      (0, import_decorators.property)({
        type: String
      })
    ], B.prototype, "header", 2);
    B = je([
      (0, import_decorators.customElement)("radix-wallet-connector-card")
    ], B);
    ut = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzQiIGhlaWdodD0iMjkiIHZpZXdCb3g9IjAgMCAzNCAyOSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE3IDUuOTg1TDI4LjI5NSAyNS41SDUuNzA1TDE3IDUuOTg1Wk0xNyAwTDAuNSAyOC41SDMzLjVMMTcgMFpNMTguNSAyMUgxNS41VjI0SDE4LjVWMjFaTTE4LjUgMTJIMTUuNVYxOEgxOC41VjEyWiIgZmlsbD0iI0YwMDAwMCIvPgo8L3N2Zz4K";
    xt = Object.defineProperty;
    At = Object.getOwnPropertyDescriptor;
    J = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? At(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && xt(i, r, e), e;
    };
    L = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.header = "", this.subheader = "", this.isError = false;
      }
      render() {
        return import_lit.html`<div class="connector-error">${this.isError ? import_lit.html`<img src="${ut}" alt="Warning" width="33">` : ""}<h1 class="${(0, import_class_map.classMap)({ error: this.isError })}">${this.header}</h1>${this.subheader ? import_lit.html`<h3>${this.subheader}</h3>` : ""}</div>`;
      }
    };
    L.styles = [
      import_lit.css`.connector-error{display:flex;align-items:center;flex-direction:column;gap:16px}h1{font-size:24px;font-weight:700;margin:0;color:var(--color-grey-1)}.error{color:#f00000}h3{margin:0;color:var(--color-grey-2);font-size:16px;font-weight:500}`
    ];
    J([
      (0, import_decorators.property)({
        type: String
      })
    ], L.prototype, "header", 2);
    J([
      (0, import_decorators.property)({
        type: String
      })
    ], L.prototype, "subheader", 2);
    J([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], L.prototype, "isError", 2);
    L = J([
      (0, import_decorators.customElement)("radix-wallet-connector-info")
    ], L);
    Nt = Object.defineProperty;
    bt = Object.getOwnPropertyDescriptor;
    E = (t, i, r, o) => {
      for (var e = o > 1 ? void 0 : o ? bt(i, r) : i, a = t.length - 1, n; a >= 0; a--)
        (n = t[a]) && (e = (o ? n(i, r, e) : n(e)) || e);
      return o && e && Nt(i, r, e), e;
    };
    h = class extends import_lit.LitElement {
      constructor() {
        super(...arguments), this.header = "", this.subheader = "", this.isError = false, this.isLoading = false, this.isHidden = true;
      }
      render() {
        return this.isHidden ? import_lit.html`` : import_lit.html`<radix-mask isBranded><radix-wallet-connector-card>${this.isLoading ? import_lit.html`<div class="loading-container"><radix-loading-spinner></radix-loading-spinner></div>` : import_lit.html`<radix-wallet-connector-info header="${this.header}" subheader="${this.subheader}" ?isError="${this.isError}"></radix-wallet-connector-info>`}</radix-wallet-connector-card></radix-mask>`;
      }
    };
    h.styles = [
      Me,
      import_lit.css`.loading-container{display:flex;justify-content:center;padding:18px 0}`
    ];
    E([
      (0, import_decorators.property)({
        type: String
      })
    ], h.prototype, "header", 2);
    E([
      (0, import_decorators.property)({
        type: String
      })
    ], h.prototype, "subheader", 2);
    E([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], h.prototype, "isError", 2);
    E([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], h.prototype, "isLoading", 2);
    E([
      (0, import_decorators.property)({
        type: Boolean
      })
    ], h.prototype, "isHidden", 2);
    h = E([
      (0, import_decorators.customElement)("radix-rcfm-page")
    ], h);
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Account: () => Account,
  AccountProof: () => AccountProof,
  AccountsRequestItem: () => AccountsRequestItem,
  AccountsRequestResponseItem: () => AccountsRequestResponseItem,
  AnswerIO: () => AnswerIO,
  AuthLoginRequestItem: () => AuthLoginRequestItem,
  AuthLoginRequestResponseItem: () => AuthLoginRequestResponseItem,
  AuthLoginWithChallengeRequestItem: () => AuthLoginWithChallengeRequestItem,
  AuthLoginWithChallengeRequestResponseItem: () => AuthLoginWithChallengeRequestResponseItem,
  AuthLoginWithoutChallengeRequestItem: () => AuthLoginWithoutChallengeRequestItem,
  AuthLoginWithoutChallengeRequestResponseItem: () => AuthLoginWithoutChallengeRequestResponseItem,
  AuthRequestItem: () => AuthRequestItem,
  AuthRequestResponseItem: () => AuthRequestResponseItem,
  AuthUsePersonaRequestItem: () => AuthUsePersonaRequestItem,
  CancelRequest: () => CancelRequest,
  CancelWalletInteractionExtensionInteraction: () => CancelWalletInteractionExtensionInteraction,
  ConnectButtonModule: () => ConnectButtonModule,
  ConnectButtonStatus: () => ConnectButtonStatus,
  ConnectButtonSubjects: () => ConnectButtonSubjects,
  ConnectorExtensionModule: () => ConnectorExtensionModule,
  ConnectorExtensionSubjects: () => ConnectorExtensionSubjects,
  Curve25519: () => Curve25519,
  DataRequestBuilder: () => DataRequestBuilder,
  DataRequestStateModule: () => DataRequestStateModule,
  DeepLinkModule: () => DeepLinkModule,
  EnvironmentModule: () => EnvironmentModule,
  ExpireAfterDelay: () => ExpireAfterDelay,
  ExpireAtTime: () => ExpireAtTime,
  ExponentialBackoff: () => ExponentialBackoff,
  ExtensionInteraction: () => ExtensionInteraction,
  GatewayApiService: () => GatewayApiService,
  GatewayModule: () => GatewayModule,
  IceCandidateIO: () => IceCandidateIO,
  IceCandidatePayloadIO: () => IceCandidatePayloadIO,
  IceCandidatesIO: () => IceCandidatesIO,
  IdentityKind: () => IdentityKind,
  IdentityModule: () => IdentityModule,
  LocalStorageModule: () => LocalStorageModule,
  Logger: () => Logger,
  LoginRequestResponseItem: () => LoginRequestResponseItem,
  MessageLifeCycleEvent: () => MessageLifeCycleEvent,
  MessageLifeCycleExtensionStatusEvent: () => MessageLifeCycleExtensionStatusEvent,
  Metadata: () => Metadata,
  NumberOfValues: () => NumberOfValues,
  OfferIO: () => OfferIO,
  OneTimeDataRequestBuilder: () => OneTimeDataRequestBuilder,
  OpenPopupExtensionInteraction: () => OpenPopupExtensionInteraction,
  Persona: () => Persona,
  PersonaDataName: () => PersonaDataName,
  PersonaDataNameVariant: () => PersonaDataNameVariant,
  PersonaDataRequestItem: () => PersonaDataRequestItem,
  PersonaDataRequestResponseItem: () => PersonaDataRequestResponseItem,
  PersonaProof: () => PersonaProof,
  Proof: () => Proof,
  ProofOfOwnershipRequestItem: () => ProofOfOwnershipRequestItem,
  ProofOfOwnershipResponseItem: () => ProofOfOwnershipResponseItem,
  RadixConnectRelayModule: () => RadixConnectRelayModule,
  RadixDappToolkit: () => RadixDappToolkit,
  RadixNetwork: () => RadixNetwork,
  RadixNetworkConfig: () => RadixNetworkConfig,
  RadixNetworkConfigById: () => RadixNetworkConfigById,
  RdtState: () => RdtState,
  RequestItemModule: () => RequestItemModule,
  ResetRequestItem: () => ResetRequestItem,
  SendTransactionItem: () => SendTransactionItem,
  SendTransactionResponseItem: () => SendTransactionResponseItem,
  SessionModule: () => SessionModule,
  SharedData: () => SharedData,
  SignalingServerMessage: () => SignalingServerMessage,
  SignedChallenge: () => SignedChallenge,
  SignedChallengeAccount: () => SignedChallengeAccount,
  SignedChallengePersona: () => SignedChallengePersona,
  Sources: () => Sources,
  StateModule: () => StateModule,
  StatusExtensionInteraction: () => StatusExtensionInteraction,
  SubintentRequestBuilder: () => SubintentRequestBuilder,
  SubintentRequestItem: () => SubintentRequestItem,
  SubintentResponseItem: () => SubintentResponseItem,
  TransactionStatus: () => TransactionStatus,
  TransformRdtDataRequestToWalletRequestInput: () => TransformRdtDataRequestToWalletRequestInput,
  WalletAuthorizedRequestItems: () => WalletAuthorizedRequestItems,
  WalletAuthorizedRequestResponseItems: () => WalletAuthorizedRequestResponseItems,
  WalletData: () => WalletData,
  WalletDataPersonaData: () => WalletDataPersonaData,
  WalletDataPersonaDataEmailAddresses: () => WalletDataPersonaDataEmailAddresses,
  WalletDataPersonaDataFullName: () => WalletDataPersonaDataFullName,
  WalletDataPersonaDataPhoneNumbersAddresses: () => WalletDataPersonaDataPhoneNumbersAddresses,
  WalletInteraction: () => WalletInteraction,
  WalletInteractionExtensionInteraction: () => WalletInteractionExtensionInteraction,
  WalletInteractionFailureResponse: () => WalletInteractionFailureResponse,
  WalletInteractionItems: () => WalletInteractionItems,
  WalletInteractionResponse: () => WalletInteractionResponse,
  WalletInteractionSuccessResponse: () => WalletInteractionSuccessResponse,
  WalletPreAuthorizationItems: () => WalletPreAuthorizationItems,
  WalletPreAuthorizationResponseItems: () => WalletPreAuthorizationResponseItems,
  WalletRequestItems: () => WalletRequestItems,
  WalletRequestModule: () => WalletRequestModule,
  WalletRequestResponseItems: () => WalletRequestResponseItems,
  WalletRequestSdk: () => WalletRequestSdk,
  WalletTransactionItems: () => WalletTransactionItems,
  WalletUnauthorizedRequestItems: () => WalletUnauthorizedRequestItems,
  blake2b: () => blake2b,
  canDataRequestBeResolvedByRdtState: () => canDataRequestBeResolvedByRdtState,
  config: () => config,
  eventType: () => eventType,
  extensionInteractionDiscriminator: () => extensionInteractionDiscriminator,
  fetchWrapper: () => fetchWrapper,
  generateGatewayApiConfig: () => generateGatewayApiConfig,
  generateRolaChallenge: () => generateRolaChallenge,
  messageLifeCycleEventType: () => messageLifeCycleEventType,
  parseJSON: () => parseJSON,
  parseSignedChallenge: () => parseSignedChallenge,
  personaDataFullNameVariant: () => personaDataFullNameVariant,
  proofType: () => proofType,
  removeUndefined: () => removeUndefined,
  stringify: () => stringify,
  toWalletRequest: () => toWalletRequest,
  transformRdtDataRequestToWalletRequest: () => transformRdtDataRequestToWalletRequest,
  transformSharedDataToDataRequestState: () => transformSharedDataToDataRequestState,
  transformWalletDataToConnectButton: () => transformWalletDataToConnectButton,
  transformWalletRequestToSharedData: () => transformWalletRequestToSharedData,
  transformWalletResponseToRdtWalletData: () => transformWalletResponseToRdtWalletData,
  typedError: () => typedError2,
  unwrapObservable: () => unwrapObservable,
  validateRolaChallenge: () => validateRolaChallenge,
  validateWalletResponse: () => validateWalletResponse,
  walletDataDefault: () => walletDataDefault
});
module.exports = __toCommonJS(src_exports);

// src/polyfills.ts
var import_buffer = require("buffer");
var polyfills_default = () => {
  if (!globalThis.Buffer) globalThis.Buffer = import_buffer.Buffer;
};

// src/modules/connect-button/connect-button.module.ts
var import_rxjs15 = require("rxjs");

// src/modules/connect-button/subjects.ts
var import_rxjs = require("rxjs");
var ConnectButtonSubjects = (input) => ({
  onConnect: new import_rxjs.Subject(),
  onDisconnect: new import_rxjs.Subject(),
  onUpdateSharedAccounts: new import_rxjs.Subject(),
  connected: new import_rxjs.ReplaySubject(1),
  requestItems: new import_rxjs.BehaviorSubject([]),
  onCancelRequestItem: new import_rxjs.Subject(),
  onIgnoreTransactionItem: new import_rxjs.Subject(),
  accounts: new import_rxjs.BehaviorSubject([]),
  onShowPopover: new import_rxjs.Subject(),
  status: new import_rxjs.BehaviorSubject("default"),
  loggedInTimestamp: new import_rxjs.BehaviorSubject(""),
  isMobile: new import_rxjs.BehaviorSubject(input.providers.environmentModule.isMobile()),
  isWalletLinked: new import_rxjs.BehaviorSubject(false),
  showPopoverMenu: new import_rxjs.BehaviorSubject(false),
  isExtensionAvailable: new import_rxjs.BehaviorSubject(false),
  fullWidth: new import_rxjs.BehaviorSubject(false),
  activeTab: new import_rxjs.BehaviorSubject("sharing"),
  mode: new import_rxjs.BehaviorSubject("light"),
  theme: new import_rxjs.BehaviorSubject("radix-blue"),
  avatarUrl: new import_rxjs.BehaviorSubject(""),
  personaLabel: new import_rxjs.BehaviorSubject(""),
  personaData: new import_rxjs.BehaviorSubject([]),
  dAppName: new import_rxjs.BehaviorSubject(""),
  onLinkClick: new import_rxjs.Subject()
});

// src/modules/wallet-request/crypto/curve25519.ts
var import_ed25519 = require("@noble/curves/ed25519");
var import_buffer2 = require("buffer");
var import_neverthrow = require("neverthrow");

// ../../node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`positive integer expected, not ${n}`);
}
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b2, ...lengths) {
  if (!isBytes(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b2.length}`);
}
function hash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(h2.outputLen);
  number(h2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// ../../node_modules/@noble/hashes/esm/utils.js
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  bytes(data);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}

// ../../node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// ../../node_modules/@noble/hashes/esm/hkdf.js
function extract(hash2, ikm, salt) {
  hash(hash2);
  if (salt === void 0)
    salt = new Uint8Array(hash2.outputLen);
  return hmac(hash2, toBytes(salt), toBytes(ikm));
}
var HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);
var EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();
function expand(hash2, prk, info, length = 32) {
  hash(hash2);
  number(length);
  if (length > 255 * hash2.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length / hash2.outputLen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  const okm = new Uint8Array(blocks * hash2.outputLen);
  const HMAC2 = hmac.create(hash2, prk);
  const HMACTmp = HMAC2._cloneInto();
  const T2 = new Uint8Array(HMAC2.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T2).update(info).update(HKDF_COUNTER).digestInto(T2);
    okm.set(T2, hash2.outputLen * counter);
    HMAC2._cloneInto(HMACTmp);
  }
  HMAC2.destroy();
  HMACTmp.destroy();
  T2.fill(0);
  HKDF_COUNTER.fill(0);
  return okm.slice(0, length);
}
var hkdf = (hash2, ikm, salt, info, length) => expand(hash2, extract(hash2, ikm, salt), info, length);

// ../../node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
var Chi = (a, b2, c2) => a & b2 ^ ~a & c2;
var Maj = (a, b2, c2) => a & b2 ^ a & c2 ^ b2 & c2;
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// ../../node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T1 = H2 + sigma1 + Chi(E2, F2, G2) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
      const T2 = sigma0 + Maj(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T1 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T1 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

// src/modules/wallet-request/crypto/curve25519.ts
var toHex = (input) => import_buffer2.Buffer.from(input).toString("hex");
var Curve25519 = (privateKeyHex = toHex(import_ed25519.x25519.utils.randomPrivateKey())) => {
  const getPrivateKey = () => privateKeyHex;
  const x25519Api = {
    getPublicKey: () => toHex(import_ed25519.x25519.getPublicKey(privateKeyHex)),
    calculateSharedSecret: (publicKeyHex, dAppDefinitionAddress) => {
      try {
        const sharedSecret = import_ed25519.x25519.getSharedSecret(privateKeyHex, publicKeyHex);
        const derived = hkdf(
          sha256,
          sharedSecret,
          import_buffer2.Buffer.from(dAppDefinitionAddress, "utf-8"),
          "RCfM",
          32
        );
        return (0, import_neverthrow.ok)(toHex(derived));
      } catch (error) {
        return (0, import_neverthrow.err)(error);
      }
    }
  };
  const ed25519Api = {
    getPublicKey: () => toHex(import_ed25519.ed25519.getPublicKey(privateKeyHex)),
    sign: (messageHex) => {
      try {
        return (0, import_neverthrow.ok)(toHex(import_ed25519.ed25519.sign(messageHex, privateKeyHex)));
      } catch (error) {
        return (0, import_neverthrow.err)(error);
      }
    }
  };
  return {
    getPrivateKey,
    x25519: x25519Api,
    ed25519: ed25519Api
  };
};

// src/modules/wallet-request/crypto/blake2b.ts
var import_neverthrow2 = require("neverthrow");
var import_blakejs = __toESM(require("blakejs"), 1);
var import_buffer3 = require("buffer");
var bufferToArrayBuffer = (buffer) => {
  const arrayBuffer = new ArrayBuffer(buffer.length);
  const view = new Uint8Array(arrayBuffer);
  for (let i = 0; i < buffer.length; ++i) {
    view[i] = buffer[i];
  }
  return arrayBuffer;
};
var bufferToUnit8Array = (buffer) => new Uint8Array(bufferToArrayBuffer(buffer));
var blake2b = (input) => {
  try {
    return (0, import_neverthrow2.ok)(import_blakejs.default.blake2bHex(bufferToUnit8Array(input), void 0, 32)).map(
      (hex) => import_buffer3.Buffer.from(hex, "hex")
    );
  } catch (error) {
    return (0, import_neverthrow2.err)(error);
  }
};

// src/modules/wallet-request/data-request/builders/accounts.ts
var import_immer = require("immer");
var import_valibot2 = require("valibot");

// src/schemas/index.ts
var import_valibot = require("valibot");
var Account = (0, import_valibot.object)({
  address: (0, import_valibot.string)(),
  label: (0, import_valibot.string)(),
  appearanceId: (0, import_valibot.number)()
});
var Proof = (0, import_valibot.object)({
  publicKey: (0, import_valibot.string)(),
  signature: (0, import_valibot.string)(),
  curve: (0, import_valibot.union)([(0, import_valibot.literal)("curve25519"), (0, import_valibot.literal)("secp256k1")])
});
var AccountProof = (0, import_valibot.object)({
  accountAddress: (0, import_valibot.string)(),
  proof: Proof
});
var PersonaProof = (0, import_valibot.object)({
  identityAddress: (0, import_valibot.string)(),
  proof: Proof
});
var ProofOfOwnershipRequestItem = (0, import_valibot.object)({
  challenge: (0, import_valibot.string)(),
  identityAddress: (0, import_valibot.optional)((0, import_valibot.string)()),
  accountAddresses: (0, import_valibot.optional)((0, import_valibot.array)((0, import_valibot.string)()))
});
var ProofOfOwnershipResponseItem = (0, import_valibot.object)({
  challenge: (0, import_valibot.string)(),
  proofs: (0, import_valibot.array)((0, import_valibot.union)([AccountProof, PersonaProof]))
});
var Persona = (0, import_valibot.object)({ identityAddress: (0, import_valibot.string)(), label: (0, import_valibot.string)() });
var personaDataFullNameVariant = {
  western: "western",
  eastern: "eastern"
};
var PersonaDataNameVariant = (0, import_valibot.union)([
  (0, import_valibot.literal)(personaDataFullNameVariant.eastern),
  (0, import_valibot.literal)(personaDataFullNameVariant.western)
]);
var PersonaDataName = (0, import_valibot.object)({
  variant: PersonaDataNameVariant,
  familyName: (0, import_valibot.string)(),
  nickname: (0, import_valibot.string)(),
  givenNames: (0, import_valibot.string)()
});
var NumberOfValues = (0, import_valibot.object)({
  quantifier: (0, import_valibot.union)([(0, import_valibot.literal)("exactly"), (0, import_valibot.literal)("atLeast")]),
  quantity: (0, import_valibot.pipe)((0, import_valibot.number)(), (0, import_valibot.minValue)(0, "The number must be at least 0."))
});
var AccountsRequestItem = (0, import_valibot.object)({
  challenge: (0, import_valibot.optional)((0, import_valibot.string)()),
  numberOfAccounts: NumberOfValues
});
var AccountsRequestResponseItem = (0, import_valibot.pipe)(
  (0, import_valibot.object)({
    accounts: (0, import_valibot.array)(Account),
    challenge: (0, import_valibot.optional)((0, import_valibot.string)()),
    proofs: (0, import_valibot.optional)((0, import_valibot.array)(AccountProof))
  }),
  (0, import_valibot.check)((data) => {
    if (data.challenge || data?.proofs) {
      return !!(data.challenge && data?.proofs?.length);
    }
    return true;
  }, "missing challenge or proofs")
);
var PersonaDataRequestItem = (0, import_valibot.object)({
  isRequestingName: (0, import_valibot.optional)((0, import_valibot.boolean)()),
  numberOfRequestedEmailAddresses: (0, import_valibot.optional)(NumberOfValues),
  numberOfRequestedPhoneNumbers: (0, import_valibot.optional)(NumberOfValues)
});
var PersonaDataRequestResponseItem = (0, import_valibot.object)({
  name: (0, import_valibot.optional)(PersonaDataName),
  emailAddresses: (0, import_valibot.optional)((0, import_valibot.array)((0, import_valibot.string)())),
  phoneNumbers: (0, import_valibot.optional)((0, import_valibot.array)((0, import_valibot.string)()))
});
var ResetRequestItem = (0, import_valibot.object)({
  accounts: (0, import_valibot.boolean)(),
  personaData: (0, import_valibot.boolean)()
});
var LoginRequestResponseItem = (0, import_valibot.pipe)(
  (0, import_valibot.object)({
    persona: Persona,
    challenge: (0, import_valibot.optional)((0, import_valibot.string)()),
    proof: (0, import_valibot.optional)(Proof)
  }),
  (0, import_valibot.check)((data) => {
    if (data.challenge || data.proof) {
      return !!(data.challenge && data.proof);
    }
    return true;
  }, "missing challenge or proof")
);
var WalletUnauthorizedRequestItems = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("unauthorizedRequest"),
  oneTimeAccounts: (0, import_valibot.optional)(AccountsRequestItem),
  oneTimePersonaData: (0, import_valibot.optional)(PersonaDataRequestItem)
});
var AuthUsePersonaRequestItem = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("usePersona"),
  identityAddress: (0, import_valibot.string)()
});
var AuthLoginWithoutChallengeRequestItem = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("loginWithoutChallenge")
});
var AuthLoginWithChallengeRequestItem = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("loginWithChallenge"),
  challenge: (0, import_valibot.string)()
});
var AuthLoginRequestItem = (0, import_valibot.union)([
  AuthLoginWithoutChallengeRequestItem,
  AuthLoginWithChallengeRequestItem
]);
var AuthRequestItem = (0, import_valibot.union)([
  AuthUsePersonaRequestItem,
  AuthLoginRequestItem
]);
var WalletAuthorizedRequestItems = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("authorizedRequest"),
  auth: AuthRequestItem,
  reset: (0, import_valibot.optional)(ResetRequestItem),
  proofOfOwnership: (0, import_valibot.optional)(ProofOfOwnershipRequestItem),
  oneTimeAccounts: (0, import_valibot.optional)(AccountsRequestItem),
  ongoingAccounts: (0, import_valibot.optional)(AccountsRequestItem),
  oneTimePersonaData: (0, import_valibot.optional)(PersonaDataRequestItem),
  ongoingPersonaData: (0, import_valibot.optional)(PersonaDataRequestItem)
});
var WalletRequestItems = (0, import_valibot.union)([
  WalletUnauthorizedRequestItems,
  WalletAuthorizedRequestItems
]);
var SendTransactionItem = (0, import_valibot.object)({
  transactionManifest: (0, import_valibot.string)(),
  version: (0, import_valibot.number)(),
  blobs: (0, import_valibot.optional)((0, import_valibot.array)((0, import_valibot.string)())),
  message: (0, import_valibot.optional)((0, import_valibot.string)())
});
var WalletTransactionItems = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("transaction"),
  send: SendTransactionItem
});
var SendTransactionResponseItem = (0, import_valibot.object)({
  transactionIntentHash: (0, import_valibot.string)()
});
var WalletTransactionResponseItems = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("transaction"),
  send: SendTransactionResponseItem
});
var CancelRequest = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("cancelRequest")
});
var ExpireAtTime = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("expireAtTime"),
  unixTimestampSeconds: (0, import_valibot.number)()
});
var ExpireAfterDelay = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("expireAfterDelay"),
  expireAfterSeconds: (0, import_valibot.number)()
});
var SubintentRequestItem = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("subintent"),
  /**
   * Version of the message interface
   */
  version: (0, import_valibot.number)(),
  /**
   * Version of the Transaction Manifest
   */
  manifestVersion: (0, import_valibot.number)(),
  subintentManifest: (0, import_valibot.string)(),
  blobs: (0, import_valibot.optional)((0, import_valibot.array)((0, import_valibot.string)())),
  message: (0, import_valibot.optional)((0, import_valibot.string)()),
  expiration: (0, import_valibot.union)([ExpireAtTime, ExpireAfterDelay])
});
var SubintentResponseItem = (0, import_valibot.object)({
  expirationTimestamp: (0, import_valibot.number)(),
  subintentHash: (0, import_valibot.string)(),
  signedPartialTransaction: (0, import_valibot.string)()
});
var WalletPreAuthorizationItems = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("preAuthorizationRequest"),
  request: (0, import_valibot.optional)(SubintentRequestItem)
});
var WalletInteractionItems = (0, import_valibot.union)([
  WalletRequestItems,
  WalletTransactionItems,
  CancelRequest,
  WalletPreAuthorizationItems
]);
var Metadata = (0, import_valibot.object)({
  version: (0, import_valibot.literal)(2),
  networkId: (0, import_valibot.number)(),
  dAppDefinitionAddress: (0, import_valibot.string)(),
  origin: (0, import_valibot.string)()
});
var WalletInteraction = (0, import_valibot.object)({
  interactionId: (0, import_valibot.string)(),
  metadata: Metadata,
  items: WalletInteractionItems
});
var WalletUnauthorizedRequestResponseItems = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("unauthorizedRequest"),
  oneTimeAccounts: (0, import_valibot.optional)(AccountsRequestResponseItem),
  oneTimePersonaData: (0, import_valibot.optional)(PersonaDataRequestResponseItem)
});
var AuthLoginWithoutChallengeRequestResponseItem = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("loginWithoutChallenge"),
  persona: Persona
});
var AuthLoginWithChallengeRequestResponseItem = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("loginWithChallenge"),
  persona: Persona,
  challenge: (0, import_valibot.string)(),
  proof: Proof
});
var WalletPreAuthorizationResponseItems = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("preAuthorizationResponse"),
  response: (0, import_valibot.optional)(SubintentResponseItem)
});
var AuthLoginRequestResponseItem = (0, import_valibot.union)([
  AuthLoginWithoutChallengeRequestResponseItem,
  AuthLoginWithChallengeRequestResponseItem
]);
var AuthUsePersonaRequestResponseItem = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("usePersona"),
  persona: Persona
});
var AuthRequestResponseItem = (0, import_valibot.union)([
  AuthUsePersonaRequestResponseItem,
  AuthLoginRequestResponseItem
]);
var WalletAuthorizedRequestResponseItems = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("authorizedRequest"),
  auth: AuthRequestResponseItem,
  proofOfOwnership: (0, import_valibot.optional)(ProofOfOwnershipResponseItem),
  oneTimeAccounts: (0, import_valibot.optional)(AccountsRequestResponseItem),
  ongoingAccounts: (0, import_valibot.optional)(AccountsRequestResponseItem),
  oneTimePersonaData: (0, import_valibot.optional)(PersonaDataRequestResponseItem),
  ongoingPersonaData: (0, import_valibot.optional)(PersonaDataRequestResponseItem)
});
var WalletRequestResponseItems = (0, import_valibot.union)([
  WalletUnauthorizedRequestResponseItems,
  WalletAuthorizedRequestResponseItems
]);
var WalletInteractionResponseItems = (0, import_valibot.union)([
  WalletRequestResponseItems,
  WalletTransactionResponseItems,
  WalletPreAuthorizationResponseItems
]);
var WalletInteractionSuccessResponse = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("success"),
  interactionId: (0, import_valibot.string)(),
  items: WalletInteractionResponseItems
});
var WalletInteractionFailureResponse = (0, import_valibot.object)({
  discriminator: (0, import_valibot.literal)("failure"),
  interactionId: (0, import_valibot.string)(),
  error: (0, import_valibot.string)(),
  message: (0, import_valibot.optional)((0, import_valibot.string)())
});
var WalletInteractionResponse = (0, import_valibot.union)([
  WalletInteractionSuccessResponse,
  WalletInteractionFailureResponse
]);
var extensionInteractionDiscriminator = {
  extensionStatus: "extensionStatus",
  openPopup: "openPopup",
  cancelWalletInteraction: "cancelWalletInteraction",
  walletInteraction: "walletInteraction"
};
var StatusExtensionInteraction = (0, import_valibot.object)({
  interactionId: (0, import_valibot.string)(),
  discriminator: (0, import_valibot.literal)(extensionInteractionDiscriminator.extensionStatus)
});
var OpenPopupExtensionInteraction = (0, import_valibot.object)({
  interactionId: (0, import_valibot.string)(),
  discriminator: (0, import_valibot.literal)(extensionInteractionDiscriminator.openPopup)
});
var WalletInteractionExtensionInteraction = (0, import_valibot.object)({
  interactionId: (0, import_valibot.string)(),
  discriminator: (0, import_valibot.literal)(extensionInteractionDiscriminator.walletInteraction),
  interaction: WalletInteraction,
  sessionId: (0, import_valibot.optional)((0, import_valibot.string)())
});
var CancelWalletInteractionExtensionInteraction = (0, import_valibot.object)({
  interactionId: (0, import_valibot.string)(),
  discriminator: (0, import_valibot.literal)(
    extensionInteractionDiscriminator.cancelWalletInteraction
  ),
  metadata: Metadata
});
var ExtensionInteraction = (0, import_valibot.union)([
  StatusExtensionInteraction,
  OpenPopupExtensionInteraction,
  WalletInteractionExtensionInteraction,
  CancelWalletInteractionExtensionInteraction
]);
var messageLifeCycleEventType = {
  extensionStatus: "extensionStatus",
  receivedByExtension: "receivedByExtension",
  receivedByWallet: "receivedByWallet",
  requestCancelSuccess: "requestCancelSuccess",
  requestCancelFail: "requestCancelFail"
};
var MessageLifeCycleExtensionStatusEvent = (0, import_valibot.object)({
  eventType: (0, import_valibot.literal)(messageLifeCycleEventType.extensionStatus),
  interactionId: (0, import_valibot.string)(),
  isWalletLinked: (0, import_valibot.boolean)(),
  isExtensionAvailable: (0, import_valibot.boolean)(),
  canHandleSessions: (0, import_valibot.optional)((0, import_valibot.boolean)())
});
var MessageLifeCycleEvent = (0, import_valibot.object)({
  eventType: (0, import_valibot.union)([
    (0, import_valibot.literal)(messageLifeCycleEventType.extensionStatus),
    (0, import_valibot.literal)(messageLifeCycleEventType.receivedByExtension),
    (0, import_valibot.literal)(messageLifeCycleEventType.receivedByWallet),
    (0, import_valibot.literal)(messageLifeCycleEventType.requestCancelSuccess),
    (0, import_valibot.literal)(messageLifeCycleEventType.requestCancelFail)
  ]),
  interactionId: (0, import_valibot.string)()
});
var IncomingMessage = (0, import_valibot.union)([
  MessageLifeCycleEvent,
  WalletInteractionResponse
]);
var eventType = {
  outgoingMessage: "radix#chromeExtension#send",
  incomingMessage: "radix#chromeExtension#receive"
};
var Offer = (0, import_valibot.literal)("offer");
var Answer = (0, import_valibot.literal)("answer");
var IceCandidate = (0, import_valibot.literal)("iceCandidate");
var IceCandidates = (0, import_valibot.literal)("iceCandidates");
var Types = (0, import_valibot.union)([Offer, Answer, IceCandidate, IceCandidates]);
var Sources = (0, import_valibot.union)([(0, import_valibot.literal)("wallet"), (0, import_valibot.literal)("extension")]);
var SignalingServerMessage = (0, import_valibot.object)({
  requestId: (0, import_valibot.string)(),
  targetClientId: (0, import_valibot.string)(),
  encryptedPayload: (0, import_valibot.string)(),
  source: (0, import_valibot.optional)(Sources),
  // redundant, to be removed
  connectionId: (0, import_valibot.optional)((0, import_valibot.string)())
  // redundant, to be removed
});
var AnswerIO = (0, import_valibot.object)({
  ...SignalingServerMessage.entries,
  method: Answer,
  payload: (0, import_valibot.object)({
    sdp: (0, import_valibot.string)()
  })
});
var OfferIO = (0, import_valibot.object)({
  ...SignalingServerMessage.entries,
  method: Offer,
  payload: (0, import_valibot.object)({
    sdp: (0, import_valibot.string)()
  })
});
var IceCandidatePayloadIO = (0, import_valibot.object)({
  candidate: (0, import_valibot.string)(),
  sdpMid: (0, import_valibot.string)(),
  sdpMLineIndex: (0, import_valibot.number)()
});
var IceCandidateIO = (0, import_valibot.object)({
  ...SignalingServerMessage.entries,
  method: IceCandidate,
  payload: IceCandidatePayloadIO
});
var IceCandidatesIO = (0, import_valibot.object)({
  ...SignalingServerMessage.entries,
  method: IceCandidates,
  payload: (0, import_valibot.array)(IceCandidatePayloadIO)
});

// src/modules/wallet-request/data-request/builders/accounts.ts
var AccountsDataRequestSchema = (0, import_valibot2.object)({
  numberOfAccounts: NumberOfValues,
  withProof: (0, import_valibot2.optional)((0, import_valibot2.boolean)()),
  reset: (0, import_valibot2.optional)((0, import_valibot2.boolean)())
});
var accounts = () => {
  const defaultValue = {
    numberOfAccounts: { quantifier: "atLeast", quantity: 1 }
  };
  let data = (0, import_immer.produce)(defaultValue, () => {
  });
  const atLeast = (n) => {
    data = (0, import_immer.produce)(data, (draft) => {
      draft.numberOfAccounts.quantifier = "atLeast";
      draft.numberOfAccounts.quantity = n;
    });
    return methods;
  };
  const exactly = (n) => {
    data = (0, import_immer.produce)(data, (draft) => {
      draft.numberOfAccounts.quantifier = "exactly";
      draft.numberOfAccounts.quantity = n;
    });
    return methods;
  };
  const reset = (value = true) => {
    data = (0, import_immer.produce)(data, (draft) => {
      draft.reset = value;
    });
    return methods;
  };
  const withProof = (value = true) => {
    data = (0, import_immer.produce)(data, (draft) => {
      draft.withProof = value;
    });
    return methods;
  };
  const _toObject = () => ({
    accounts: data
  });
  const methods = {
    atLeast,
    exactly,
    withProof,
    reset,
    _toObject
  };
  return methods;
};

// src/modules/wallet-request/data-request/builders/persona.ts
var import_immer2 = require("immer");
var import_valibot3 = require("valibot");
var schema = (0, import_valibot3.object)({
  withProof: (0, import_valibot3.optional)((0, import_valibot3.boolean)())
});
var persona = (initialData = {
  withProof: false
}) => {
  let data = (0, import_immer2.produce)(initialData, () => {
  });
  const withProof = (value = true) => {
    data = (0, import_immer2.produce)(data, (draft) => {
      draft.withProof = value;
    });
    return methods;
  };
  const _toObject = () => ({
    persona: data
  });
  const methods = {
    withProof,
    _toObject
  };
  return methods;
};

// src/modules/wallet-request/data-request/builders/persona-data.ts
var import_immer3 = require("immer");
var import_valibot4 = require("valibot");
var PersonaDataRequestSchema = (0, import_valibot4.partial)(
  (0, import_valibot4.object)({
    fullName: (0, import_valibot4.boolean)(),
    emailAddresses: NumberOfValues,
    phoneNumbers: NumberOfValues,
    reset: (0, import_valibot4.boolean)()
  })
);
var personaData = (initialData = {}) => {
  let data = (0, import_immer3.produce)(initialData, () => {
  });
  const fullName = (value = true) => {
    data = (0, import_immer3.produce)(data, (draft) => {
      draft.fullName = value;
    });
    return methods;
  };
  const createNumberOfValuesOptions = (key) => ({
    atLeast: (n) => {
      data = (0, import_immer3.produce)(data, (draft) => {
        draft[key] = { quantifier: "atLeast", quantity: n };
      });
      return methods;
    },
    exactly: (n) => {
      data = (0, import_immer3.produce)(data, (draft) => {
        draft[key] = { quantifier: "exactly", quantity: n };
      });
      return methods;
    }
  });
  const emailAddresses = (value = true) => {
    const options = createNumberOfValuesOptions("emailAddresses");
    options.exactly(value ? 1 : 0);
    return methods;
  };
  const phoneNumbers = (value = true) => {
    const options = createNumberOfValuesOptions("phoneNumbers");
    options.exactly(value ? 1 : 0);
    return methods;
  };
  const reset = (value = true) => {
    data = (0, import_immer3.produce)(data, (draft) => {
      draft.reset = value;
    });
    return methods;
  };
  const _toObject = () => ({
    personaData: data
  });
  const methods = {
    fullName,
    emailAddresses,
    phoneNumbers,
    reset,
    _toObject
  };
  return methods;
};

// src/modules/wallet-request/data-request/builders/proof-of-ownership.ts
var import_immer4 = require("immer");
var import_valibot5 = require("valibot");
var schema2 = (0, import_valibot5.object)({
  accountAddresses: (0, import_valibot5.optional)((0, import_valibot5.array)((0, import_valibot5.string)())),
  identityAddress: (0, import_valibot5.optional)((0, import_valibot5.string)())
});
var proofOfOwnership = (initialData = {}) => {
  let data = (0, import_immer4.produce)(initialData, () => {
  });
  const accounts2 = (value) => {
    data = (0, import_immer4.produce)(data, (draft) => {
      draft.accountAddresses = value;
    });
    return methods;
  };
  const identity = (value) => {
    data = (0, import_immer4.produce)(data, (draft) => {
      draft.identityAddress = value;
    });
    return methods;
  };
  const _toObject = () => ({
    proofOfOwnership: data
  });
  const methods = {
    accounts: accounts2,
    identity,
    _toObject
  };
  return methods;
};

// src/modules/wallet-request/data-request/builders/index.ts
var config = (data) => {
  const _toObject = () => ({ ...data });
  const methods = {
    _toObject
  };
  return methods;
};
var DataRequestBuilder = {
  accounts,
  personaData,
  persona,
  config
};
var OneTimeDataRequestBuilder = {
  accounts,
  personaData,
  proofOfOwnership
};

// src/helpers/is-deep-equal.ts
var isDeepEqual = (a, b2) => {
  const values = [null, void 0, false, true];
  if (values.includes(a) || values.includes(b2) || typeof a === "number" || typeof b2 === "number") {
    return Object.is(a, b2);
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b2);
  if (aKeys.length !== bKeys.length) return false;
  for (const key of aKeys) {
    const value1 = a[key];
    const value2 = b2[key];
    const isObjects = isObject(value1) && isObject(value2);
    if (isObjects && !isDeepEqual(value1, value2) || !isObjects && value1 !== value2) {
      return false;
    }
  }
  return true;
};
var isObject = (x2) => {
  return x2 != null && typeof x2 === "object";
};

// src/modules/wallet-request/data-request/helpers/can-data-request-be-resolved-by-rdt-state.ts
var canDataRequestBeResolvedByRdtState = (dataRequest, state) => {
  if (dataRequest.discriminator === "authorizedRequest") {
    const isReset = dataRequest.reset?.accounts || dataRequest.reset?.personaData;
    const isOneTimeRequest = !!(dataRequest.oneTimeAccounts || dataRequest.oneTimePersonaData);
    const isChallengeRequest = dataRequest.auth.discriminator === "loginWithChallenge" || !!dataRequest.oneTimeAccounts?.challenge || !!dataRequest.ongoingAccounts?.challenge;
    if (isReset || isOneTimeRequest || isChallengeRequest) return false;
    let rdtStateSatisfiesRequest = false;
    if (dataRequest.ongoingAccounts) {
      const { quantifier, quantity } = dataRequest.ongoingAccounts.numberOfAccounts;
      rdtStateSatisfiesRequest = state.sharedData?.ongoingAccounts?.numberOfAccounts?.quantifier === quantifier && state.sharedData?.ongoingAccounts?.numberOfAccounts?.quantity === quantity;
    }
    if (dataRequest.ongoingPersonaData) {
      rdtStateSatisfiesRequest = isDeepEqual(
        dataRequest.ongoingPersonaData,
        state.sharedData?.ongoingPersonaData
      );
    }
    return rdtStateSatisfiesRequest;
  }
  return false;
};

// src/modules/wallet-request/data-request/helpers/to-wallet-request.ts
var import_immer6 = require("immer");

// src/modules/wallet-request/data-request/transformations/rdt-to-wallet.ts
var import_immer5 = require("immer");
var import_neverthrow3 = require("neverthrow");
var import_valibot6 = require("valibot");
var TransformRdtDataRequestToWalletRequestInput = (0, import_valibot6.object)({
  proofOfOwnership: (0, import_valibot6.optional)(
    (0, import_valibot6.object)({
      challenge: (0, import_valibot6.optional)((0, import_valibot6.string)()),
      accountAddresses: (0, import_valibot6.optional)((0, import_valibot6.array)((0, import_valibot6.string)())),
      identityAddress: (0, import_valibot6.optional)((0, import_valibot6.string)())
    })
  ),
  accounts: (0, import_valibot6.optional)(
    (0, import_valibot6.object)({
      numberOfAccounts: NumberOfValues,
      reset: (0, import_valibot6.boolean)(),
      oneTime: (0, import_valibot6.boolean)(),
      challenge: (0, import_valibot6.optional)((0, import_valibot6.string)())
    })
  ),
  personaData: (0, import_valibot6.optional)(
    (0, import_valibot6.object)({
      fullName: (0, import_valibot6.optional)((0, import_valibot6.boolean)()),
      phoneNumbers: (0, import_valibot6.optional)(NumberOfValues),
      emailAddresses: (0, import_valibot6.optional)(NumberOfValues),
      reset: (0, import_valibot6.boolean)(),
      oneTime: (0, import_valibot6.optional)((0, import_valibot6.boolean)())
    })
  ),
  persona: (0, import_valibot6.optional)(
    (0, import_valibot6.object)({
      identityAddress: (0, import_valibot6.optional)((0, import_valibot6.string)()),
      label: (0, import_valibot6.optional)((0, import_valibot6.string)()),
      challenge: (0, import_valibot6.optional)((0, import_valibot6.string)())
    })
  )
});
var isAuthorized = (input) => {
  const { persona: persona2, accounts: accounts2, personaData: personaData2, proofOfOwnership: proofOfOwnership2 } = input;
  const isPersonaLogin = !!persona2;
  const shouldResetData = accounts2?.reset || personaData2?.reset;
  const isOngoingAccountsRequest = accounts2 && !accounts2?.oneTime;
  const isOngoingPersonaDataRequest = personaData2 && !personaData2?.oneTime;
  const isAuthorizedRequest = !!(shouldResetData || isOngoingAccountsRequest || isOngoingPersonaDataRequest || isPersonaLogin || proofOfOwnership2);
  return isAuthorizedRequest;
};
var createLoginRequestItem = (input) => {
  if (input.persona?.challenge) {
    return {
      discriminator: "loginWithChallenge",
      challenge: input.persona.challenge
    };
  }
  if (input.persona?.identityAddress) {
    return {
      discriminator: "usePersona",
      identityAddress: input.persona?.identityAddress
    };
  }
  return {
    discriminator: "loginWithoutChallenge"
  };
};
var withAccountRequestItem = (input) => (requestItems) => {
  const updatedRequestItems = { ...requestItems };
  const { accounts: accounts2 } = input;
  if (accounts2) {
    const data = {
      challenge: accounts2.challenge,
      numberOfAccounts: accounts2.numberOfAccounts
    };
    const isOngoingRequest = updatedRequestItems.discriminator === "authorizedRequest" && !input.accounts?.oneTime;
    const isConnectOngoingRequest = updatedRequestItems.discriminator === "authorizedRequest";
    if (input.accounts?.oneTime) {
      updatedRequestItems["oneTimeAccounts"] = data;
    } else if (isOngoingRequest || isConnectOngoingRequest) {
      updatedRequestItems["ongoingAccounts"] = data;
    }
  }
  return updatedRequestItems;
};
var withProofOfOwnershipRequestItem = (input) => (requestItems) => {
  const updatedRequestItems = { ...requestItems };
  if (input.proofOfOwnership) {
    const { challenge, accountAddresses, identityAddress } = input.proofOfOwnership;
    if (challenge && updatedRequestItems.discriminator === "authorizedRequest") {
      updatedRequestItems["proofOfOwnership"] = {
        challenge
      };
      if (accountAddresses) {
        updatedRequestItems["proofOfOwnership"].accountAddresses = accountAddresses;
      }
      if (identityAddress) {
        updatedRequestItems["proofOfOwnership"].identityAddress = identityAddress;
      }
    }
  }
  return updatedRequestItems;
};
var withPersonaDataRequestItem = (input) => (requestItems) => {
  const updatedRequestItems = { ...requestItems };
  if (input.personaData) {
    const {
      fullName: isRequestingName,
      phoneNumbers: numberOfRequestedPhoneNumbers,
      emailAddresses: numberOfRequestedEmailAddresses
    } = input.personaData;
    if (input.personaData?.oneTime) {
      updatedRequestItems["oneTimePersonaData"] = {
        isRequestingName,
        numberOfRequestedPhoneNumbers,
        numberOfRequestedEmailAddresses
      };
    }
    const isOngoingRequest = updatedRequestItems.discriminator === "authorizedRequest" && !input.personaData?.oneTime;
    const isConnectOngoingRequest = updatedRequestItems.discriminator === "authorizedRequest";
    if (isOngoingRequest || isConnectOngoingRequest) {
      updatedRequestItems["ongoingPersonaData"] = {
        isRequestingName,
        numberOfRequestedPhoneNumbers,
        numberOfRequestedEmailAddresses
      };
    }
  }
  return updatedRequestItems;
};
var withResetRequestItem = (input) => (requestItems) => {
  const { accounts: accounts2, personaData: personaData2 } = input;
  return {
    ...requestItems,
    reset: { accounts: !!accounts2?.reset, personaData: !!personaData2?.reset }
  };
};
var createUnauthorizedRequestItems = (input) => (0, import_neverthrow3.ok)({
  discriminator: "unauthorizedRequest"
}).map(withAccountRequestItem(input)).map(withPersonaDataRequestItem(input)).map(withProofOfOwnershipRequestItem(input));
var createAuthorizedRequestItems = (input) => (0, import_neverthrow3.ok)({
  discriminator: "authorizedRequest",
  auth: createLoginRequestItem(input)
}).map(withAccountRequestItem(input)).map(withPersonaDataRequestItem(input)).map(withResetRequestItem(input)).map(withProofOfOwnershipRequestItem(input));
var transformConnectRequest = (isConnect, input) => (0, import_neverthrow3.ok)(
  isConnect ? (0, import_immer5.produce)(input, (draft) => {
    if (draft.accounts) {
      draft.accounts.oneTime = false;
      draft.accounts.reset = false;
    }
    if (draft.personaData) {
      draft.personaData.oneTime = false;
      draft.personaData.reset = false;
    }
  }) : input
);
var transformRdtDataRequestToWalletRequest = (isConnect, input) => transformConnectRequest(isConnect, input).andThen(
  (transformed) => isAuthorized(transformed) ? createAuthorizedRequestItems(transformed) : createUnauthorizedRequestItems(transformed)
);

// src/modules/wallet-request/data-request/helpers/to-wallet-request.ts
var toWalletRequest = ({
  dataRequestState,
  isConnect,
  challenge,
  oneTime,
  walletData
}) => transformRdtDataRequestToWalletRequest(
  isConnect,
  (0, import_immer6.produce)({}, (draft) => {
    if (dataRequestState.proofOfOwnership) {
      draft.proofOfOwnership = {
        ...dataRequestState.proofOfOwnership,
        challenge
      };
    }
    if (dataRequestState.accounts) {
      draft.accounts = {
        numberOfAccounts: dataRequestState.accounts.numberOfAccounts || {
          quantifier: "atLeast",
          quantity: 1
        },
        oneTime,
        reset: !!dataRequestState.accounts.reset,
        challenge: dataRequestState.accounts.withProof ? challenge : void 0
      };
    }
    if (dataRequestState.personaData)
      draft.personaData = {
        ...dataRequestState.personaData,
        reset: !!dataRequestState.personaData.reset,
        oneTime
      };
    if (!oneTime || dataRequestState.proofOfOwnership) {
      const persona2 = walletData.persona;
      if (walletData.persona) draft.persona = persona2;
      if (dataRequestState.persona?.withProof)
        draft.persona = { ...draft.persona ?? {}, challenge };
      if (Object.values(dataRequestState).length === 0)
        draft.persona = { challenge: void 0 };
    }
  })
);

// src/modules/wallet-request/data-request/transformations/shared-data.ts
var import_immer7 = require("immer");
var transformWalletRequestToSharedData = (walletInteraction, sharedData) => {
  const { items: walletDataRequest } = walletInteraction;
  if (walletDataRequest.discriminator === "authorizedRequest")
    return (0, import_immer7.produce)({}, (draft) => {
      draft.persona = { proof: false };
      if (walletDataRequest.auth.discriminator === "loginWithChallenge")
        draft.persona.proof = !!walletDataRequest.auth.challenge;
      if (walletDataRequest.ongoingAccounts) {
        draft.ongoingAccounts = {
          proof: !!walletDataRequest.ongoingAccounts.challenge,
          numberOfAccounts: walletDataRequest.ongoingAccounts.numberOfAccounts
        };
      }
      if (walletDataRequest.ongoingPersonaData) {
        draft.ongoingPersonaData = walletDataRequest.ongoingPersonaData;
      }
    });
  return sharedData;
};
var transformSharedDataToDataRequestState = (sharedData) => (0, import_immer7.produce)({}, (draft) => {
  if (sharedData.ongoingAccounts) {
    draft.accounts = {
      numberOfAccounts: sharedData.ongoingAccounts.numberOfAccounts,
      withProof: sharedData.ongoingAccounts.proof,
      reset: true
    };
  }
  if (sharedData.ongoingPersonaData) {
    draft.personaData = {
      fullName: sharedData.ongoingPersonaData.isRequestingName,
      phoneNumbers: sharedData.ongoingPersonaData.numberOfRequestedPhoneNumbers,
      emailAddresses: sharedData.ongoingPersonaData.numberOfRequestedEmailAddresses,
      reset: false
    };
  }
  if (sharedData.persona) {
    draft.persona = {
      withProof: false
    };
  }
});

// src/modules/wallet-request/data-request/transformations/wallet-to-rdt.ts
var import_immer8 = require("immer");
var import_neverthrow5 = require("neverthrow");

// src/modules/state/state.module.ts
var import_rxjs2 = require("rxjs");

// src/modules/state/types.ts
var import_valibot7 = require("valibot");
var proofType = {
  persona: "persona",
  account: "account"
};
var SignedChallengePersona = (0, import_valibot7.object)({
  challenge: (0, import_valibot7.string)(),
  proof: Proof,
  address: (0, import_valibot7.string)(),
  type: (0, import_valibot7.literal)(proofType.persona)
});
var SignedChallengeAccount = (0, import_valibot7.object)({
  challenge: (0, import_valibot7.string)(),
  proof: Proof,
  address: (0, import_valibot7.string)(),
  type: (0, import_valibot7.literal)(proofType.account)
});
var SignedChallenge = (0, import_valibot7.variant)("type", [
  SignedChallengePersona,
  SignedChallengeAccount
]);
var WalletDataPersonaDataFullName = (0, import_valibot7.object)({
  entry: (0, import_valibot7.literal)("fullName"),
  fields: PersonaDataName
});
var WalletDataPersonaDataEmailAddresses = (0, import_valibot7.object)({
  entry: (0, import_valibot7.literal)("emailAddresses"),
  fields: (0, import_valibot7.array)((0, import_valibot7.string)())
});
var WalletDataPersonaDataPhoneNumbersAddresses = (0, import_valibot7.object)({
  entry: (0, import_valibot7.literal)("phoneNumbers"),
  fields: (0, import_valibot7.array)((0, import_valibot7.string)())
});
var WalletDataPersonaData = (0, import_valibot7.variant)("entry", [
  WalletDataPersonaDataFullName,
  WalletDataPersonaDataEmailAddresses,
  WalletDataPersonaDataPhoneNumbersAddresses
]);
var WalletData = (0, import_valibot7.object)({
  accounts: (0, import_valibot7.array)(Account),
  personaData: (0, import_valibot7.array)(WalletDataPersonaData),
  persona: (0, import_valibot7.optional)(Persona),
  proofs: (0, import_valibot7.array)(SignedChallenge)
});
var SharedData = (0, import_valibot7.object)({
  persona: (0, import_valibot7.optional)((0, import_valibot7.object)({ proof: (0, import_valibot7.boolean)() })),
  ongoingAccounts: (0, import_valibot7.optional)(
    (0, import_valibot7.object)({
      numberOfAccounts: (0, import_valibot7.optional)(NumberOfValues),
      proof: (0, import_valibot7.boolean)()
    })
  ),
  ongoingPersonaData: (0, import_valibot7.optional)(PersonaDataRequestItem)
});
var RdtState = (0, import_valibot7.object)({
  loggedInTimestamp: (0, import_valibot7.string)(),
  walletData: WalletData,
  sharedData: SharedData
});
var walletDataDefault = {
  accounts: [],
  personaData: [],
  proofs: [],
  persona: void 0
};

// src/modules/state/state.module.ts
var import_neverthrow4 = require("neverthrow");
var StateModule = (input) => {
  const logger = input?.logger?.getSubLogger({ name: "StateModule" });
  const storageModule = input.providers.storageModule;
  const subscriptions = new import_rxjs2.Subscription();
  const setState = (state) => storageModule.setState(state);
  const getState = () => storageModule.getState().orElse(() => (0, import_neverthrow4.okAsync)(defaultState)).andThen((state) => state ? (0, import_neverthrow4.ok)(state) : (0, import_neverthrow4.ok)(defaultState));
  const patchState = (state) => getState().andThen(
    (oldState) => setState({ ...oldState, ...state })
  );
  const defaultState = {
    walletData: walletDataDefault,
    loggedInTimestamp: "",
    sharedData: {}
  };
  const resetState = () => storageModule.setState(defaultState).map(() => {
    emitWalletData();
  });
  const initializeState = () => getState().map(() => emitWalletData()).orElse(() => resetState());
  initializeState();
  const walletDataSubject = new import_rxjs2.BehaviorSubject(
    void 0
  );
  const emitWalletData = () => {
    storageModule.getState().map((state) => {
      walletDataSubject.next(state?.walletData);
    });
  };
  const walletData$ = walletDataSubject.asObservable().pipe((0, import_rxjs2.filter)((walletData) => !!walletData));
  return {
    setState,
    patchState,
    getState,
    walletData$,
    emitWalletData,
    getWalletData: () => walletDataSubject.value,
    reset: resetState,
    storage$: storageModule.storage$,
    destroy: () => {
      subscriptions.unsubscribe();
    }
  };
};

// src/modules/wallet-request/data-request/transformations/wallet-to-rdt.ts
var withAccounts = (input) => (walletData) => {
  let accounts2 = [];
  if (input.discriminator === "authorizedRequest") {
    const oneTimeAccounts = input.oneTimeAccounts?.accounts ?? [];
    const ongoingAccounts = input.ongoingAccounts?.accounts ?? [];
    accounts2 = [...oneTimeAccounts, ...ongoingAccounts];
  } else if (input.discriminator === "unauthorizedRequest") {
    const oneTimeAccounts = input.oneTimeAccounts?.accounts ?? [];
    accounts2 = oneTimeAccounts;
  }
  return (0, import_immer8.produce)(walletData, (draft) => {
    draft.accounts = accounts2;
  });
};
var withPersonaDataEntries = (input) => {
  const entries = [];
  if (input.name) {
    entries.push({
      entry: "fullName",
      fields: input.name
    });
  }
  if (input.emailAddresses)
    entries.push({
      entry: "emailAddresses",
      fields: input.emailAddresses
    });
  if (input.phoneNumbers)
    entries.push({
      entry: "phoneNumbers",
      fields: input.phoneNumbers
    });
  return entries;
};
var convertOwnershipProofsToSignedChallenge = (challenge, proofs) => {
  return proofs.map((proof) => {
    const type = "identityAddress" in proof ? proofType.persona : proofType.account;
    const address = "identityAddress" in proof ? proof.identityAddress : proof.accountAddress;
    return {
      type,
      challenge,
      address,
      proof: proof.proof
    };
  });
};
var withPersonaData = (input) => (walletData) => (0, import_immer8.produce)(walletData, (draft) => {
  if (input.discriminator === "authorizedRequest") {
    if (input.oneTimePersonaData)
      draft.personaData = withPersonaDataEntries(input.oneTimePersonaData);
    if (input.ongoingPersonaData)
      draft.personaData = withPersonaDataEntries(input.ongoingPersonaData);
  } else if (input.discriminator === "unauthorizedRequest" && input.oneTimePersonaData)
    draft.personaData = withPersonaDataEntries(input.oneTimePersonaData);
});
var withPersona = (input) => (walletData) => (0, import_immer8.produce)(walletData, (draft) => {
  if (input.discriminator === "authorizedRequest")
    draft.persona = input.auth?.persona;
});
var withProofs = (input) => (walletData) => (0, import_immer8.produce)(walletData, (draft) => {
  draft.proofs = [];
  if (input.discriminator === "authorizedRequest") {
    if (input.auth.discriminator === "loginWithChallenge")
      draft.proofs.push({
        challenge: input.auth.challenge,
        proof: input.auth.proof,
        address: input.auth.persona.identityAddress,
        type: proofType.persona
      });
    if (input.ongoingAccounts?.challenge && input.ongoingAccounts.proofs?.length) {
      const challenge = input.ongoingAccounts.challenge;
      const accountProofs = input.ongoingAccounts.proofs.map(
        ({ accountAddress, proof }) => ({
          proof,
          address: accountAddress,
          challenge,
          type: proofType.account
        })
      );
      draft.proofs.push(...accountProofs);
    }
    if (input.oneTimeAccounts?.challenge && input.oneTimeAccounts.proofs?.length) {
      const challenge = input.oneTimeAccounts.challenge;
      const accountProofs = input.oneTimeAccounts.proofs.map(
        ({ accountAddress, proof }) => ({
          proof,
          address: accountAddress,
          challenge,
          type: proofType.account
        })
      );
      draft.proofs.push(...accountProofs);
    }
    if (input.proofOfOwnership) {
      draft.proofs.push(
        ...convertOwnershipProofsToSignedChallenge(
          input.proofOfOwnership.challenge,
          input.proofOfOwnership.proofs
        )
      );
    }
  }
  if (input.discriminator === "unauthorizedRequest") {
    if (input.oneTimeAccounts?.challenge && input.oneTimeAccounts.proofs?.length) {
      const challenge = input.oneTimeAccounts.challenge;
      const accountProofs = input.oneTimeAccounts.proofs.map(
        ({ accountAddress, proof }) => ({
          proof,
          address: accountAddress,
          challenge,
          type: proofType.account
        })
      );
      draft.proofs.push(...accountProofs);
    }
  }
});
var transformWalletResponseToRdtWalletData = (response) => (0, import_neverthrow5.okAsync)({
  accounts: [],
  personaData: [],
  proofs: [],
  persona: void 0
}).map(withAccounts(response)).map(withPersonaData(response)).map(withPersona(response)).map(withProofs(response));

// src/modules/wallet-request/data-request/transformations/wallet-data-to-connect-button.ts
var transformWalletDataToConnectButton = (walletData) => {
  const accounts2 = walletData.accounts ?? [];
  const personaLabel = walletData?.persona?.label ?? "";
  const connected = !!walletData?.persona;
  const personaData2 = walletData?.personaData?.map((item) => {
    if (item.entry === "fullName") {
      const { variant: variant2, givenNames, familyName, nickname } = item.fields;
      const value = variant2 === "western" ? `${givenNames}${nickname ? ` "${nickname}" ` : " "}${familyName}` : `${familyName}${nickname ? ` "${nickname}" ` : " "}${givenNames}`;
      return {
        value,
        field: "fullName"
      };
    } else if (item.entry === "emailAddresses") {
      return {
        // currently only one email address is supported
        value: item.fields[0],
        field: "emailAddress"
      };
    } else if (item.entry === "phoneNumbers") {
      return {
        // currently only one phone number is supported
        value: item.fields[0],
        field: "phoneNumber"
      };
    }
    return;
  }).filter(
    (item) => !!item && !!item.value?.trim()
  );
  return { accounts: accounts2, personaLabel, connected, personaData: personaData2 };
};

// src/modules/wallet-request/data-request/data-request-state.module.ts
var import_rxjs3 = require("rxjs");
var import_immer9 = require("immer");
var DataRequestStateModule = (initialState) => {
  const state = new import_rxjs3.BehaviorSubject(initialState);
  const reset = () => state.next(initialState);
  const update = (input) => state.next(input);
  const getState = () => state.getValue();
  const toDataRequestState = (...items) => items.filter((item) => typeof item._toObject === "function").reduce(
    (acc, item) => ({
      ...acc,
      ...item._toObject()
    }),
    {}
  );
  const setState = (...items) => {
    if (items.length === 0) reset();
    else {
      update(toDataRequestState(...items));
    }
  };
  const patchState = (...items) => {
    if (items.length === 0) return;
    update({ ...getState(), ...toDataRequestState(...items) });
  };
  const removeState = (...keys) => {
    update(
      (0, import_immer9.produce)(getState(), (draft) => {
        keys.forEach((key) => {
          delete draft[key];
        });
      })
    );
  };
  return {
    reset,
    setState,
    getState,
    patchState,
    removeState,
    toDataRequestState,
    state$: state.asObservable()
  };
};

// src/modules/wallet-request/identity/identity.module.ts
var import_neverthrow6 = require("neverthrow");

// src/modules/wallet-request/crypto/create-signature-message.ts
var import_buffer4 = require("buffer");
var createSignatureMessage = ({
  interactionId,
  dAppDefinitionAddress,
  origin,
  logger
}) => {
  const prefix = "C";
  const prefixBuffer = import_buffer4.Buffer.from("C", "ascii");
  const lengthOfDappDefAddress = dAppDefinitionAddress.length;
  const lengthOfDappDefAddressBuffer = import_buffer4.Buffer.from(
    lengthOfDappDefAddress.toString(16),
    "hex"
  );
  const dappDefAddressBuffer = import_buffer4.Buffer.from(dAppDefinitionAddress, "utf-8");
  const originBuffer = import_buffer4.Buffer.from(origin, "utf-8");
  const interactionIdBuffer = import_buffer4.Buffer.from(interactionId, "utf-8");
  const messageBuffer = import_buffer4.Buffer.concat([
    prefixBuffer,
    interactionIdBuffer,
    lengthOfDappDefAddressBuffer,
    dappDefAddressBuffer,
    originBuffer
  ]);
  const blake2bHash = blake2b(messageBuffer).map((hash2) => {
    logger?.debug({
      method: "createSignatureMessage",
      messagePartsRaw: [
        prefix,
        interactionId,
        lengthOfDappDefAddress,
        dAppDefinitionAddress,
        origin
      ],
      messageParts: [
        prefixBuffer.toString("hex"),
        interactionIdBuffer.toString("hex"),
        lengthOfDappDefAddressBuffer.toString("hex"),
        dappDefAddressBuffer.toString("hex"),
        originBuffer.toString("hex")
      ],
      message: messageBuffer.toString("hex"),
      blake2bHash: hash2.toString("hex")
    });
    return import_buffer4.Buffer.from(hash2).toString("hex");
  }).mapErr((jsError) => ({ reason: "couldNotHashMessage", jsError }));
  return blake2bHash;
};

// src/modules/wallet-request/identity/identity.module.ts
var IdentityKind = {
  dApp: "dApp"
};
var IdentityModule = (input) => {
  const { storageModule, KeyPairModule } = input.providers;
  const keyPairFromSecret = (input2) => (0, import_neverthrow6.ok)(KeyPairModule(input2));
  const getIdentity = (kind) => storageModule.getItemById(kind).andThen(
    (identity) => identity ? keyPairFromSecret(identity.secret) : (0, import_neverthrow6.okAsync)(void 0)
  );
  const createIdentity = (kind) => (0, import_neverthrow6.ok)(KeyPairModule()).asyncAndThen(
    (keyPair) => storageModule.setItems({
      [kind]: {
        secret: keyPair.getPrivateKey(),
        createdAt: Date.now()
      }
    }).map(() => keyPair)
  );
  const getOrCreateIdentity = (kind) => getIdentity(kind).andThen((keyPair) => keyPair ? (0, import_neverthrow6.okAsync)(keyPair) : createIdentity(kind)).mapErr((error) => ({
    reason: "couldNotGetOrCreateIdentity",
    jsError: error
  }));
  const deriveSharedSecret = (kind, publicKey) => getIdentity(kind).mapErr(() => ({ reason: "couldNotDeriveSharedSecret" })).andThen(
    (identity) => identity ? identity.x25519.calculateSharedSecret(publicKey, input.dAppDefinitionAddress).mapErr(() => ({
      reason: "FailedToDeriveSharedSecret"
    })) : (0, import_neverthrow6.err)({ reason: "DappIdentityNotFound" })
  );
  const createSignature = ({
    kind,
    interactionId,
    dAppDefinitionAddress,
    origin
  }) => getOrCreateIdentity(kind).andThen(
    (identity) => createSignatureMessage({
      interactionId,
      dAppDefinitionAddress,
      origin,
      logger: input.logger
    }).andThen(
      (message) => identity.ed25519.sign(message).map((signature) => ({
        signature,
        publicKey: identity.x25519.getPublicKey(),
        identity: identity.ed25519.getPublicKey()
      })).mapErr((error) => ({
        reason: "couldNotSignMessage",
        jsError: error
      }))
    )
  );
  return {
    get: (kind) => getOrCreateIdentity(kind),
    deriveSharedSecret,
    createSignature
  };
};

// ../common/src/index.ts
var RequestStatus = {
  fail: "fail",
  ignored: "ignored",
  pending: "pending",
  success: "success",
  timedOut: "timedOut",
  cancelled: "cancelled",
  /**
   * Pending commit status is for preauthorization which was signed but not yet successfully committed to the network
   */
  pendingCommit: "pendingCommit"
};

// src/modules/wallet-request/request-items/request-item.module.ts
var import_rxjs4 = require("rxjs");

// src/error.ts
var ErrorType = {
  rejectedByUser: "rejectedByUser",
  missingExtension: "missingExtension",
  canceledByUser: "canceledByUser",
  walletRequestValidation: "walletRequestValidation",
  walletResponseValidation: "walletResponseValidation",
  wrongNetwork: "wrongNetwork",
  failedToPrepareTransaction: "failedToPrepareTransaction",
  failedToCompileTransaction: "failedToCompileTransaction",
  failedToSignTransaction: "failedToSignTransaction",
  failedToSubmitTransaction: "failedToSubmitTransaction",
  failedToPollSubmittedTransaction: "failedToPollSubmittedTransaction",
  submittedTransactionWasDuplicate: "submittedTransactionWasDuplicate",
  submittedTransactionHasFailedTransactionStatus: "submittedTransactionHasFailedTransactionStatus",
  submittedTransactionHasRejectedTransactionStatus: "submittedTransactionHasRejectedTransactionStatus",
  failedToFindAccountWithEnoughFundsToLockFee: "failedToFindAccountWithEnoughFundsToLockFee",
  wrongAccountType: "wrongAccountType",
  unknownWebsite: "unknownWebsite",
  radixJsonNotFound: "radixJsonNotFound",
  unknownDappDefinitionAddress: "unknownDappDefinitionAddress",
  invalidPersona: "invalidPersona"
};
var defaultErrorMessage = (/* @__PURE__ */ new Map()).set(ErrorType.missingExtension, "extension could not be found").set(ErrorType.rejectedByUser, "user rejected request").set(ErrorType.canceledByUser, "user has canceled the request");
var SdkError = (error, interactionId, message, jsError) => ({
  error,
  interactionId,
  message: message || defaultErrorMessage.get(error) || "",
  jsError
});

// src/modules/wallet-request/request-items/request-item.module.ts
var import_neverthrow7 = require("neverthrow");
var RequestItemModule = (input) => {
  const logger = input?.logger?.getSubLogger({ name: "RequestItemModule" });
  const subscriptions = new import_rxjs4.Subscription();
  const storageModule = input.providers.storageModule;
  const signals = /* @__PURE__ */ new Map();
  const createItem = ({
    type,
    walletInteraction,
    isOneTimeRequest
  }) => ({
    type,
    status: "pending",
    createdAt: Date.now(),
    interactionId: walletInteraction.interactionId,
    showCancel: true,
    walletInteraction,
    isOneTimeRequest
  });
  const add = (value, onSignal) => {
    const item = createItem(value);
    logger?.debug({
      method: "addRequestItem",
      item
    });
    if (onSignal) {
      signals.set(item.interactionId, onSignal);
    }
    return storageModule.setItems({ [item.interactionId]: item }).map(() => item);
  };
  const getAndRemoveSignal = (interactionId) => {
    if (signals.has(interactionId)) {
      const signal = signals.get(interactionId);
      signals.delete(interactionId);
      return signal;
    }
  };
  const patch = (id, partialValue) => {
    logger?.debug({
      method: "patchRequestItemStatus",
      item: { id, ...partialValue }
    });
    return storageModule.patchItem(id, partialValue);
  };
  const cancel = (id) => {
    logger?.debug({ method: "cancelRequestItem", id });
    return patch(id, { status: "fail", error: ErrorType.canceledByUser });
  };
  const isWalletInteractionRequired = (status) => [RequestStatus.pending, RequestStatus.pendingCommit].includes(
    status
  );
  const updateStatus = ({
    id,
    status,
    error,
    transactionIntentHash,
    metadata = {},
    walletData,
    walletResponse
  }) => {
    return storageModule.getItemById(id).mapErr(() => ({ reason: "couldNotReadFromStore" })).andThen((item) => {
      if (item) {
        if (status === RequestStatus.ignored && signals.has(id)) {
          signals.delete(id);
        }
        if (status === RequestStatus.success) {
          const signal = getAndRemoveSignal(id);
          signal?.(metadata?.parentTransactionIntentHash);
        }
        const updated = {
          ...item,
          walletData,
          transactionIntentHash,
          error,
          walletResponse,
          status: item.status === RequestStatus.ignored ? item.status : status,
          metadata: item.metadata ? { ...item.metadata, ...metadata } : metadata
        };
        if (!isWalletInteractionRequired(updated.status)) {
          delete updated.walletInteraction;
        }
        logger?.debug({ method: "updateRequestItemStatus", updated });
        return storageModule.setItems({ [id]: updated }).mapErr(() => ({ reason: "couldNotWriteToStore" }));
      }
      return (0, import_neverthrow7.errAsync)({ reason: "itemNotFound" });
    });
  };
  const getPendingCommit = () => storageModule.getItemList().map(
    (items) => items.filter((item) => item.status === RequestStatus.pendingCommit)
  );
  const getPending = () => storageModule.getItemList().map((items) => items.filter((item) => item.status === "pending"));
  const requests$ = storageModule.storage$.pipe(
    (0, import_rxjs4.switchMap)(() => storageModule.getItemList()),
    (0, import_rxjs4.map)((result) => {
      if (result.isOk()) return result.value;
    }),
    (0, import_rxjs4.filter)((items) => !!items)
  );
  return {
    add,
    cancel,
    updateStatus,
    patch,
    getAndRemoveSignal,
    getById: (id) => storageModule.getItemById(id),
    getPendingCommit,
    getPending,
    requests$,
    clear: storageModule.clear,
    destroy: () => {
      subscriptions.unsubscribe();
    }
  };
};

// src/modules/wallet-request/session/session.module.ts
var import_neverthrow8 = require("neverthrow");
var import_uuid = require("uuid");
var SessionModule = (input) => {
  const storageModule = input.providers.storageModule;
  const getSession = () => storageModule.getItemList().mapErr((error) => ({
    reason: "couldNotReadSessionFromStore",
    jsError: error
  })).map((sessions) => sessions[0]);
  const getSessionById = (sessionId) => storageModule.getItemById(sessionId).mapErr((error) => ({ reason: "couldNotGetSessionById", jsError: error }));
  const createSession = () => {
    const sessionId = (0, import_uuid.v4)();
    const newSession = {
      sessionId,
      createdAt: Date.now()
    };
    return storageModule.setItems({ [sessionId]: newSession }).map(() => newSession).mapErr((error) => ({ reason: "couldNotCreateSession", jsError: error }));
  };
  const patchSession = (sessionId, value) => storageModule.patchItem(sessionId, value).mapErr((error) => ({ reason: "couldNotPatchSession", jsError: error }));
  const getCurrentSession = () => getSession().andThen(
    (session) => session ? (0, import_neverthrow8.okAsync)(session) : createSession()
  );
  return {
    getCurrentSession,
    getSession,
    store: storageModule,
    getSessionById,
    patchSession
  };
};

// src/modules/wallet-request/transport/connector-extension/subjects.ts
var import_rxjs5 = require("rxjs");
var ConnectorExtensionSubjects = () => ({
  outgoingMessageSubject: new import_rxjs5.Subject(),
  incomingMessageSubject: new import_rxjs5.Subject(),
  responseSubject: new import_rxjs5.Subject(),
  messageLifeCycleEventSubject: new import_rxjs5.Subject()
});

// src/modules/wallet-request/transport/connector-extension/connector-extension.module.ts
var import_neverthrow15 = require("neverthrow");
var import_rxjs8 = require("rxjs");

// src/helpers/exponential-backoff.ts
var import_neverthrow9 = require("neverthrow");
var import_rxjs6 = require("rxjs");
var ExponentialBackoff = ({
  maxDelayTime = 1e4,
  multiplier = 2,
  timeout,
  interval = 2e3
} = {}) => {
  const trigger = new import_rxjs6.Subject();
  const stop = new import_rxjs6.Subject();
  let numberOfRetries = 0;
  const backoff$ = (0, import_rxjs6.merge)(
    (0, import_rxjs6.of)(0),
    trigger.pipe(
      (0, import_rxjs6.map)(() => {
        numberOfRetries = numberOfRetries + 1;
        return numberOfRetries;
      })
    )
  ).pipe(
    (0, import_rxjs6.switchMap)((numberOfRetries2) => {
      const delayTime = numberOfRetries2 * interval * multiplier;
      const delay2 = delayTime > maxDelayTime ? maxDelayTime : delayTime;
      return (0, import_rxjs6.timer)(delay2).pipe((0, import_rxjs6.map)(() => (0, import_neverthrow9.ok)(numberOfRetries2)));
    })
  );
  const withBackoffAndTimeout$ = (0, import_rxjs6.merge)(
    stop.asObservable().pipe((0, import_rxjs6.map)(() => (0, import_neverthrow9.err)({ error: "stopped" }))),
    timeout ? (0, import_rxjs6.merge)(
      backoff$,
      (0, import_rxjs6.timer)(timeout).pipe((0, import_rxjs6.map)(() => (0, import_neverthrow9.err)({ error: "timeout" })))
    ) : backoff$
  );
  return {
    trigger,
    withBackoff$: withBackoffAndTimeout$,
    stop: () => stop.next()
  };
};

// src/helpers/fetch-wrapper.ts
var import_neverthrow11 = require("neverthrow");

// src/helpers/parse-json.ts
var import_neverthrow10 = require("neverthrow");
var parseJSON = (text) => {
  try {
    return (0, import_neverthrow10.ok)(JSON.parse(text));
  } catch (error) {
    return (0, import_neverthrow10.err)(error);
  }
};

// src/helpers/fetch-wrapper.ts
var typedError = (error) => error;
var resolveFetch = (fetchable) => import_neverthrow11.ResultAsync.fromPromise(fetchable, typedError).mapErr((error) => ({
  reason: "FailedToFetch",
  error,
  status: 0
}));
var fetchWrapper = (fetchable) => resolveFetch(fetchable).andThen(
  (response) => import_neverthrow11.ResultAsync.fromPromise(response.text(), typedError).andThen((text) => text ? parseJSON(text) : (0, import_neverthrow11.okAsync)(text)).mapErr((error) => ({
    status: response.status,
    reason: "FailedToParseResponseToJson",
    error
  })).andThen(
    (data) => response.ok ? (0, import_neverthrow11.okAsync)({
      status: response.status,
      data
    }) : (0, import_neverthrow11.errAsync)({
      status: response.status,
      reason: "RequestStatusNotOk",
      data
    })
  )
);

// src/helpers/logger.ts
var import_tslog = require("tslog");
var Logger = (minLevel) => new import_tslog.Logger({
  minLevel: minLevel ?? 2,
  prettyLogTemplate: "{{hh}}:{{MM}}:{{ss}}:{{ms}}	{{name}}	{{logLevelName}}	"
});

// src/helpers/stringify.ts
var import_neverthrow12 = require("neverthrow");
var stringify = (input) => {
  try {
    return (0, import_neverthrow12.ok)(JSON.stringify(input));
  } catch (error) {
    return (0, import_neverthrow12.err)(error);
  }
};

// src/helpers/remove-undefined.ts
var removeUndefined = (input) => stringify(input).andThen(parseJSON);

// src/helpers/typed-error.ts
var typedError2 = (error) => error;

// src/helpers/unwrap-observable.ts
var import_neverthrow13 = require("neverthrow");
var import_rxjs7 = require("rxjs");
var unwrapObservable = (input) => import_neverthrow13.ResultAsync.fromPromise(
  (0, import_rxjs7.firstValueFrom)(input),
  (error) => error
).andThen((result) => result);

// src/helpers/validate-wallet-response.ts
var import_neverthrow14 = require("neverthrow");
var import_valibot8 = require("valibot");
var validateWalletResponse = (walletResponse) => {
  const fn = import_neverthrow14.Result.fromThrowable(
    (_2) => (0, import_valibot8.parse)(WalletInteractionResponse, _2),
    (error) => error
  );
  return fn(walletResponse).mapErr(
    (response) => SdkError(
      "walletResponseValidation",
      walletResponse?.interactionId,
      "Invalid input",
      response
    )
  );
};

// src/helpers/generate-rola-challenge.ts
var generateRolaChallenge = () => [...globalThis.crypto.getRandomValues(new Uint8Array(32))].map((x2) => x2.toString(16).padStart(2, "0")).join("");

// src/helpers/validate-rola-challenge.ts
var validateRolaChallenge = (challenge) => typeof challenge === "string" && /^[0-9a-f]{64}$/i.test(challenge);

// src/helpers/parse-signed-challenge.ts
var import_valibot9 = require("valibot");
var parseSignedChallenge = (value) => (0, import_valibot9.safeParse)(SignedChallenge, value);

// src/modules/wallet-request/transport/connector-extension/connector-extension.module.ts
var import_uuid2 = require("uuid");
var ConnectorExtensionModule = (input) => {
  let isExtensionHandlingSessions = false;
  const logger = input?.logger?.getSubLogger({
    name: "ConnectorExtensionModule"
  });
  const subjects = input?.subjects ?? ConnectorExtensionSubjects();
  const subscription = new import_rxjs8.Subscription();
  const extensionDetectionTime = input?.extensionDetectionTime ?? 200;
  const requestResolverModule = input.providers.requestResolverModule;
  const storage = input.providers.storageModule.getPartition("connectorExtension");
  subscription.add(
    subjects.incomingMessageSubject.pipe(
      (0, import_rxjs8.tap)((message) => {
        logger?.debug({
          method: "incomingMessageSubject",
          message
        });
        if ("eventType" in message) {
          subjects.messageLifeCycleEventSubject.next(message);
        } else {
          subjects.responseSubject.next(message);
        }
      })
    ).subscribe()
  );
  subscription.add(
    subjects.responseSubject.pipe(
      (0, import_rxjs8.mergeMap)(
        (walletResponse) => (0, import_rxjs8.from)(requestResolverModule.addWalletResponses([walletResponse]))
      )
    ).subscribe()
  );
  subscription.add(
    subjects.outgoingMessageSubject.pipe(
      (0, import_rxjs8.tap)((payload) => {
        logger?.debug({
          method: "outgoingMessageSubject",
          payload
        });
        input.providers.environmentModule.globalThis.dispatchEvent(
          new CustomEvent(eventType.outgoingMessage, {
            detail: payload
          })
        );
      })
    ).subscribe()
  );
  const wrapOutgoingInteraction = (interaction) => {
    if (!isExtensionHandlingSessions) {
      return (0, import_neverthrow15.okAsync)(interaction);
    }
    return storage.getState().andThen((state) => {
      const isAuthorizedRequest = interaction.items.discriminator === "authorizedRequest";
      const sessionId = isAuthorizedRequest ? state?.sessionId || (0, import_uuid2.v4)() : state?.sessionId;
      const wrappedRequest = {
        interactionId: interaction.interactionId,
        interaction,
        sessionId,
        discriminator: "walletInteraction"
      };
      return isAuthorizedRequest ? storage.setState({ sessionId }).map(() => wrappedRequest) : (0, import_neverthrow15.okAsync)(wrappedRequest);
    });
  };
  const handleIncomingMessage = (event) => {
    const message = event.detail;
    subjects.incomingMessageSubject.next(message);
  };
  addEventListener(eventType.incomingMessage, handleIncomingMessage);
  const sendWalletInteraction = (walletInteraction, callbackFns) => {
    const cancelRequestSubject = new import_rxjs8.Subject();
    const maybeResolved$ = (0, import_rxjs8.from)(
      requestResolverModule.getWalletResponseById(
        walletInteraction.interactionId
      )
    ).pipe((0, import_rxjs8.filter)((result) => result.isOk() && !!result.value));
    const walletResponse$ = subjects.responseSubject.pipe(
      (0, import_rxjs8.filter)(
        (response) => response.interactionId === walletInteraction.interactionId
      ),
      (0, import_rxjs8.map)((walletResponse) => (0, import_neverthrow15.ok)(walletResponse))
    );
    const cancelResponse$ = subjects.messageLifeCycleEventSubject.pipe(
      (0, import_rxjs8.filter)(
        ({ interactionId, eventType: eventType2 }) => walletInteraction.interactionId === interactionId && ["requestCancelSuccess", "requestCancelFail"].includes(eventType2)
      ),
      (0, import_rxjs8.map)((message) => {
        const error = SdkError("canceledByUser", message.interactionId);
        logger?.debug(`\u{1F535}\u2B06\uFE0F\u274C walletRequestCanceled`, error);
        return message;
      })
    );
    const sendCancelRequest = () => {
      subjects.outgoingMessageSubject.next({
        interactionId: walletInteraction.interactionId,
        metadata: walletInteraction.metadata,
        ...isExtensionHandlingSessions ? { discriminator: "cancelWalletInteraction" } : { items: { discriminator: "cancelRequest" } }
      });
      setTimeout(() => {
        cancelRequestSubject.next(
          (0, import_neverthrow15.err)(SdkError("canceledByUser", walletInteraction.interactionId))
        );
      });
      return import_neverthrow15.ResultAsync.fromSafePromise(
        (0, import_rxjs8.firstValueFrom)(
          (0, import_rxjs8.merge)(
            walletResponse$.pipe((0, import_rxjs8.map)(() => "requestCancelFail")),
            cancelResponse$.pipe((0, import_rxjs8.map)(({ eventType: eventType2 }) => eventType2))
          )
        )
      );
    };
    if (callbackFns.requestControl)
      callbackFns.requestControl({
        cancelRequest: () => sendCancelRequest().andThen(
          (eventType2) => eventType2 === "requestCancelSuccess" ? (0, import_neverthrow15.ok)("requestCancelSuccess") : (0, import_neverthrow15.err)("requestCancelFail")
        ),
        getRequest: () => walletInteraction
      });
    const walletResponseOrCancelRequest$ = (0, import_rxjs8.merge)(
      maybeResolved$,
      walletResponse$,
      cancelRequestSubject
    ).pipe((0, import_rxjs8.first)());
    const messageLifeCycleEvent$ = subjects.messageLifeCycleEventSubject.pipe(
      (0, import_rxjs8.filter)(
        ({ interactionId }) => walletInteraction.interactionId === interactionId
      ),
      (0, import_rxjs8.tap)((event) => {
        if (callbackFns.eventCallback)
          callbackFns.eventCallback(event.eventType);
      }),
      (0, import_rxjs8.takeUntil)(walletResponse$),
      (0, import_rxjs8.share)()
    );
    const messageEventSubscription = messageLifeCycleEvent$.subscribe();
    const missingExtensionError$ = (0, import_rxjs8.timer)(extensionDetectionTime).pipe(
      (0, import_rxjs8.map)(
        () => (0, import_neverthrow15.err)(SdkError("missingExtension", walletInteraction.interactionId))
      )
    );
    const extensionMissingError$ = (0, import_rxjs8.merge)(
      missingExtensionError$,
      messageLifeCycleEvent$
    ).pipe(
      (0, import_rxjs8.first)(),
      (0, import_rxjs8.filter)((value) => !("eventType" in value))
    );
    const sendWalletRequest$ = extensionStatus$.pipe(
      (0, import_rxjs8.filter)((status) => status.isExtensionAvailable),
      (0, import_rxjs8.switchMap)(() => (0, import_rxjs8.of)(wrapOutgoingInteraction(walletInteraction))),
      (0, import_rxjs8.tap)((result) => {
        result.map((message) => {
          subjects.outgoingMessageSubject.next(message);
        });
      }),
      (0, import_rxjs8.filter)((_2) => false)
    );
    return unwrapObservable(
      (0, import_rxjs8.merge)(
        walletResponseOrCancelRequest$,
        extensionMissingError$,
        sendWalletRequest$
      ).pipe(
        (0, import_rxjs8.tap)(() => {
          messageEventSubscription.unsubscribe();
        })
      )
    );
  };
  const extensionStatusEvent$ = subjects.messageLifeCycleEventSubject.pipe(
    (0, import_rxjs8.filter)(
      (event) => event.eventType === "extensionStatus"
    )
  );
  const extensionStatus$ = (0, import_rxjs8.of)(true).pipe(
    (0, import_rxjs8.tap)(() => {
      subjects.outgoingMessageSubject.next({
        interactionId: (0, import_uuid2.v4)(),
        discriminator: "extensionStatus"
      });
    }),
    (0, import_rxjs8.switchMap)(
      () => (0, import_rxjs8.race)(
        extensionStatusEvent$,
        (0, import_rxjs8.merge)(
          extensionStatusEvent$,
          (0, import_rxjs8.timer)(extensionDetectionTime).pipe(
            (0, import_rxjs8.map)(
              () => ({
                eventType: "extensionStatus",
                isWalletLinked: false,
                isExtensionAvailable: false,
                canHandleSessions: false
              })
            )
          )
        )
      )
    ),
    (0, import_rxjs8.tap)((event) => {
      isExtensionHandlingSessions = event.canHandleSessions || false;
    }),
    (0, import_rxjs8.shareReplay)(1)
  );
  return {
    id: "connector-extension",
    isSupported: () => !input.providers.environmentModule.isMobile(),
    send: sendWalletInteraction,
    isAvailable$: extensionStatus$.pipe(
      (0, import_rxjs8.map)(({ isExtensionAvailable }) => isExtensionAvailable)
    ),
    isLinked$: extensionStatus$.pipe(
      (0, import_rxjs8.map)(({ isWalletLinked }) => isWalletLinked)
    ),
    showQrCode: () => {
      input.providers.environmentModule.globalThis.dispatchEvent(
        new CustomEvent(eventType.outgoingMessage, {
          detail: { discriminator: "openPopup" }
        })
      );
    },
    disconnect: () => {
      storage.clear();
    },
    destroy: () => {
      subscription.unsubscribe();
      removeEventListener(eventType.incomingMessage, handleIncomingMessage);
    }
  };
};

// src/modules/wallet-request/transport/radix-connect-relay/deep-link.module.ts
var import_neverthrow16 = require("neverthrow");
var DeepLinkModule = (input) => {
  const { walletUrl } = input;
  const logger = input?.logger?.getSubLogger({ name: "DeepLinkModule" });
  const isTelegramMiniApp = input.providers.environmentModule.isTMA();
  const deepLinkToWallet = (values) => {
    const outboundUrl = new URL(walletUrl);
    Object.entries(values).forEach(([key, value]) => {
      outboundUrl.searchParams.append(key, value);
    });
    logger?.debug({
      method: "deepLinkToWallet",
      data: { ...values }
    });
    if (input.providers.environmentModule.isMobile()) {
      const deepLink = outboundUrl.toString();
      if (isTelegramMiniApp)
        input.providers.environmentModule.globalThis.open(deepLink, "_blank");
      else if (input.providers.environmentModule.globalThis.location?.href)
        input.providers.environmentModule.globalThis.location.href = deepLink;
      return (0, import_neverthrow16.okAsync)(void 0);
    }
    return (0, import_neverthrow16.errAsync)(SdkError("UnhandledEnvironment", ""));
  };
  return {
    deepLinkToWallet
  };
};

// src/modules/wallet-request/transport/radix-connect-relay/radix-connect-relay.module.ts
var import_neverthrow20 = require("neverthrow");
var import_rxjs9 = require("rxjs");

// src/modules/wallet-request/encryption/helpers/buffer-reader.ts
var import_neverthrow17 = require("neverthrow");
var import_buffer5 = require("buffer");
var createBufferReader = (buffer) => {
  let offset = 0;
  let bytesLeftToRead = buffer.length;
  const readNextBuffer = (byteCount) => {
    if (byteCount < 0) return (0, import_neverthrow17.err)(Error(`'byteCount' must not be negative`));
    if (byteCount === 0) {
      return (0, import_neverthrow17.ok)(import_buffer5.Buffer.alloc(0));
    }
    if (offset + byteCount > buffer.length)
      return (0, import_neverthrow17.err)(Error(`Out of buffer's boundary`));
    const bufToReturn = import_buffer5.Buffer.alloc(byteCount);
    buffer.copy(bufToReturn, 0, offset, offset + byteCount);
    if (bufToReturn.length !== byteCount) {
      return (0, import_neverthrow17.err)(Error(`Incorrect length of newly read buffer...`));
    }
    offset += byteCount;
    bytesLeftToRead -= byteCount;
    return (0, import_neverthrow17.ok)(bufToReturn);
  };
  const finishedParsing = () => {
    if (bytesLeftToRead < 0) {
      return (0, import_neverthrow17.err)(Error(`Incorrect implementation, read too many bytes.`));
    }
    return (0, import_neverthrow17.ok)(bytesLeftToRead === 0);
  };
  return {
    readNextBuffer,
    finishedParsing,
    remainingBytes: () => finishedParsing().andThen((finished) => {
      if (finished) return (0, import_neverthrow17.ok)(import_buffer5.Buffer.alloc(0));
      const leftBuf = import_buffer5.Buffer.alloc(bytesLeftToRead);
      buffer.copy(leftBuf, 0, offset);
      return (0, import_neverthrow17.ok)(leftBuf);
    })
  };
};
var readBuffer = (buffer) => createBufferReader(buffer).readNextBuffer;

// src/modules/wallet-request/encryption/helpers/sealbox.ts
var import_buffer6 = require("buffer");
var import_neverthrow18 = require("neverthrow");
var transformBufferToSealbox = (buffer) => {
  const readNextBuffer = readBuffer(buffer);
  const nonceLength = 12;
  const authTagLength = 16;
  return import_neverthrow18.Result.combine([
    readNextBuffer(nonceLength),
    readNextBuffer(buffer.length - nonceLength - authTagLength),
    readNextBuffer(authTagLength)
  ]).map(([iv, ciphertext, authTag]) => ({
    iv,
    ciphertext,
    authTag,
    combined: import_buffer6.Buffer.concat([iv, ciphertext, authTag]),
    ciphertextAndAuthTag: import_buffer6.Buffer.concat([ciphertext, authTag])
  }));
};

// src/modules/wallet-request/encryption/encryption.module.ts
var import_neverthrow19 = require("neverthrow");
var import_buffer7 = require("buffer");
var EncryptionModule = () => {
  const cryptoDecrypt = (data, encryptionKey, iv) => import_neverthrow19.ResultAsync.fromPromise(
    crypto.subtle.decrypt({ name: "AES-GCM", iv }, encryptionKey, data),
    typedError2
  ).map(import_buffer7.Buffer.from);
  const cryptoEncrypt = (data, encryptionKey, iv) => import_neverthrow19.ResultAsync.fromPromise(
    crypto.subtle.encrypt(
      {
        name: "AES-GCM",
        iv
      },
      encryptionKey,
      data
    ),
    typedError2
  ).map(import_buffer7.Buffer.from);
  const getKey = (encryptionKey) => import_neverthrow19.ResultAsync.fromPromise(
    crypto.subtle.importKey(
      "raw",
      encryptionKey,
      {
        name: "AES-GCM",
        length: 256
      },
      false,
      ["encrypt", "decrypt"]
    ),
    typedError2
  );
  const decrypt = (data, encryptionKey, iv) => getKey(encryptionKey).andThen(
    (cryptoKey) => cryptoDecrypt(data, cryptoKey, iv)
  );
  const encrypt = (data, encryptionKey, iv = createIV()) => getKey(encryptionKey).andThen((cryptoKey) => cryptoEncrypt(data, cryptoKey, iv)).map((ciphertext) => ({
    combined: import_buffer7.Buffer.concat([iv, ciphertext]),
    iv,
    ciphertext
  }));
  const createIV = () => import_buffer7.Buffer.from(crypto.getRandomValues(new Uint8Array(12)));
  return { encrypt, decrypt, createIV };
};

// src/modules/wallet-request/transport/radix-connect-relay/radix-connect-relay-api.service.ts
var RadixConnectRelayApiService = (input) => {
  const baseUrl = input.baseUrl;
  const logger = input.logger?.getSubLogger({ name: "RadixConnectRelayApi" });
  const callApi = (body) => {
    logger?.debug({ method: `callApi.${body.method}`, body });
    return fetchWrapper(
      fetch(baseUrl, {
        method: "POST",
        body: JSON.stringify(body)
      })
    ).map((response) => {
      logger?.debug({
        method: `callApi.${body.method}.success`,
        response
      });
      return response;
    }).mapErr((error) => {
      logger?.debug({
        method: `callApi.${body.method}.error`,
        error
      });
      return SdkError(
        "RadixConnectRelayRequestFailed",
        body.interactionId ?? ""
      );
    });
  };
  const getResponses = (sessionId) => callApi({
    method: "getResponses",
    sessionId
  }).map((value) => value.data);
  return {
    getResponses
  };
};

// src/modules/wallet-request/transport/radix-connect-relay/helpers/base64url.ts
var import_base64url = __toESM(require("base64url"), 1);
var base64urlEncode = (value) => import_base64url.default.encode(Buffer.from(JSON.stringify(value)));

// src/modules/wallet-request/transport/radix-connect-relay/radix-connect-relay.module.ts
var RadixConnectRelayModule = (input) => {
  const logger = input.logger?.getSubLogger({ name: "RadixConnectRelayModule" });
  const { baseUrl, providers, walletUrl } = input;
  const { storageModule, requestResolverModule } = providers;
  const encryptionModule = providers?.encryptionModule ?? EncryptionModule();
  const deepLinkModule = providers?.deepLinkModule ?? DeepLinkModule({
    logger,
    walletUrl,
    providers: {
      environmentModule: input.providers.environmentModule
    }
  });
  const identityModule = providers?.identityModule ?? IdentityModule({
    logger,
    dAppDefinitionAddress: input.dAppDefinitionAddress,
    providers: {
      storageModule: storageModule.getPartition("identities"),
      KeyPairModule: Curve25519
    }
  });
  const sessionModule = providers?.sessionModule ?? SessionModule({
    providers: {
      storageModule: storageModule.getPartition("sessions")
    }
  });
  const radixConnectRelayApiService = RadixConnectRelayApiService({
    baseUrl: `${baseUrl}/api/v1`,
    logger
  });
  const subscriptions = new import_rxjs9.Subscription();
  const wait = (timer3 = 1500) => new Promise((resolve) => setTimeout(resolve, timer3));
  const decryptWalletResponse = (walletResponse) => {
    if ("error" in walletResponse) {
      return (0, import_neverthrow20.errAsync)({ reason: walletResponse.error });
    }
    return identityModule.get("dApp").andThen(
      (dAppIdentity) => dAppIdentity.x25519.calculateSharedSecret(
        walletResponse.publicKey,
        input.dAppDefinitionAddress
      ).mapErr(() => ({ reason: "FailedToDeriveSharedSecret" })).asyncAndThen(
        (sharedSecret) => decryptWalletResponseData(sharedSecret, walletResponse.data)
      )
    );
  };
  const checkRelayLoop = async () => {
    await requestResolverModule.getPendingRequestIds().andThen(
      () => sessionModule.getCurrentSession().map((session) => session.sessionId).andThen(radixConnectRelayApiService.getResponses).andThen(
        (responses) => import_neverthrow20.ResultAsync.combine(responses.map(decryptWalletResponse))
      ).andThen(requestResolverModule.addWalletResponses)
    );
    await wait();
    checkRelayLoop();
  };
  if (input.providers.environmentModule.isMobile()) {
    checkRelayLoop();
  }
  const sendWalletInteractionRequest = ({
    session,
    walletInteraction,
    signature,
    publicKey,
    identity
  }) => requestResolverModule.getPendingRequestById(walletInteraction.interactionId).andThen(
    () => requestResolverModule.markRequestAsSent(
      walletInteraction.interactionId
    )
  ).andThen(
    () => deepLinkModule.deepLinkToWallet({
      sessionId: session.sessionId,
      request: base64urlEncode(walletInteraction),
      signature,
      publicKey,
      identity,
      origin: walletInteraction.metadata.origin,
      dAppDefinitionAddress: walletInteraction.metadata.dAppDefinitionAddress
    })
  ).mapErr(
    () => SdkError("FailedToSendDappRequest", walletInteraction.interactionId)
  );
  const sendToWallet = (walletInteraction, callbackFns) => import_neverthrow20.ResultAsync.combine([
    sessionModule.getCurrentSession().mapErr(
      (error) => SdkError(error.reason, walletInteraction.interactionId)
    ),
    identityModule.get("dApp").mapErr(
      (error) => SdkError(error.reason, walletInteraction.interactionId)
    )
  ]).andThen(
    ([session, dAppIdentity]) => identityModule.createSignature({
      dAppDefinitionAddress: walletInteraction.metadata.dAppDefinitionAddress,
      interactionId: walletInteraction.interactionId,
      origin: walletInteraction.metadata.origin,
      kind: "dApp"
    }).mapErr(
      (error) => SdkError(error.reason, walletInteraction.interactionId)
    ).andThen(
      ({ signature }) => sendWalletInteractionRequest({
        session,
        walletInteraction,
        signature,
        identity: dAppIdentity.ed25519.getPublicKey(),
        publicKey: dAppIdentity.x25519.getPublicKey()
      })
    ).andThen(
      () => requestResolverModule.waitForWalletResponse(
        walletInteraction.interactionId
      )
    ).map((requestItem) => requestItem.walletResponse)
  );
  const decryptWalletResponseData = (sharedSecretHex, value) => transformBufferToSealbox(Buffer.from(value, "hex")).asyncAndThen(
    ({ ciphertextAndAuthTag, iv }) => encryptionModule.decrypt(
      ciphertextAndAuthTag,
      Buffer.from(sharedSecretHex, "hex"),
      iv
    )
  ).andThen(
    (decrypted) => parseJSON(decrypted.toString("utf-8"))
  ).mapErr((error) => ({
    reason: "FailedToDecryptWalletResponseData",
    jsError: error
  }));
  return {
    id: "radix-connect-relay",
    isSupported: () => input.providers.environmentModule.isMobile(),
    send: sendToWallet,
    disconnect: () => {
    },
    destroy: () => {
      subscriptions.unsubscribe();
    }
  };
};

// src/modules/wallet-request/wallet-request-sdk.ts
var import_neverthrow21 = require("neverthrow");
var import_valibot10 = require("valibot");
var import_uuid3 = require("uuid");
var WalletRequestSdk = (input) => {
  const metadata = {
    version: 2,
    dAppDefinitionAddress: input.dAppDefinitionAddress,
    networkId: input.networkId,
    origin: input.origin || input.providers.environmentModule.globalThis?.location?.origin || ""
  };
  const interactionIdFactory = input.providers.interactionIdFactory ?? import_uuid3.v4;
  (0, import_valibot10.parse)(Metadata, metadata);
  const logger = input?.logger?.getSubLogger({ name: "WalletSdk" });
  const availableTransports = input.providers.transports;
  const requestInterceptorDefault = async (walletInteraction) => walletInteraction;
  const requestInterceptor = input.requestInterceptor ?? requestInterceptorDefault;
  logger?.debug({ metadata });
  const createWalletInteraction = (items, interactionId = interactionIdFactory()) => ({
    items,
    interactionId,
    metadata
  });
  const withInterceptor = (payload) => import_neverthrow21.ResultAsync.fromPromise(
    requestInterceptor(payload),
    (error) => SdkError("requestInterceptorError", payload.interactionId, error.message)
  );
  const getTransport = (interactionId) => {
    const transport = availableTransports.find(
      (transport2) => transport2.isSupported()
    );
    return transport ? (0, import_neverthrow21.ok)(transport) : (0, import_neverthrow21.err)({
      error: "SupportedTransportNotFound",
      interactionId,
      message: "No supported transport found"
    });
  };
  const sendInteraction = ({
    interactionId = (0, import_uuid3.v4)(),
    items
  }, callbackFns = {}) => withInterceptor({
    items,
    interactionId,
    metadata
  }).andThen(
    (walletInteraction) => getTransport(walletInteraction.interactionId).asyncAndThen(
      (transport) => transport.send(walletInteraction, callbackFns)
    ).andThen(
      (response) => response.discriminator === "failure" ? (0, import_neverthrow21.errAsync)(response) : (0, import_neverthrow21.okAsync)(response)
    )
  );
  return {
    sendInteraction,
    createWalletInteraction,
    getTransport
  };
};

// src/modules/wallet-request/wallet-request.ts
var import_rxjs13 = require("rxjs");
var import_neverthrow29 = require("neverthrow");

// src/modules/wallet-request/request-resolver/request-resolver.module.ts
var import_neverthrow22 = require("neverthrow");
var import_rxjs10 = require("rxjs");
var RequestResolverModule = (input) => {
  const WAIT_TIME = 1e3;
  const { providers } = input;
  const { requestItemModule, storageModule, resolvers } = providers;
  const logger = input.logger?.getSubLogger({ name: "RequestResolverModule" });
  let shouldRun = true;
  const walletResponses = storageModule.getPartition("walletResponses");
  const getPendingRequests = () => requestItemModule.getPending().orElse((error) => {
    logger?.error({ method: "getPendingRequests", error });
    return (0, import_neverthrow22.ok)([]);
  }).andThen(
    (pendingItems) => pendingItems.length === 0 ? (0, import_neverthrow22.err)("PendingItemsNotFound") : (0, import_neverthrow22.ok)(pendingItems)
  );
  const getPendingRequestById = (interactionId) => requestItemModule.getById(interactionId).mapErr(() => SdkError("FailedToGetPendingItems", interactionId)).andThen(
    (pendingItem) => pendingItem?.status === "pending" ? (0, import_neverthrow22.ok)(pendingItem) : (0, import_neverthrow22.err)(SdkError("PendingItemNotFound", interactionId))
  );
  const getWalletResponseById = (interactionId) => requestItemModule.getById(interactionId).mapErr(() => SdkError("FailedToGetWalletResponse", interactionId)).map((item) => item?.walletResponse);
  const markRequestAsSent = (interactionId) => requestItemModule.patch(interactionId, { sentToWallet: true });
  const addWalletResponses = (responses) => import_neverthrow22.Result.combine(responses.map(validateWalletResponse)).asyncAndThen(
    () => walletResponses.setItems(
      responses.reduce(
        (acc, response) => {
          acc[response.interactionId] = response;
          return acc;
        },
        {}
      )
    )
  ).mapErr((error) => logger?.error({ method: "addWalletResponses", error }));
  const toRequestItemMap = (items) => items.reduce(
    (acc, item) => ({ ...acc, [item.interactionId]: item }),
    {}
  );
  const matchRequestItemToResponses = (requestItems) => {
    const ids = Object.keys(requestItems);
    return walletResponses.getItemList().map(
      (responses) => responses.filter((response) => ids.includes(response.interactionId))
    ).andThen(
      (responses) => responses.length ? (0, import_neverthrow22.ok)(responses) : (0, import_neverthrow22.err)("WalletResponsesNotFound")
    ).map(
      (responses) => responses.map((response) => ({
        walletInteractionResponse: response,
        requestItem: requestItems[response.interactionId]
      }))
    );
  };
  const resolveRequests = (unresolvedRequests) => import_neverthrow22.ResultAsync.combine(unresolvedRequests.map(resolveRequest)).map(
    () => unresolvedRequests
  );
  const cleanup = (requestItems) => {
    return (0, import_neverthrow22.okAsync)(void 0);
  };
  const resolveRequest = ({
    requestItem,
    walletInteractionResponse
  }) => {
    const { walletInteraction } = requestItem;
    return import_neverthrow22.ResultAsync.combine(
      resolvers.map(
        (resolver) => resolver({ walletInteraction, walletInteractionResponse, requestItem })
      )
    );
  };
  const waitForWalletResponse = (interactionId) => import_neverthrow22.ResultAsync.fromSafePromise(
    (0, import_rxjs10.firstValueFrom)(
      requestItemModule.requests$.pipe(
        (0, import_rxjs10.filter)(
          (items) => items.some(
            (item) => item.interactionId === interactionId && item.status !== "pending"
          )
        ),
        (0, import_rxjs10.map)(
          (items) => items.find((item) => item.interactionId === interactionId)
        )
      )
    )
  );
  const requestResolverLoop = async () => {
    await getPendingRequests().map(toRequestItemMap).andThen(matchRequestItemToResponses).andThen(resolveRequests).map(
      (unresolvedRequests) => unresolvedRequests.map((item) => item.requestItem)
    ).andThen(cleanup);
    await new Promise((resolve) => setTimeout(resolve, WAIT_TIME));
    if (shouldRun) requestResolverLoop();
  };
  requestResolverLoop();
  return {
    waitForWalletResponse,
    getPendingRequestById,
    getPendingRequestIds: () => getPendingRequests().map(
      (items) => items.map((item) => item.interactionId)
    ),
    markRequestAsSent,
    addWalletResponses,
    getWalletResponseById,
    destroy: () => {
      shouldRun = false;
    }
  };
};

// src/modules/wallet-request/request-resolver/resolvers/data-response.ts
var import_neverthrow23 = require("neverthrow");
var matchResponse = (input) => {
  if (input.discriminator === "success") {
    if (input.items.discriminator === "authorizedRequest" || input.items.discriminator === "unauthorizedRequest") {
      return input.items;
    }
  }
};
var useDataRequestController = (getDataRequestController, interactionId) => (walletData) => {
  const maybeDataRequestController = getDataRequestController();
  if (!maybeDataRequestController) return (0, import_neverthrow23.okAsync)(walletData);
  return maybeDataRequestController(walletData).map(() => walletData).mapErr((error) => SdkError(error.error, interactionId, error.message));
};
var handleAuthorizedRequestResponse = ({
  requestItem,
  walletInteraction,
  walletData,
  stateModule
}) => stateModule.getState().andThen(
  (state) => stateModule.setState({
    loggedInTimestamp: requestItem.type === "loginRequest" ? Date.now().toString() : state.loggedInTimestamp,
    walletData,
    sharedData: transformWalletRequestToSharedData(
      walletInteraction,
      state.sharedData
    )
  }).andTee(() => stateModule.emitWalletData())
).orElse(
  () => (0, import_neverthrow23.err)(SdkError("FailedToUpdateRdtState", walletInteraction.interactionId))
);
var dataResponseResolver = (dependencies) => ({ walletInteraction, walletInteractionResponse, requestItem }) => {
  const dataResponse = matchResponse(walletInteractionResponse);
  if (!dataResponse) return (0, import_neverthrow23.okAsync)(void 0);
  const { requestItemModule, getDataRequestController, stateModule } = dependencies;
  const { interactionId } = walletInteraction;
  return transformWalletResponseToRdtWalletData(dataResponse).andThen(
    useDataRequestController(getDataRequestController, interactionId)
  ).andThen(
    (walletData) => dataResponse.discriminator === "authorizedRequest" ? handleAuthorizedRequestResponse({
      requestItem,
      walletInteraction,
      walletData,
      stateModule
    }).map(() => walletData) : (0, import_neverthrow23.okAsync)(walletData)
  ).andThen(
    (walletData) => requestItemModule.updateStatus({
      id: walletInteraction.interactionId,
      status: "success",
      walletData,
      walletResponse: walletInteractionResponse
    }).mapErr(
      (error) => SdkError(error.reason, walletInteraction.interactionId)
    )
  ).andTee(() => dependencies.updateConnectButtonStatus("success")).orElse((error) => {
    dependencies.updateConnectButtonStatus("fail");
    return (0, import_neverthrow23.err)(error);
  }).map(() => void 0);
};

// src/modules/wallet-request/request-resolver/resolvers/failed-response.ts
var import_neverthrow24 = require("neverthrow");
var matchResponse2 = (input) => {
  if (input.discriminator === "failure") {
    return input;
  }
};
var failedResponseResolver = (dependencies) => ({ walletInteraction, walletInteractionResponse }) => {
  const failedResponse = matchResponse2(walletInteractionResponse);
  if (!failedResponse) return (0, import_neverthrow24.okAsync)(void 0);
  const { interactionId } = walletInteraction;
  const { requestItemModule } = dependencies;
  return requestItemModule.updateStatus({
    id: interactionId,
    status: "fail",
    walletResponse: walletInteractionResponse
  }).orElse((error) => {
    dependencies.updateConnectButtonStatus("fail");
    return (0, import_neverthrow24.err)(SdkError(error.reason, interactionId));
  }).andTee(() => dependencies.updateConnectButtonStatus("fail")).map(() => void 0);
};

// src/modules/wallet-request/request-resolver/resolvers/send-transaction-response.ts
var import_neverthrow26 = require("neverthrow");

// src/modules/gateway/types.ts
var TransactionStatus = {
  Unknown: "Unknown",
  CommittedSuccess: "CommittedSuccess",
  CommittedFailure: "CommittedFailure",
  Pending: "Pending",
  Rejected: "Rejected"
};
var RadixNetwork = {
  Mainnet: 1,
  Stokenet: 2,
  Gilganet: 32,
  Enkinet: 33,
  Hammunet: 34,
  Nergalnet: 35,
  Mardunet: 36,
  Dumunet: 37
};
var RadixNetworkConfig = {
  Mainnet: {
    networkName: "Mainnet",
    networkId: RadixNetwork.Mainnet,
    gatewayUrl: "https://mainnet.radixdlt.com",
    dashboardUrl: "https://dashboard.radixdlt.com"
  },
  Stokenet: {
    networkName: "Stokenet",
    networkId: RadixNetwork.Stokenet,
    gatewayUrl: "https://babylon-stokenet-gateway.radixdlt.com",
    dashboardUrl: "https://stokenet-dashboard.radixdlt.com"
  },
  Mardunet: {
    networkName: "Mardunet",
    networkId: RadixNetwork.Mardunet,
    gatewayUrl: "https://mardunet-gateway.radixdlt.com",
    dashboardUrl: "https://mardunet-dashboard.rdx-works-main.extratools.works"
  },
  Gilganet: {
    networkName: "Gilganet",
    networkId: RadixNetwork.Gilganet,
    gatewayUrl: "https://gilganet-gateway.radixdlt.com",
    dashboardUrl: "https://gilganet-dashboard.rdx-works-main.extratools.works"
  },
  Enkinet: {
    networkName: "Enkinet",
    networkId: RadixNetwork.Enkinet,
    gatewayUrl: "https://enkinet-gateway.radixdlt.com",
    dashboardUrl: "https://enkinet-dashboard.rdx-works-main.extratools.works"
  },
  Hammunet: {
    networkName: "Hammunet",
    networkId: RadixNetwork.Hammunet,
    gatewayUrl: "https://hammunet-gateway.radixdlt.com",
    dashboardUrl: "https://hammunet-dashboard.rdx-works-main.extratools.works"
  },
  Dumunet: {
    networkName: "Dumunet",
    networkId: RadixNetwork.Dumunet,
    gatewayUrl: "https://dumunet-gateway.radixdlt.com",
    dashboardUrl: "https://dumunet-dashboard.rdx-works-main.extratools.works"
  }
};
var RadixNetworkConfigById = Object.values(RadixNetworkConfig).reduce(
  (prev, config2) => {
    prev[config2.networkId] = config2;
    return prev;
  },
  {}
);

// src/modules/gateway/helpers/generate-gateway-api-config.ts
var generateGatewayApiConfig = ({
  networkId,
  dAppDefinitionAddress,
  gatewayBaseUrl,
  applicationName,
  applicationVersion
}) => ({
  basePath: gatewayBaseUrl ?? RadixNetworkConfigById[networkId].gatewayUrl,
  applicationName: applicationName ?? "Unknown",
  applicationVersion: applicationVersion ?? "Unknown",
  applicationDappDefinitionAddress: dAppDefinitionAddress
});

// src/version.ts
var __VERSION__ = "2.2.1";

// src/modules/gateway/gateway.service.ts
var GatewayApiService = ({
  basePath,
  applicationName,
  applicationVersion,
  applicationDappDefinitionAddress
}) => {
  const fetchWithHeaders = (url, body) => fetchWrapper(
    fetch(`${basePath}${url}`, {
      method: "POST",
      body: JSON.stringify(body),
      headers: {
        "Content-Type": "application/json",
        "RDX-Client-Name": "@radixdlt/radix-dapp-toolkit",
        "RDX-Client-Version": __VERSION__,
        "RDX-App-Name": applicationName,
        "RDX-App-Version": applicationVersion,
        "RDX-App-Dapp-Definition": applicationDappDefinitionAddress
      }
    })
  ).map((response) => response.data);
  const getTransactionStatus = (transactionIntentHash) => fetchWithHeaders("/transaction/status", {
    intent_hash: transactionIntentHash
  });
  const getSubintentStatus = (subintentHash) => fetchWithHeaders("/transaction/subintent-status", {
    subintent_hash: subintentHash
  });
  const getEntityMetadataPage = (address) => fetchWithHeaders("/state/entity/page/metadata", { address });
  return {
    getSubintentStatus,
    getTransactionStatus,
    getEntityMetadataPage
  };
};

// src/modules/gateway/gateway.module.ts
var import_neverthrow25 = require("neverthrow");
var import_rxjs11 = require("rxjs");
var GatewayModule = (input) => {
  const logger = input.logger?.getSubLogger({ name: "GatewayModule" });
  const gatewayApi = input?.providers?.gatewayApiService ?? GatewayApiService(input.clientConfig);
  const poll = (hash2, apiCall, exponentialBackoff) => {
    return import_neverthrow25.ResultAsync.fromPromise(
      (0, import_rxjs11.firstValueFrom)(
        exponentialBackoff.withBackoff$.pipe(
          (0, import_rxjs11.switchMap)((result) => {
            if (result.isErr())
              return [
                (0, import_neverthrow25.err)(
                  SdkError("failedToPoll", "", void 0, {
                    error: result.error,
                    context: "GatewayModule.poll.retry.withBackoff$",
                    hash: hash2
                  })
                )
              ];
            logger?.debug(`Polling ${hash2} retry #${result.value + 1}`);
            return apiCall().orElse((response) => {
              if (response.reason === "FailedToFetch") {
                logger?.debug({
                  error: response,
                  context: "unexpected error, retrying"
                });
                exponentialBackoff.trigger.next();
                return (0, import_neverthrow25.ok)(void 0);
              }
              logger?.debug(response);
              return (0, import_neverthrow25.err)(
                SdkError("failedToPoll", "", void 0, {
                  error: response,
                  hash: hash2,
                  context: "GatewayModule.poll"
                })
              );
            });
          }),
          (0, import_rxjs11.filter)(
            (result) => result.isOk() && !!result.value || result.isErr()
          ),
          (0, import_rxjs11.first)()
        )
      ),
      (error) => error
    ).andThen((result) => result);
  };
  const pollTransactionStatus = (transactionIntentHash) => {
    const exponentialBackoff = ExponentialBackoff(input.retryConfig);
    return poll(
      transactionIntentHash,
      () => gatewayApi.getTransactionStatus(transactionIntentHash).map(({ status }) => {
        const completedStatus = /* @__PURE__ */ new Set([
          "CommittedSuccess",
          "CommittedFailure",
          "Rejected"
        ]);
        if (completedStatus.has(status)) return status;
        exponentialBackoff.trigger.next();
        return;
      }),
      exponentialBackoff
    );
  };
  const pollSubintentStatus = (subintentHash, expirationTimestamp) => {
    const exponentialBackoff = ExponentialBackoff({
      ...input.retryConfig,
      maxDelayTime: 6e4,
      timeout: new Date(expirationTimestamp * 1e3)
    });
    return {
      stop: exponentialBackoff.stop,
      result: poll(
        subintentHash,
        () => gatewayApi.getSubintentStatus(subintentHash).map(
          ({ subintent_status, finalized_at_transaction_intent_hash }) => {
            if (subintent_status === "CommittedSuccess") {
              return {
                subintentStatus: subintent_status,
                transactionIntentHash: finalized_at_transaction_intent_hash
              };
            }
            exponentialBackoff.trigger.next();
            return;
          }
        ),
        exponentialBackoff
      )
    };
  };
  return {
    pollSubintentStatus,
    pollTransactionStatus,
    gatewayApi,
    configuration: input.clientConfig
  };
};

// src/modules/wallet-request/request-resolver/resolvers/send-transaction-response.ts
var matchResponse3 = (input) => {
  if (input.discriminator === "success" && input.items.discriminator === "transaction") {
    return input.items;
  }
};
var determineFailedTransaction = (status) => {
  const failedTransactionStatus = [
    TransactionStatus.Rejected,
    TransactionStatus.CommittedFailure
  ];
  return failedTransactionStatus.includes(status);
};
var sendTransactionResponseResolver = (dependencies) => ({ walletInteraction, walletInteractionResponse }) => {
  const transactionResponse = matchResponse3(walletInteractionResponse);
  if (!transactionResponse) return (0, import_neverthrow26.okAsync)(void 0);
  const { gatewayModule, requestItemModule, updateConnectButtonStatus } = dependencies;
  const { interactionId } = walletInteraction;
  const {
    send: { transactionIntentHash }
  } = transactionResponse;
  return requestItemModule.getById(interactionId).mapErr(() => SdkError("FailedToGetItemWithInteractionId", interactionId)).andTee(
    () => requestItemModule.getAndRemoveSignal(interactionId)?.(
      transactionIntentHash
    )
  ).andThen(() => gatewayModule.pollTransactionStatus(transactionIntentHash)).andThen((status) => {
    const isFailedTransaction = determineFailedTransaction(status);
    const requestItemStatus = isFailedTransaction ? "fail" : "success";
    return requestItemModule.updateStatus({
      id: interactionId,
      status: requestItemStatus,
      transactionIntentHash,
      metadata: { transactionStatus: status },
      walletResponse: walletInteractionResponse
    }).orElse((error) => (0, import_neverthrow26.err)(SdkError(error.reason, interactionId))).andThen(() => {
      updateConnectButtonStatus(requestItemStatus);
      return (0, import_neverthrow26.okAsync)(void 0);
    }).orElse((error) => {
      updateConnectButtonStatus("fail");
      return (0, import_neverthrow26.err)(error);
    });
  }).map(() => void 0);
};

// src/modules/wallet-request/request-resolver/resolvers/pre-authorization-response.ts
var import_neverthrow27 = require("neverthrow");
var matchResponse4 = (input) => {
  if (input.discriminator === "success" && input.items.discriminator === "preAuthorizationResponse") {
    return input.items.response;
  }
};
var preAuthorizationResponseResolver = (dependencies) => ({ walletInteraction, walletInteractionResponse }) => {
  const response = matchResponse4(walletInteractionResponse);
  if (!response) return (0, import_neverthrow27.okAsync)(void 0);
  const { signedPartialTransaction, expirationTimestamp, subintentHash } = response;
  const { interactionId } = walletInteraction;
  const { requestItemModule } = dependencies;
  return requestItemModule.updateStatus({
    id: interactionId,
    status: RequestStatus.pendingCommit,
    transactionIntentHash: subintentHash,
    walletResponse: walletInteractionResponse,
    metadata: {
      signedPartialTransaction,
      expirationTimestamp,
      subintentHash
    }
  }).orElse((error) => {
    dependencies.updateConnectButtonStatus("fail");
    return (0, import_neverthrow27.err)(SdkError(error.reason, interactionId));
  }).andTee(() => dependencies.updateConnectButtonStatus("success")).map(() => void 0);
};

// src/modules/wallet-request/pre-authorization-request/preauthorization-polling-module.ts
var import_neverthrow28 = require("neverthrow");
var import_rxjs12 = require("rxjs");
var PreauthorizationPollingModule = (input) => {
  const logger = input?.logger?.getSubLogger({
    name: "PreauthorizationPolling"
  });
  const {
    providers: { requestItemModule, ignoreTransactionSubject }
  } = input;
  let shouldRun = true;
  const WAIT_TIME = 1e3;
  const activePolling = /* @__PURE__ */ new Map();
  const subscriptions = new import_rxjs12.Subscription();
  subscriptions.add(
    ignoreTransactionSubject.pipe(
      (0, import_rxjs12.tap)((id) => {
        if (activePolling.has(id)) {
          activePolling.get(id)?.stop();
          activePolling.delete(id);
        }
      })
    ).subscribe()
  );
  const preauthorizationPollingLoop = async () => {
    await requestItemModule.getPendingCommit().andThen((lookedUpItems) => {
      const timedOutItems = [];
      const lookupItems = [];
      lookedUpItems.forEach((item) => {
        if (Number(item.metadata?.expirationTimestamp) * 1e3 < Date.now()) {
          timedOutItems.push(item);
        } else {
          lookupItems.push(item);
        }
      });
      lookupItems.forEach((item) => {
        if (!activePolling.has(item.interactionId)) {
          const polling = input.providers.gatewayModule.pollSubintentStatus(
            item.transactionIntentHash,
            item.metadata?.expirationTimestamp
          );
          activePolling.set(item.interactionId, polling);
          polling.result.andTee(
            (result) => requestItemModule.updateStatus({
              id: item.interactionId,
              status: RequestStatus.success,
              metadata: {
                parentTransactionIntentHash: result.transactionIntentHash
              }
            })
          ).mapErr(() => {
            activePolling.delete(item.interactionId);
          });
        }
      });
      return import_neverthrow28.ResultAsync.combine(
        timedOutItems.map((item) => {
          if (activePolling.has(item.interactionId)) {
            activePolling.get(item.interactionId)?.stop();
            activePolling.delete(item.interactionId);
          }
          return requestItemModule.updateStatus({
            id: item.interactionId,
            status: RequestStatus.timedOut
          });
        })
      );
    });
    await new Promise((resolve) => setTimeout(resolve, WAIT_TIME));
    if (shouldRun) preauthorizationPollingLoop();
  };
  preauthorizationPollingLoop();
  return {
    destroy: () => {
      shouldRun = false;
      subscriptions.unsubscribe();
    }
  };
};

// src/modules/wallet-request/wallet-request.ts
var WalletRequestModule = (input) => {
  const logger = input.logger?.getSubLogger({ name: "WalletRequestModule" });
  const useCache = input.useCache;
  const networkId = input.networkId;
  const cancelRequestSubject = new import_rxjs13.Subject();
  const ignoreTransactionSubject = new import_rxjs13.Subject();
  const interactionStatusChangeSubject = new import_rxjs13.Subject();
  const gatewayModule = input.providers.gatewayModule;
  const dAppDefinitionAddress = input.dAppDefinitionAddress;
  const stateModule = input.providers.stateModule;
  const storageModule = input.providers.storageModule;
  const dataRequestStateModule = input.providers.dataRequestStateModule ?? DataRequestStateModule({});
  const requestItemModule = input.providers.requestItemModule ?? RequestItemModule({
    logger,
    providers: {
      gatewayModule,
      storageModule: storageModule.getPartition("requests")
    }
  });
  const preauthorizationPollingModule = input.providers.preauthorizationPollingModule ?? PreauthorizationPollingModule({
    logger,
    providers: {
      gatewayModule,
      requestItemModule,
      ignoreTransactionSubject
    }
  });
  const updateConnectButtonStatus = (status) => {
    interactionStatusChangeSubject.next(status);
  };
  const requestResolverModule = input.providers.requestResolverModule ?? RequestResolverModule({
    logger,
    providers: {
      storageModule,
      requestItemModule,
      resolvers: [
        sendTransactionResponseResolver({
          gatewayModule,
          requestItemModule,
          updateConnectButtonStatus
        }),
        preAuthorizationResponseResolver({
          requestItemModule,
          updateConnectButtonStatus
        }),
        failedResponseResolver({
          requestItemModule,
          updateConnectButtonStatus
        }),
        dataResponseResolver({
          requestItemModule,
          getDataRequestController: () => dataRequestControl,
          stateModule,
          updateConnectButtonStatus
        })
      ]
    }
  });
  const transports = input.providers.transports ?? [
    ConnectorExtensionModule({
      logger,
      providers: {
        storageModule,
        requestResolverModule,
        environmentModule: input.providers.environmentModule
      }
    }),
    RadixConnectRelayModule({
      logger,
      walletUrl: "radixWallet://connect",
      baseUrl: "https://radix-connect-relay.radixdlt.com",
      dAppDefinitionAddress: input.dAppDefinitionAddress,
      providers: {
        storageModule,
        requestResolverModule,
        environmentModule: input.providers.environmentModule
      }
    })
  ];
  const walletRequestSdk = input.providers.walletRequestSdk ?? WalletRequestSdk({
    logger,
    networkId,
    origin: input.origin,
    dAppDefinitionAddress,
    requestInterceptor: input.requestInterceptor,
    providers: {
      transports,
      environmentModule: input.providers.environmentModule
    }
  });
  const cancelRequestControl = (id) => {
    const messageLifeCycleEvent = new import_rxjs13.Subject();
    return {
      eventCallback: (event) => {
        messageLifeCycleEvent.next(event);
      },
      requestControl: ({ cancelRequest: cancelRequest2, getRequest }) => {
        (0, import_rxjs13.firstValueFrom)(
          messageLifeCycleEvent.pipe(
            (0, import_rxjs13.filter)((event) => event === "receivedByWallet"),
            (0, import_rxjs13.map)(() => getRequest()),
            (0, import_rxjs13.tap)((request) => {
              if (["transaction", "preAuthorizationRequest"].includes(
                request.items.discriminator
              ))
                requestItemModule.patch(id, { showCancel: false });
            })
          )
        );
        (0, import_rxjs13.firstValueFrom)(
          cancelRequestSubject.pipe(
            (0, import_rxjs13.filter)((requestItemId) => requestItemId === id),
            (0, import_rxjs13.switchMap)(
              () => requestItemModule.cancel(id).andThen(() => cancelRequest2())
            )
          )
        );
        (0, import_rxjs13.firstValueFrom)(
          ignoreTransactionSubject.pipe(
            (0, import_rxjs13.filter)((requestItemId) => requestItemId === id),
            (0, import_rxjs13.switchMap)(
              () => requestItemModule.updateStatus({
                id,
                status: "ignored"
              }).andThen(() => cancelRequest2())
            )
          )
        );
      }
    };
  };
  let challengeGeneratorFn = () => Promise.resolve("");
  let connectResponseCallback;
  let dataRequestControl;
  const isChallengeNeeded = (dataRequestState) => dataRequestState.accounts?.withProof || dataRequestState.persona?.withProof || dataRequestState.proofOfOwnership;
  const getChallenge = (dataRequestState) => {
    if (!isChallengeNeeded(dataRequestState)) return (0, import_neverthrow29.okAsync)(void 0);
    return import_neverthrow29.ResultAsync.fromPromise(
      challengeGeneratorFn(),
      () => SdkError("ChallengeGeneratorError", "", "failed to generate challenge")
    ).andThen(
      (challenge) => validateRolaChallenge(challenge) ? (0, import_neverthrow29.ok)(challenge) : (0, import_neverthrow29.err)(SdkError("ChallengeValidationError", "", "challenge is invalid"))
    );
  };
  const provideConnectResponseCallback = (fn) => {
    connectResponseCallback = (result) => fn(result);
  };
  const provideDataRequestControl = (fn) => {
    dataRequestControl = (walletData) => import_neverthrow29.ResultAsync.fromPromise(fn(walletData), () => ({
      error: "LoginRejectedByDapp",
      message: "Login rejected by dApp"
    }));
  };
  const sendRequestAndAwaitResponse = (walletInteraction) => {
    updateConnectButtonStatus("pending");
    return import_neverthrow29.ResultAsync.combine([
      walletRequestSdk.sendInteraction(
        walletInteraction,
        cancelRequestControl(walletInteraction.interactionId)
      ),
      requestResolverModule.waitForWalletResponse(
        walletInteraction.interactionId
      )
    ]).map(([_2, response]) => response);
  };
  const sendOneTimeRequest = (...items) => sendRequest({
    dataRequestState: dataRequestStateModule.toDataRequestState(...items),
    isConnect: false,
    oneTime: true
  });
  const sendDataRequest = (walletInteraction) => sendRequestAndAwaitResponse(walletInteraction).andThen((response) => {
    logger?.debug({ method: "sendDataRequest.successResponse", response });
    return (0, import_neverthrow29.ok)(response.walletData);
  }).mapErr((error) => {
    logger?.debug({ method: "sendDataRequest.errorResponse", error });
    return error;
  });
  const getRdtState = () => stateModule.getState().mapErr(() => SdkError("FailedToReadRdtState", ""));
  const addNewRequest = (type, walletInteraction, isOneTimeRequest, signal) => requestItemModule.add(
    {
      type,
      walletInteraction,
      isOneTimeRequest
    },
    signal
  ).mapErr(
    ({ message }) => SdkError(
      "FailedToCreateRequestItem",
      walletInteraction.interactionId,
      message
    )
  );
  const sendPreAuthorizationRequest = (value) => {
    const walletInteraction = walletRequestSdk.createWalletInteraction({
      discriminator: "preAuthorizationRequest",
      request: value.toRequestItem()
    });
    return addNewRequest(
      "preAuthorizationRequest",
      walletInteraction,
      false,
      value.getOnSubmittedSuccessFn?.()
    ).andThen(() => sendRequestAndAwaitResponse(walletInteraction)).map(
      (requestItem) => ({
        ...requestItem.metadata
      })
    );
  };
  const sendRequest = ({
    isConnect,
    oneTime,
    dataRequestState
  }) => import_neverthrow29.ResultAsync.combine([
    getChallenge(dataRequestState),
    getRdtState()
  ]).andThen(
    ([challenge, state]) => toWalletRequest({
      dataRequestState,
      isConnect,
      oneTime,
      challenge,
      walletData: state.walletData
    }).mapErr(() => SdkError("FailedToTransformWalletRequest", "")).asyncAndThen((walletDataRequest) => {
      const walletInteraction = walletRequestSdk.createWalletInteraction(walletDataRequest);
      if (canDataRequestBeResolvedByRdtState(walletDataRequest, state) && useCache)
        return (0, import_neverthrow29.okAsync)(state.walletData);
      const isLoginRequest = !state.walletData.persona && walletDataRequest.discriminator === "authorizedRequest";
      const isProofOfOwnershipRequest = walletDataRequest.discriminator === "authorizedRequest" && !!walletDataRequest.proofOfOwnership;
      const requestType = isLoginRequest ? "loginRequest" : isProofOfOwnershipRequest ? "proofRequest" : "dataRequest";
      return addNewRequest(requestType, walletInteraction, oneTime).andThen(
        () => sendDataRequest(walletInteraction)
      );
    })
  );
  const setRequestDataState = (...items) => {
    dataRequestStateModule.setState(...items);
    return {
      sendRequest: () => sendRequest({
        dataRequestState: dataRequestStateModule.getState(),
        isConnect: false,
        oneTime: false
      })
    };
  };
  const updateSharedAccounts = () => stateModule.getState().mapErr((err18) => {
    logger?.error(err18);
    return {
      error: "FailedToReadRdtState",
      message: "failed to read rdt state",
      jsError: err18
    };
  }).andThen(
    (state) => sendRequest({
      dataRequestState: transformSharedDataToDataRequestState(
        state.sharedData
      ),
      isConnect: false,
      oneTime: false
    })
  );
  const subscriptions = new import_rxjs13.Subscription();
  const sendTransaction = (value) => {
    const createTransactionRequest = () => {
      const walletInteraction = walletRequestSdk.createWalletInteraction({
        discriminator: "transaction",
        send: {
          blobs: value.blobs,
          transactionManifest: value.transactionManifest,
          message: value.message,
          version: value.version ?? 1
        }
      });
      return requestItemModule.add(
        {
          type: "sendTransaction",
          walletInteraction,
          isOneTimeRequest: false
        },
        value.onTransactionId
      ).mapErr(
        () => SdkError("FailedToAddRequestItem", walletInteraction.interactionId)
      ).map(() => walletInteraction);
    };
    return createTransactionRequest().andThen(
      (walletInteraction) => sendRequestAndAwaitResponse(walletInteraction)
    ).andThen(({ status, transactionIntentHash, metadata, interactionId }) => {
      const output2 = {
        transactionIntentHash,
        status: metadata.transactionStatus
      };
      return status === "success" ? (0, import_neverthrow29.ok)(output2) : (0, import_neverthrow29.err)(SdkError(output2.status, interactionId));
    });
  };
  const getTransport = () => transports.find((transport) => transport.isSupported());
  const getPendingRequests = () => requestItemModule.getPending();
  const cancelRequest = (id) => {
    cancelRequestSubject.next(id);
    requestItemModule.cancel(id);
    interactionStatusChangeSubject.next("fail");
    updateConnectButtonStatus("fail");
  };
  const ignoreTransaction = (id) => {
    ignoreTransactionSubject.next(id);
    requestItemModule.updateStatus({
      id,
      status: "ignored"
    });
    interactionStatusChangeSubject.next("fail");
  };
  const provideChallengeGenerator = (fn) => {
    challengeGeneratorFn = fn;
  };
  const disconnect = () => {
    requestItemModule.getPending().map((items) => {
      items.forEach((item) => {
        if (item.showCancel) cancelRequestSubject.next(item.interactionId);
      });
    });
    stateModule.reset();
    requestItemModule.clear();
    transports.forEach((transport) => transport?.disconnect());
  };
  const destroy = () => {
    stateModule.destroy();
    requestItemModule.destroy();
    requestResolverModule.destroy();
    preauthorizationPollingModule.destroy();
    input.providers.transports?.forEach((transport) => transport.destroy());
    subscriptions.unsubscribe();
  };
  return {
    sendRequest: (input2) => sendRequest({
      isConnect: input2.isConnect,
      oneTime: input2.oneTime,
      dataRequestState: dataRequestStateModule.getState()
    }).andThen((response) => {
      if (connectResponseCallback) connectResponseCallback((0, import_neverthrow29.ok)(response));
      return (0, import_neverthrow29.ok)(response);
    }).orElse((error) => {
      if (connectResponseCallback) connectResponseCallback((0, import_neverthrow29.err)(error));
      return (0, import_neverthrow29.err)(error);
    }),
    sendTransaction,
    sendPreAuthorizationRequest,
    cancelRequest,
    ignoreTransaction,
    requestItemModule,
    provideChallengeGenerator,
    provideDataRequestControl,
    provideConnectResponseCallback,
    sendOneTimeRequest,
    setRequestDataState,
    getPendingRequests,
    getTransport,
    updateSharedAccounts,
    dataRequestStateModule,
    interactionStatusChange$: interactionStatusChangeSubject.asObservable(),
    requestItems$: requestItemModule.requests$,
    disconnect,
    destroy
  };
};

// src/modules/wallet-request/pre-authorization-request/subintent-builder.ts
var SubintentRequestBuilder = () => {
  let state = {
    discriminator: "subintent",
    version: 1,
    manifestVersion: 2
  };
  let onSubmittedSuccessFn;
  const onSubmittedSuccess = (callback) => {
    onSubmittedSuccessFn = callback;
    return api;
  };
  const setExpiration = (type, value) => {
    state.expiration = type === "atTime" ? {
      discriminator: "expireAtTime",
      unixTimestampSeconds: value
    } : {
      discriminator: "expireAfterDelay",
      expireAfterSeconds: value
    };
    return api;
  };
  const addBlobs = (...blobs) => {
    state.blobs = blobs;
    return api;
  };
  const message = (message2) => {
    state.message = message2;
    return api;
  };
  const manifest = (value) => {
    state.subintentManifest = value;
    return { setExpiration };
  };
  const toRequestItem = () => state;
  const rawConfig = (rawConfig2) => {
    state = { ...rawConfig2, discriminator: "subintent" };
    return { toRequestItem };
  };
  const api = {
    addBlobs,
    message,
    toRequestItem,
    onSubmittedSuccess,
    getOnSubmittedSuccessFn: () => onSubmittedSuccessFn
  };
  return { manifest, rawConfig };
};

// src/modules/connect-button/connect-button-noop.module.ts
var import_rxjs14 = require("rxjs");
var ConnectButtonNoopModule = () => {
  return {
    status$: import_rxjs14.NEVER,
    onConnect$: import_rxjs14.NEVER,
    onDisconnect$: import_rxjs14.NEVER,
    onUpdateSharedAccounts$: import_rxjs14.NEVER,
    onShowPopover$: import_rxjs14.NEVER,
    onCancelRequestItem$: import_rxjs14.NEVER,
    onLinkClick$: import_rxjs14.NEVER,
    setStatus: () => {
    },
    setMode: () => {
    },
    setTheme: () => {
    },
    setActiveTab: () => {
    },
    setIsMobile: () => {
    },
    setIsWalletLinked: () => {
    },
    setIsExtensionAvailable: () => {
    },
    setConnected: () => {
    },
    setLoggedInTimestamp: () => {
    },
    setRequestItems: () => {
    },
    setAccounts: () => {
    },
    setPersonaData: () => {
    },
    setPersonaLabel: () => {
    },
    setDappName: () => {
    },
    destroy: () => {
    },
    disconnect: () => {
    }
  };
};

// src/modules/connect-button/connect-button.module.ts
var ConnectButtonModule = (input) => {
  if (!input.providers.environmentModule.isBrowser()) {
    return ConnectButtonNoopModule();
  }
  Promise.resolve().then(() => init_connect_button());
  const logger = input?.logger?.getSubLogger({ name: "ConnectButtonModule" });
  const subjects = input.subjects || ConnectButtonSubjects({
    providers: { environmentModule: input.providers.environmentModule }
  });
  const dAppDefinitionAddress = input.dAppDefinitionAddress;
  const { baseUrl, accountsPath, transactionPath, subintentPath } = input.explorer ?? {
    baseUrl: RadixNetworkConfigById[input.networkId].dashboardUrl,
    transactionPath: "/transaction/",
    subintentPath: "/subintent/",
    accountsPath: "/account/"
  };
  const stateModule = input.providers.stateModule;
  const gatewayModule = input.providers.gatewayModule;
  const walletRequestModule = input.providers.walletRequestModule;
  const onConnectDefault = (done) => {
    done();
  };
  const onConnect = input.onConnect || onConnectDefault;
  const transport = walletRequestModule.getTransport();
  const getConnectButtonElement = () => document.querySelector("radix-connect-button");
  const subscriptions = new import_rxjs15.Subscription();
  const onConnectButtonRender$ = (0, import_rxjs15.fromEvent)(input.providers.environmentModule.globalThis, "onConnectButtonRender");
  subscriptions.add(
    onConnectButtonRender$.pipe(
      (0, import_rxjs15.map)(() => getConnectButtonElement()),
      (0, import_rxjs15.filter)((element) => !!element),
      (0, import_rxjs15.switchMap)((connectButtonElement) => {
        logger?.debug({ observable: `onConnectButtonRender$` });
        const onConnect$ = (0, import_rxjs15.fromEvent)(connectButtonElement, "onConnect").pipe(
          (0, import_rxjs15.tap)(() => {
            onConnect((value) => subjects.onConnect.next(value));
          })
        );
        const onDisconnect$ = (0, import_rxjs15.fromEvent)(
          connectButtonElement,
          "onDisconnect"
        ).pipe((0, import_rxjs15.tap)(() => subjects.onDisconnect.next()));
        const onLinkClick$ = (0, import_rxjs15.fromEvent)(connectButtonElement, "onLinkClick").pipe(
          (0, import_rxjs15.tap)((ev) => {
            subjects.onLinkClick.next(ev.detail);
          })
        );
        const onDestroy$ = (0, import_rxjs15.fromEvent)(connectButtonElement, "onDestroy").pipe(
          (0, import_rxjs15.map)(() => {
            logger?.debug({ observable: `onDestroy$` });
            return true;
          })
        );
        const onCancelRequestItem$ = (0, import_rxjs15.fromEvent)(
          connectButtonElement,
          "onCancelRequestItem"
        ).pipe(
          (0, import_rxjs15.tap)((event) => {
            const id = event.detail.id;
            logger?.debug({ method: "onCancelRequestItem", id });
            subjects.onCancelRequestItem.next(id);
          })
        );
        const onIgnoreTransactionItem$ = (0, import_rxjs15.fromEvent)(
          connectButtonElement,
          "onIgnoreTransactionItem"
        ).pipe(
          (0, import_rxjs15.tap)((event) => {
            const id = event.detail.id;
            logger?.debug({
              method: "onIgnoreTransactionItem",
              id
            });
            subjects.onIgnoreTransactionItem.next(id);
          })
        );
        const onUpdateSharedAccounts$ = (0, import_rxjs15.fromEvent)(
          connectButtonElement,
          "onUpdateSharedAccounts"
        ).pipe(
          (0, import_rxjs15.tap)(() => {
            logger?.debug(`onUpdateSharedAccounts`);
            subjects.onUpdateSharedAccounts.next();
          })
        );
        const onShowPopover$ = (0, import_rxjs15.fromEvent)(
          connectButtonElement,
          "onShowPopover"
        ).pipe((0, import_rxjs15.tap)(() => subjects.onShowPopover.next()));
        const isWalletLinked$ = subjects.isWalletLinked.pipe(
          (0, import_rxjs15.tap)((value) => connectButtonElement.isWalletLinked = value)
        );
        const isExtensionAvailable$ = subjects.isExtensionAvailable.pipe(
          (0, import_rxjs15.tap)((value) => connectButtonElement.isExtensionAvailable = value)
        );
        const status$ = subjects.status.pipe(
          (0, import_rxjs15.tap)((value) => connectButtonElement.status = value)
        );
        const mode$ = subjects.mode.pipe(
          (0, import_rxjs15.tap)((value) => connectButtonElement.mode = value)
        );
        const connected$ = subjects.connected.pipe(
          (0, import_rxjs15.tap)((value) => connectButtonElement.connected = value)
        );
        const isMobile$ = subjects.isMobile.pipe(
          (0, import_rxjs15.tap)((value) => connectButtonElement.isMobile = value)
        );
        const loggedInTimestamp$ = subjects.loggedInTimestamp.pipe(
          (0, import_rxjs15.tap)((value) => connectButtonElement.loggedInTimestamp = value)
        );
        const activeTab$ = subjects.activeTab.pipe(
          (0, import_rxjs15.tap)((value) => connectButtonElement.activeTab = value)
        );
        const requestItems$ = subjects.requestItems.pipe(
          (0, import_rxjs15.tap)((items) => connectButtonElement.requestItems = items)
        );
        const showPopoverMenu$ = subjects.showPopoverMenu.pipe(
          (0, import_rxjs15.tap)((value) => {
            value ? connectButtonElement.setAttribute("showPopoverMenu", "true") : connectButtonElement.removeAttribute("showPopoverMenu");
          })
        );
        const accounts$ = subjects.accounts.pipe(
          (0, import_rxjs15.tap)((items) => connectButtonElement.accounts = items)
        );
        const personaData$ = subjects.personaData.pipe(
          (0, import_rxjs15.tap)((items) => connectButtonElement.personaData = items)
        );
        const personaLabel$ = subjects.personaLabel.pipe(
          (0, import_rxjs15.tap)((items) => connectButtonElement.personaLabel = items)
        );
        const dAppName$ = subjects.dAppName.pipe(
          (0, import_rxjs15.tap)((value) => connectButtonElement.dAppName = value)
        );
        const theme$ = subjects.theme.pipe(
          (0, import_rxjs15.tap)((value) => connectButtonElement.theme = value)
        );
        const connectButtonEvents$ = (0, import_rxjs15.merge)(
          onConnect$,
          status$,
          theme$,
          mode$,
          connected$,
          showPopoverMenu$,
          requestItems$,
          loggedInTimestamp$,
          isMobile$,
          activeTab$,
          isWalletLinked$,
          isExtensionAvailable$,
          onDisconnect$,
          onCancelRequestItem$,
          onIgnoreTransactionItem$,
          accounts$,
          personaData$,
          personaLabel$,
          onUpdateSharedAccounts$,
          onShowPopover$,
          dAppName$,
          onLinkClick$
        ).pipe((0, import_rxjs15.map)(() => false));
        return (0, import_rxjs15.merge)(connectButtonEvents$, onDestroy$).pipe(
          (0, import_rxjs15.filter)((shouldDestroy) => !!shouldDestroy),
          (0, import_rxjs15.first)(),
          (0, import_rxjs15.finalize)(() => {
            logger?.debug({ observable: `onConnectButtonRender$.finalize` });
          })
        );
      })
    ).subscribe()
  );
  subscriptions.add(
    (transport && transport.isAvailable$ || (0, import_rxjs15.of)(true)).pipe((0, import_rxjs15.tap)((value) => subjects.isExtensionAvailable.next(value))).subscribe()
  );
  subscriptions.add(
    (transport && transport.isLinked$ || (0, import_rxjs15.of)(true)).pipe((0, import_rxjs15.tap)((value) => subjects.isWalletLinked.next(value))).subscribe()
  );
  subscriptions.add(
    subjects.onLinkClick.pipe(
      (0, import_rxjs15.tap)(({ type, data }) => {
        if (["account", "transaction", "subintent"].includes(type)) {
          if (!baseUrl || !window) return;
          const url = `${baseUrl}${type === "transaction" ? transactionPath : type === "subintent" ? subintentPath : accountsPath}${data}`;
          window.open(url);
        } else if (type === "setupGuide")
          window.open("https://wallet.radixdlt.com");
        else if (type === "getWallet") {
          window.open("https://app.radixdlt.com/qr-code");
        } else if (type === "showQrCode" && transport?.showQrCode)
          transport.showQrCode();
      })
    ).subscribe()
  );
  const connectButtonApi = {
    status$: subjects.status.asObservable(),
    onConnect$: subjects.onConnect.asObservable(),
    onDisconnect$: subjects.onDisconnect.asObservable(),
    onShowPopover$: subjects.onShowPopover.asObservable(),
    onUpdateSharedAccounts$: subjects.onUpdateSharedAccounts.asObservable(),
    onCancelRequestItem$: subjects.onCancelRequestItem.asObservable(),
    onIgnoreTransactionItem$: subjects.onIgnoreTransactionItem.asObservable(),
    onLinkClick$: subjects.onLinkClick.asObservable(),
    setTheme: (value) => subjects.theme.next(value),
    setMode: (value) => subjects.mode.next(value),
    setActiveTab: (value) => subjects.activeTab.next(value),
    setIsMobile: (value) => subjects.isMobile.next(value),
    setIsWalletLinked: (value) => subjects.isWalletLinked.next(value),
    setIsExtensionAvailable: (value) => subjects.isExtensionAvailable.next(value),
    setLoggedInTimestamp: (value) => subjects.loggedInTimestamp.next(value),
    setConnected: (value) => subjects.connected.next(value),
    setShowPopoverMenu: (value) => subjects.showPopoverMenu.next(value),
    setRequestItems: (items) => subjects.requestItems.next(items),
    setAccounts: (accounts2) => subjects.accounts.next(accounts2),
    setPersonaData: (personaData2) => subjects.personaData.next(personaData2),
    setPersonaLabel: (personaLabel) => subjects.personaLabel.next(personaLabel),
    setDappName: (dAppName) => subjects.dAppName.next(dAppName),
    disconnect: () => {
      subjects.connected.next(false);
      subjects.status.next("default");
    },
    destroy: () => {
      subscriptions.unsubscribe();
    }
  };
  const setPropsFromState = () => stateModule.getState().map((state) => {
    const { personaData: personaData2, accounts: accounts2, personaLabel, connected } = transformWalletDataToConnectButton(state.walletData);
    connectButtonApi.setLoggedInTimestamp(state.loggedInTimestamp);
    connectButtonApi.setAccounts(accounts2);
    connectButtonApi.setPersonaData(personaData2);
    connectButtonApi.setPersonaLabel(personaLabel);
    connectButtonApi.setConnected(connected);
  });
  subscriptions.add(
    stateModule.storage$.pipe((0, import_rxjs15.switchMap)(() => setPropsFromState())).subscribe()
  );
  subscriptions.add(
    subjects.onCancelRequestItem.pipe(
      (0, import_rxjs15.tap)((value) => {
        walletRequestModule.cancelRequest(value);
      })
    ).subscribe()
  );
  subscriptions.add(
    subjects.onIgnoreTransactionItem.pipe(
      (0, import_rxjs15.tap)((value) => {
        walletRequestModule.ignoreTransaction(value);
      })
    ).subscribe()
  );
  subscriptions.add(
    walletRequestModule.requestItems$.pipe(
      (0, import_rxjs15.tap)((items) => {
        connectButtonApi.setRequestItems([...items].reverse());
      })
    ).subscribe()
  );
  subscriptions.add(
    subjects.onShowPopover.pipe(
      (0, import_rxjs15.tap)(() => {
        walletRequestModule.getPendingRequests().map((pendingRequests) => {
          if (pendingRequests.length > 0) {
            subjects.activeTab.next("requests");
          }
        });
      })
    ).subscribe()
  );
  subscriptions.add(
    subjects.onConnect.pipe(
      (0, import_rxjs15.switchMap)(
        () => stateModule.reset().andThen(
          () => walletRequestModule.sendRequest({
            isConnect: true,
            oneTime: false
          })
        ).map(
          () => input.providers.environmentModule.isMobile() && subjects.showPopoverMenu.next(false)
        )
      )
    ).subscribe()
  );
  subscriptions.add(
    subjects.onUpdateSharedAccounts.pipe((0, import_rxjs15.switchMap)(() => walletRequestModule.updateSharedAccounts())).subscribe()
  );
  subscriptions.add(
    subjects.onDisconnect.pipe(
      (0, import_rxjs15.tap)(() => {
        subjects.connected.next(false);
        subjects.status.next("default");
        walletRequestModule.disconnect();
        if (input.onDisconnect) input.onDisconnect();
      })
    ).subscribe()
  );
  const setPendingOrDefault = () => walletRequestModule.getPendingRequests().andTee(
    (items) => subjects.status.next(items.length ? "pending" : "default")
  );
  subscriptions.add(
    walletRequestModule.interactionStatusChange$.pipe(
      (0, import_rxjs15.mergeMap)(
        (newStatus) => (0, import_rxjs15.of)(
          subjects.status.next(
            newStatus === "success" ? "success" : newStatus === "fail" ? "error" : "pending"
          )
        ).pipe(
          (0, import_rxjs15.delay)(2e3),
          (0, import_rxjs15.concatMap)(() => setPendingOrDefault())
        )
      )
    ).subscribe()
  );
  setPendingOrDefault();
  if (dAppDefinitionAddress) {
    gatewayModule.gatewayApi.getEntityMetadataPage(dAppDefinitionAddress).map(
      (details) => details?.items.find((item) => item.key === "name")?.value?.typed?.value
    ).map((dAppName) => {
      subjects.dAppName.next(dAppName ?? "Unnamed dApp");
    });
  }
  return connectButtonApi;
};

// src/modules/connect-button/types.ts
var ConnectButtonStatus = {
  pending: "pending",
  success: "success",
  default: "default",
  error: "error"
};

// src/modules/environment/environment.module.ts
var EnvironmentModule = () => {
  const isMobile = (userAgent) => {
    const ua = userAgent.toLowerCase();
    return /(mobi|ipod|phone|blackberry|opera mini|fennec|minimo|symbian|psp|nintendo ds|archos|skyfire|puffin|blazer|bolt|gobrowser|iris|maemo|semc|teashark|uzard|ipad|tablet|(android(?!.*mobile))|(windows(?!.*phone)(.*touch))|kindle|playbook|silk|(puffin(?!.*(IP|AP|WP))))/.test(
      ua
    );
  };
  const getNavigator = () => {
    return typeof navigator !== "undefined" ? navigator : void 0;
  };
  const isTMA = () => Object.keys(globalThis?.Telegram?.WebView?.initParams || {}).length > 0;
  return {
    get globalThis() {
      return globalThis;
    },
    isMobile: (userAgent) => {
      return isMobile(userAgent ?? getNavigator()?.userAgent ?? "");
    },
    isTMA,
    isBrowser: () => ![typeof window, typeof document].includes("undefined")
  };
};

// src/modules/storage/local-storage.module.ts
var import_neverthrow30 = require("neverthrow");
var import_rxjs16 = require("rxjs");
var LocalStorageModule = (storageKey, {
  providers
}) => {
  const _window = providers.environmentModule.globalThis;
  const getDataAsync = () => new Promise((resolve, reject) => {
    try {
      resolve(localStorage.getItem(storageKey));
    } catch (error) {
      reject(error);
    }
  });
  const setDataAsync = (value) => new Promise((resolve, reject) => {
    try {
      localStorage.setItem(storageKey, value);
      resolve();
    } catch (error) {
      reject(error);
    }
  });
  const getItems = () => import_neverthrow30.ResultAsync.fromPromise(getDataAsync(), typedError2).andThen(
    (data) => data ? parseJSON(data) : (0, import_neverthrow30.ok)({})
  );
  const getState = () => import_neverthrow30.ResultAsync.fromPromise(getDataAsync(), typedError2).andThen(
    (data) => data ? parseJSON(data) : (0, import_neverthrow30.ok)(void 0)
  );
  const getItemById = (id) => import_neverthrow30.ResultAsync.fromPromise(getDataAsync(), typedError2).andThen((data) => data ? parseJSON(data) : (0, import_neverthrow30.ok)(void 0)).map((items) => items ? items[id] : void 0);
  const removeItemById = (id) => getItems().andThen((items) => {
    const { [id]: _2, ...newItems } = items;
    return stringify(newItems).asyncAndThen((serialized) => {
      const result = import_neverthrow30.ResultAsync.fromPromise(
        setDataAsync(serialized),
        typedError2
      ).map(() => {
        _window.dispatchEvent(
          new StorageEvent("storage", {
            key: storageKey,
            oldValue: JSON.stringify(items),
            newValue: serialized
          })
        );
      });
      return result;
    });
  });
  const patchItem = (id, patch) => getItemById(id).andThen((item) => {
    return item ? setItems({ [id]: { ...item, ...patch } }) : (0, import_neverthrow30.err)(new Error("Item not found"));
  });
  const setItems = (item) => getItems().andThen(
    (data) => stringify({ ...data, ...item }).asyncAndThen((serialized) => {
      const result = import_neverthrow30.ResultAsync.fromPromise(
        setDataAsync(serialized),
        typedError2
      ).map(() => {
        _window.dispatchEvent(
          new StorageEvent("storage", {
            key: storageKey,
            oldValue: JSON.stringify(data),
            newValue: serialized
          })
        );
      });
      return result;
    })
  );
  const getItemList = () => getItems().map(Object.values);
  const setState = (newValue) => getState().andThen(
    (oldValue) => stringify({ ...oldValue ?? {}, ...newValue }).asyncAndThen(
      (serialized) => {
        const result = import_neverthrow30.ResultAsync.fromPromise(
          setDataAsync(serialized),
          typedError2
        ).map(() => {
          _window.dispatchEvent(
            new StorageEvent("storage", {
              key: storageKey,
              oldValue: JSON.stringify(oldValue),
              newValue: serialized
            })
          );
        });
        return result;
      }
    )
  );
  const patchState = (newValue) => getState().mapErr(() => ({ reason: "FailedToReadFromLocalStorage" })).andThen(
    (oldState) => oldState ? setState({ ...oldState, ...newValue }).mapErr(() => ({
      reason: "FailedToWriteToLocalStorage"
    })) : (0, import_neverthrow30.err)({ reason: "PatchingStateFailed" })
  );
  const getPartition = (partitionKey) => LocalStorageModule(`${storageKey}:${partitionKey}`, { providers });
  const storage$ = (0, import_rxjs16.merge)(
    (0, import_rxjs16.fromEvent)(providers.environmentModule.globalThis, "storage"),
    (0, import_rxjs16.of)({ key: storageKey, newValue: null, oldValue: null })
  ).pipe(
    (0, import_rxjs16.filter)((item) => item.key === storageKey),
    (0, import_rxjs16.mergeMap)((event) => {
      const { key, newValue, oldValue } = event;
      if (!key) return [];
      const [rdt, accountDefinition, networkId, partition] = key.split(":");
      if (rdt === "rdt" && accountDefinition && networkId) {
        const oldValueResult = oldValue ? parseJSON(oldValue) : (0, import_neverthrow30.ok)(void 0);
        const newValueResult = newValue ? parseJSON(newValue) : (0, import_neverthrow30.ok)(void 0);
        return [
          import_neverthrow30.Result.combine([oldValueResult, newValueResult]).map(
            ([oldValue2, newValue2]) => ({
              key,
              partition,
              newValue: newValue2,
              oldValue: oldValue2
            })
          )
        ];
      }
      return [];
    }),
    (0, import_rxjs16.filter)((result) => result.isOk()),
    (0, import_rxjs16.map)(({ value }) => value)
  );
  const clear = () => import_neverthrow30.ResultAsync.fromPromise(
    new Promise((resolve) => resolve(localStorage.removeItem(storageKey))),
    typedError2
  );
  return {
    getItems,
    getItemById,
    removeItemById,
    patchItem,
    setItems,
    getItemList,
    getPartition,
    setState,
    getState,
    patchState,
    clear,
    storage$
  };
};

// src/radix-dapp-toolkit.ts
polyfills_default();
var RadixDappToolkit = (options) => {
  const dAppDefinitionAddress = options.dAppDefinitionAddress ?? options.applicationDappDefinitionAddress;
  const {
    networkId,
    providers,
    logger,
    onDisconnect,
    gatewayBaseUrl,
    applicationName,
    applicationVersion,
    useCache = true
  } = options || {};
  const environmentModule = providers?.environmentModule ?? EnvironmentModule();
  const storageModule = providers?.storageModule ?? LocalStorageModule(`rdt:${dAppDefinitionAddress}:${networkId}`, {
    providers: {
      environmentModule
    }
  });
  const stateModule = providers?.stateModule ?? StateModule({
    logger,
    providers: {
      storageModule: storageModule.getPartition("state")
    }
  });
  const gatewayModule = providers?.gatewayModule ?? GatewayModule({
    logger,
    clientConfig: generateGatewayApiConfig({
      networkId,
      dAppDefinitionAddress,
      gatewayBaseUrl,
      applicationName,
      applicationVersion
    })
  });
  const walletRequestModule = providers?.walletRequestModule ?? WalletRequestModule({
    logger,
    useCache,
    networkId,
    dAppDefinitionAddress,
    requestInterceptor: options.requestInterceptor,
    providers: {
      stateModule,
      storageModule,
      gatewayModule,
      environmentModule
    }
  });
  const connectButtonModule = providers?.connectButtonModule ?? ConnectButtonModule({
    logger,
    networkId,
    explorer: options.explorer,
    onDisconnect,
    dAppDefinitionAddress,
    providers: {
      stateModule,
      environmentModule,
      walletRequestModule,
      gatewayModule
    }
  });
  return {
    walletApi: {
      setRequestData: walletRequestModule.setRequestDataState,
      sendRequest: () => walletRequestModule.sendRequest({
        isConnect: false,
        oneTime: false
      }),
      provideChallengeGenerator: (fn) => walletRequestModule.provideChallengeGenerator(fn),
      dataRequestControl: (fn) => {
        walletRequestModule.provideDataRequestControl(fn);
      },
      provideConnectResponseCallback: walletRequestModule.provideConnectResponseCallback,
      updateSharedAccounts: () => walletRequestModule.updateSharedAccounts(),
      sendOneTimeRequest: walletRequestModule.sendOneTimeRequest,
      sendPreAuthorizationRequest: walletRequestModule.sendPreAuthorizationRequest,
      sendTransaction: (input) => walletRequestModule.sendTransaction(input),
      walletData$: stateModule.walletData$,
      getWalletData: stateModule.getWalletData
    },
    buttonApi: {
      setTheme: connectButtonModule.setTheme,
      setMode: connectButtonModule.setMode,
      status$: connectButtonModule.status$
    },
    gatewayApi: {
      clientConfig: gatewayModule.configuration
    },
    disconnect: () => {
      walletRequestModule.disconnect();
      connectButtonModule.disconnect();
      if (onDisconnect) onDisconnect();
    },
    destroy: () => {
      stateModule.destroy();
      walletRequestModule.destroy();
      connectButtonModule.destroy();
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Account,
  AccountProof,
  AccountsRequestItem,
  AccountsRequestResponseItem,
  AnswerIO,
  AuthLoginRequestItem,
  AuthLoginRequestResponseItem,
  AuthLoginWithChallengeRequestItem,
  AuthLoginWithChallengeRequestResponseItem,
  AuthLoginWithoutChallengeRequestItem,
  AuthLoginWithoutChallengeRequestResponseItem,
  AuthRequestItem,
  AuthRequestResponseItem,
  AuthUsePersonaRequestItem,
  CancelRequest,
  CancelWalletInteractionExtensionInteraction,
  ConnectButtonModule,
  ConnectButtonStatus,
  ConnectButtonSubjects,
  ConnectorExtensionModule,
  ConnectorExtensionSubjects,
  Curve25519,
  DataRequestBuilder,
  DataRequestStateModule,
  DeepLinkModule,
  EnvironmentModule,
  ExpireAfterDelay,
  ExpireAtTime,
  ExponentialBackoff,
  ExtensionInteraction,
  GatewayApiService,
  GatewayModule,
  IceCandidateIO,
  IceCandidatePayloadIO,
  IceCandidatesIO,
  IdentityKind,
  IdentityModule,
  LocalStorageModule,
  Logger,
  LoginRequestResponseItem,
  MessageLifeCycleEvent,
  MessageLifeCycleExtensionStatusEvent,
  Metadata,
  NumberOfValues,
  OfferIO,
  OneTimeDataRequestBuilder,
  OpenPopupExtensionInteraction,
  Persona,
  PersonaDataName,
  PersonaDataNameVariant,
  PersonaDataRequestItem,
  PersonaDataRequestResponseItem,
  PersonaProof,
  Proof,
  ProofOfOwnershipRequestItem,
  ProofOfOwnershipResponseItem,
  RadixConnectRelayModule,
  RadixDappToolkit,
  RadixNetwork,
  RadixNetworkConfig,
  RadixNetworkConfigById,
  RdtState,
  RequestItemModule,
  ResetRequestItem,
  SendTransactionItem,
  SendTransactionResponseItem,
  SessionModule,
  SharedData,
  SignalingServerMessage,
  SignedChallenge,
  SignedChallengeAccount,
  SignedChallengePersona,
  Sources,
  StateModule,
  StatusExtensionInteraction,
  SubintentRequestBuilder,
  SubintentRequestItem,
  SubintentResponseItem,
  TransactionStatus,
  TransformRdtDataRequestToWalletRequestInput,
  WalletAuthorizedRequestItems,
  WalletAuthorizedRequestResponseItems,
  WalletData,
  WalletDataPersonaData,
  WalletDataPersonaDataEmailAddresses,
  WalletDataPersonaDataFullName,
  WalletDataPersonaDataPhoneNumbersAddresses,
  WalletInteraction,
  WalletInteractionExtensionInteraction,
  WalletInteractionFailureResponse,
  WalletInteractionItems,
  WalletInteractionResponse,
  WalletInteractionSuccessResponse,
  WalletPreAuthorizationItems,
  WalletPreAuthorizationResponseItems,
  WalletRequestItems,
  WalletRequestModule,
  WalletRequestResponseItems,
  WalletRequestSdk,
  WalletTransactionItems,
  WalletUnauthorizedRequestItems,
  blake2b,
  canDataRequestBeResolvedByRdtState,
  config,
  eventType,
  extensionInteractionDiscriminator,
  fetchWrapper,
  generateGatewayApiConfig,
  generateRolaChallenge,
  messageLifeCycleEventType,
  parseJSON,
  parseSignedChallenge,
  personaDataFullNameVariant,
  proofType,
  removeUndefined,
  stringify,
  toWalletRequest,
  transformRdtDataRequestToWalletRequest,
  transformSharedDataToDataRequestState,
  transformWalletDataToConnectButton,
  transformWalletRequestToSharedData,
  transformWalletResponseToRdtWalletData,
  typedError,
  unwrapObservable,
  validateRolaChallenge,
  validateWalletResponse,
  walletDataDefault
});
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
