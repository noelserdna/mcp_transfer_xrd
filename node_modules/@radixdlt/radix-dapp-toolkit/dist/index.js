// src/polyfills.ts
import { Buffer as Buffer2 } from "buffer";
var polyfills_default = () => {
  if (!globalThis.Buffer) globalThis.Buffer = Buffer2;
};

// src/modules/connect-button/connect-button.module.ts
import {
  concatMap,
  delay,
  filter as filter7,
  finalize,
  first as first3,
  fromEvent,
  map as map6,
  merge as merge3,
  mergeMap as mergeMap2,
  of as of3,
  Subscription as Subscription7,
  switchMap as switchMap6,
  tap as tap4
} from "rxjs";

// src/modules/connect-button/subjects.ts
import { BehaviorSubject, ReplaySubject, Subject } from "rxjs";
var ConnectButtonSubjects = (input) => ({
  onConnect: new Subject(),
  onDisconnect: new Subject(),
  onUpdateSharedAccounts: new Subject(),
  connected: new ReplaySubject(1),
  requestItems: new BehaviorSubject([]),
  onCancelRequestItem: new Subject(),
  onIgnoreTransactionItem: new Subject(),
  accounts: new BehaviorSubject([]),
  onShowPopover: new Subject(),
  status: new BehaviorSubject("default"),
  loggedInTimestamp: new BehaviorSubject(""),
  isMobile: new BehaviorSubject(input.providers.environmentModule.isMobile()),
  isWalletLinked: new BehaviorSubject(false),
  showPopoverMenu: new BehaviorSubject(false),
  isExtensionAvailable: new BehaviorSubject(false),
  fullWidth: new BehaviorSubject(false),
  activeTab: new BehaviorSubject("sharing"),
  mode: new BehaviorSubject("light"),
  theme: new BehaviorSubject("radix-blue"),
  avatarUrl: new BehaviorSubject(""),
  personaLabel: new BehaviorSubject(""),
  personaData: new BehaviorSubject([]),
  dAppName: new BehaviorSubject(""),
  onLinkClick: new Subject()
});

// src/modules/wallet-request/crypto/curve25519.ts
import { x25519, ed25519 } from "@noble/curves/ed25519";
import { Buffer as Buffer3 } from "buffer";
import { err, ok } from "neverthrow";

// ../../node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`positive integer expected, not ${n}`);
}
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function hash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(h.outputLen);
  number(h.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// ../../node_modules/@noble/hashes/esm/utils.js
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  bytes(data);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}

// ../../node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// ../../node_modules/@noble/hashes/esm/hkdf.js
function extract(hash2, ikm, salt) {
  hash(hash2);
  if (salt === void 0)
    salt = new Uint8Array(hash2.outputLen);
  return hmac(hash2, toBytes(salt), toBytes(ikm));
}
var HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);
var EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();
function expand(hash2, prk, info, length = 32) {
  hash(hash2);
  number(length);
  if (length > 255 * hash2.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length / hash2.outputLen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  const okm = new Uint8Array(blocks * hash2.outputLen);
  const HMAC2 = hmac.create(hash2, prk);
  const HMACTmp = HMAC2._cloneInto();
  const T = new Uint8Array(HMAC2.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, hash2.outputLen * counter);
    HMAC2._cloneInto(HMACTmp);
  }
  HMAC2.destroy();
  HMACTmp.destroy();
  T.fill(0);
  HKDF_COUNTER.fill(0);
  return okm.slice(0, length);
}
var hkdf = (hash2, ikm, salt, info, length) => expand(hash2, extract(hash2, ikm, salt), info, length);

// ../../node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// ../../node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

// src/modules/wallet-request/crypto/curve25519.ts
var toHex = (input) => Buffer3.from(input).toString("hex");
var Curve25519 = (privateKeyHex = toHex(x25519.utils.randomPrivateKey())) => {
  const getPrivateKey = () => privateKeyHex;
  const x25519Api = {
    getPublicKey: () => toHex(x25519.getPublicKey(privateKeyHex)),
    calculateSharedSecret: (publicKeyHex, dAppDefinitionAddress) => {
      try {
        const sharedSecret = x25519.getSharedSecret(privateKeyHex, publicKeyHex);
        const derived = hkdf(
          sha256,
          sharedSecret,
          Buffer3.from(dAppDefinitionAddress, "utf-8"),
          "RCfM",
          32
        );
        return ok(toHex(derived));
      } catch (error) {
        return err(error);
      }
    }
  };
  const ed25519Api = {
    getPublicKey: () => toHex(ed25519.getPublicKey(privateKeyHex)),
    sign: (messageHex) => {
      try {
        return ok(toHex(ed25519.sign(messageHex, privateKeyHex)));
      } catch (error) {
        return err(error);
      }
    }
  };
  return {
    getPrivateKey,
    x25519: x25519Api,
    ed25519: ed25519Api
  };
};

// src/modules/wallet-request/crypto/blake2b.ts
import { err as err2, ok as ok2 } from "neverthrow";
import blake from "blakejs";
import { Buffer as Buffer4 } from "buffer";
var bufferToArrayBuffer = (buffer) => {
  const arrayBuffer = new ArrayBuffer(buffer.length);
  const view = new Uint8Array(arrayBuffer);
  for (let i = 0; i < buffer.length; ++i) {
    view[i] = buffer[i];
  }
  return arrayBuffer;
};
var bufferToUnit8Array = (buffer) => new Uint8Array(bufferToArrayBuffer(buffer));
var blake2b = (input) => {
  try {
    return ok2(blake.blake2bHex(bufferToUnit8Array(input), void 0, 32)).map(
      (hex) => Buffer4.from(hex, "hex")
    );
  } catch (error) {
    return err2(error);
  }
};

// src/modules/wallet-request/data-request/builders/accounts.ts
import { produce } from "immer";
import { boolean as boolean2, object as object2, optional as optional2 } from "valibot";

// src/schemas/index.ts
import {
  array,
  boolean,
  literal,
  number as number2,
  object,
  optional,
  minValue,
  string,
  union,
  check,
  pipe
} from "valibot";
var Account = object({
  address: string(),
  label: string(),
  appearanceId: number2()
});
var Proof = object({
  publicKey: string(),
  signature: string(),
  curve: union([literal("curve25519"), literal("secp256k1")])
});
var AccountProof = object({
  accountAddress: string(),
  proof: Proof
});
var PersonaProof = object({
  identityAddress: string(),
  proof: Proof
});
var ProofOfOwnershipRequestItem = object({
  challenge: string(),
  identityAddress: optional(string()),
  accountAddresses: optional(array(string()))
});
var ProofOfOwnershipResponseItem = object({
  challenge: string(),
  proofs: array(union([AccountProof, PersonaProof]))
});
var Persona = object({ identityAddress: string(), label: string() });
var personaDataFullNameVariant = {
  western: "western",
  eastern: "eastern"
};
var PersonaDataNameVariant = union([
  literal(personaDataFullNameVariant.eastern),
  literal(personaDataFullNameVariant.western)
]);
var PersonaDataName = object({
  variant: PersonaDataNameVariant,
  familyName: string(),
  nickname: string(),
  givenNames: string()
});
var NumberOfValues = object({
  quantifier: union([literal("exactly"), literal("atLeast")]),
  quantity: pipe(number2(), minValue(0, "The number must be at least 0."))
});
var AccountsRequestItem = object({
  challenge: optional(string()),
  numberOfAccounts: NumberOfValues
});
var AccountsRequestResponseItem = pipe(
  object({
    accounts: array(Account),
    challenge: optional(string()),
    proofs: optional(array(AccountProof))
  }),
  check((data) => {
    if (data.challenge || data?.proofs) {
      return !!(data.challenge && data?.proofs?.length);
    }
    return true;
  }, "missing challenge or proofs")
);
var PersonaDataRequestItem = object({
  isRequestingName: optional(boolean()),
  numberOfRequestedEmailAddresses: optional(NumberOfValues),
  numberOfRequestedPhoneNumbers: optional(NumberOfValues)
});
var PersonaDataRequestResponseItem = object({
  name: optional(PersonaDataName),
  emailAddresses: optional(array(string())),
  phoneNumbers: optional(array(string()))
});
var ResetRequestItem = object({
  accounts: boolean(),
  personaData: boolean()
});
var LoginRequestResponseItem = pipe(
  object({
    persona: Persona,
    challenge: optional(string()),
    proof: optional(Proof)
  }),
  check((data) => {
    if (data.challenge || data.proof) {
      return !!(data.challenge && data.proof);
    }
    return true;
  }, "missing challenge or proof")
);
var WalletUnauthorizedRequestItems = object({
  discriminator: literal("unauthorizedRequest"),
  oneTimeAccounts: optional(AccountsRequestItem),
  oneTimePersonaData: optional(PersonaDataRequestItem)
});
var AuthUsePersonaRequestItem = object({
  discriminator: literal("usePersona"),
  identityAddress: string()
});
var AuthLoginWithoutChallengeRequestItem = object({
  discriminator: literal("loginWithoutChallenge")
});
var AuthLoginWithChallengeRequestItem = object({
  discriminator: literal("loginWithChallenge"),
  challenge: string()
});
var AuthLoginRequestItem = union([
  AuthLoginWithoutChallengeRequestItem,
  AuthLoginWithChallengeRequestItem
]);
var AuthRequestItem = union([
  AuthUsePersonaRequestItem,
  AuthLoginRequestItem
]);
var WalletAuthorizedRequestItems = object({
  discriminator: literal("authorizedRequest"),
  auth: AuthRequestItem,
  reset: optional(ResetRequestItem),
  proofOfOwnership: optional(ProofOfOwnershipRequestItem),
  oneTimeAccounts: optional(AccountsRequestItem),
  ongoingAccounts: optional(AccountsRequestItem),
  oneTimePersonaData: optional(PersonaDataRequestItem),
  ongoingPersonaData: optional(PersonaDataRequestItem)
});
var WalletRequestItems = union([
  WalletUnauthorizedRequestItems,
  WalletAuthorizedRequestItems
]);
var SendTransactionItem = object({
  transactionManifest: string(),
  version: number2(),
  blobs: optional(array(string())),
  message: optional(string())
});
var WalletTransactionItems = object({
  discriminator: literal("transaction"),
  send: SendTransactionItem
});
var SendTransactionResponseItem = object({
  transactionIntentHash: string()
});
var WalletTransactionResponseItems = object({
  discriminator: literal("transaction"),
  send: SendTransactionResponseItem
});
var CancelRequest = object({
  discriminator: literal("cancelRequest")
});
var ExpireAtTime = object({
  discriminator: literal("expireAtTime"),
  unixTimestampSeconds: number2()
});
var ExpireAfterDelay = object({
  discriminator: literal("expireAfterDelay"),
  expireAfterSeconds: number2()
});
var SubintentRequestItem = object({
  discriminator: literal("subintent"),
  /**
   * Version of the message interface
   */
  version: number2(),
  /**
   * Version of the Transaction Manifest
   */
  manifestVersion: number2(),
  subintentManifest: string(),
  blobs: optional(array(string())),
  message: optional(string()),
  expiration: union([ExpireAtTime, ExpireAfterDelay])
});
var SubintentResponseItem = object({
  expirationTimestamp: number2(),
  subintentHash: string(),
  signedPartialTransaction: string()
});
var WalletPreAuthorizationItems = object({
  discriminator: literal("preAuthorizationRequest"),
  request: optional(SubintentRequestItem)
});
var WalletInteractionItems = union([
  WalletRequestItems,
  WalletTransactionItems,
  CancelRequest,
  WalletPreAuthorizationItems
]);
var Metadata = object({
  version: literal(2),
  networkId: number2(),
  dAppDefinitionAddress: string(),
  origin: string()
});
var WalletInteraction = object({
  interactionId: string(),
  metadata: Metadata,
  items: WalletInteractionItems
});
var WalletUnauthorizedRequestResponseItems = object({
  discriminator: literal("unauthorizedRequest"),
  oneTimeAccounts: optional(AccountsRequestResponseItem),
  oneTimePersonaData: optional(PersonaDataRequestResponseItem)
});
var AuthLoginWithoutChallengeRequestResponseItem = object({
  discriminator: literal("loginWithoutChallenge"),
  persona: Persona
});
var AuthLoginWithChallengeRequestResponseItem = object({
  discriminator: literal("loginWithChallenge"),
  persona: Persona,
  challenge: string(),
  proof: Proof
});
var WalletPreAuthorizationResponseItems = object({
  discriminator: literal("preAuthorizationResponse"),
  response: optional(SubintentResponseItem)
});
var AuthLoginRequestResponseItem = union([
  AuthLoginWithoutChallengeRequestResponseItem,
  AuthLoginWithChallengeRequestResponseItem
]);
var AuthUsePersonaRequestResponseItem = object({
  discriminator: literal("usePersona"),
  persona: Persona
});
var AuthRequestResponseItem = union([
  AuthUsePersonaRequestResponseItem,
  AuthLoginRequestResponseItem
]);
var WalletAuthorizedRequestResponseItems = object({
  discriminator: literal("authorizedRequest"),
  auth: AuthRequestResponseItem,
  proofOfOwnership: optional(ProofOfOwnershipResponseItem),
  oneTimeAccounts: optional(AccountsRequestResponseItem),
  ongoingAccounts: optional(AccountsRequestResponseItem),
  oneTimePersonaData: optional(PersonaDataRequestResponseItem),
  ongoingPersonaData: optional(PersonaDataRequestResponseItem)
});
var WalletRequestResponseItems = union([
  WalletUnauthorizedRequestResponseItems,
  WalletAuthorizedRequestResponseItems
]);
var WalletInteractionResponseItems = union([
  WalletRequestResponseItems,
  WalletTransactionResponseItems,
  WalletPreAuthorizationResponseItems
]);
var WalletInteractionSuccessResponse = object({
  discriminator: literal("success"),
  interactionId: string(),
  items: WalletInteractionResponseItems
});
var WalletInteractionFailureResponse = object({
  discriminator: literal("failure"),
  interactionId: string(),
  error: string(),
  message: optional(string())
});
var WalletInteractionResponse = union([
  WalletInteractionSuccessResponse,
  WalletInteractionFailureResponse
]);
var extensionInteractionDiscriminator = {
  extensionStatus: "extensionStatus",
  openPopup: "openPopup",
  cancelWalletInteraction: "cancelWalletInteraction",
  walletInteraction: "walletInteraction"
};
var StatusExtensionInteraction = object({
  interactionId: string(),
  discriminator: literal(extensionInteractionDiscriminator.extensionStatus)
});
var OpenPopupExtensionInteraction = object({
  interactionId: string(),
  discriminator: literal(extensionInteractionDiscriminator.openPopup)
});
var WalletInteractionExtensionInteraction = object({
  interactionId: string(),
  discriminator: literal(extensionInteractionDiscriminator.walletInteraction),
  interaction: WalletInteraction,
  sessionId: optional(string())
});
var CancelWalletInteractionExtensionInteraction = object({
  interactionId: string(),
  discriminator: literal(
    extensionInteractionDiscriminator.cancelWalletInteraction
  ),
  metadata: Metadata
});
var ExtensionInteraction = union([
  StatusExtensionInteraction,
  OpenPopupExtensionInteraction,
  WalletInteractionExtensionInteraction,
  CancelWalletInteractionExtensionInteraction
]);
var messageLifeCycleEventType = {
  extensionStatus: "extensionStatus",
  receivedByExtension: "receivedByExtension",
  receivedByWallet: "receivedByWallet",
  requestCancelSuccess: "requestCancelSuccess",
  requestCancelFail: "requestCancelFail"
};
var MessageLifeCycleExtensionStatusEvent = object({
  eventType: literal(messageLifeCycleEventType.extensionStatus),
  interactionId: string(),
  isWalletLinked: boolean(),
  isExtensionAvailable: boolean(),
  canHandleSessions: optional(boolean())
});
var MessageLifeCycleEvent = object({
  eventType: union([
    literal(messageLifeCycleEventType.extensionStatus),
    literal(messageLifeCycleEventType.receivedByExtension),
    literal(messageLifeCycleEventType.receivedByWallet),
    literal(messageLifeCycleEventType.requestCancelSuccess),
    literal(messageLifeCycleEventType.requestCancelFail)
  ]),
  interactionId: string()
});
var IncomingMessage = union([
  MessageLifeCycleEvent,
  WalletInteractionResponse
]);
var eventType = {
  outgoingMessage: "radix#chromeExtension#send",
  incomingMessage: "radix#chromeExtension#receive"
};
var Offer = literal("offer");
var Answer = literal("answer");
var IceCandidate = literal("iceCandidate");
var IceCandidates = literal("iceCandidates");
var Types = union([Offer, Answer, IceCandidate, IceCandidates]);
var Sources = union([literal("wallet"), literal("extension")]);
var SignalingServerMessage = object({
  requestId: string(),
  targetClientId: string(),
  encryptedPayload: string(),
  source: optional(Sources),
  // redundant, to be removed
  connectionId: optional(string())
  // redundant, to be removed
});
var AnswerIO = object({
  ...SignalingServerMessage.entries,
  method: Answer,
  payload: object({
    sdp: string()
  })
});
var OfferIO = object({
  ...SignalingServerMessage.entries,
  method: Offer,
  payload: object({
    sdp: string()
  })
});
var IceCandidatePayloadIO = object({
  candidate: string(),
  sdpMid: string(),
  sdpMLineIndex: number2()
});
var IceCandidateIO = object({
  ...SignalingServerMessage.entries,
  method: IceCandidate,
  payload: IceCandidatePayloadIO
});
var IceCandidatesIO = object({
  ...SignalingServerMessage.entries,
  method: IceCandidates,
  payload: array(IceCandidatePayloadIO)
});

// src/modules/wallet-request/data-request/builders/accounts.ts
var AccountsDataRequestSchema = object2({
  numberOfAccounts: NumberOfValues,
  withProof: optional2(boolean2()),
  reset: optional2(boolean2())
});
var accounts = () => {
  const defaultValue = {
    numberOfAccounts: { quantifier: "atLeast", quantity: 1 }
  };
  let data = produce(defaultValue, () => {
  });
  const atLeast = (n) => {
    data = produce(data, (draft) => {
      draft.numberOfAccounts.quantifier = "atLeast";
      draft.numberOfAccounts.quantity = n;
    });
    return methods;
  };
  const exactly = (n) => {
    data = produce(data, (draft) => {
      draft.numberOfAccounts.quantifier = "exactly";
      draft.numberOfAccounts.quantity = n;
    });
    return methods;
  };
  const reset = (value = true) => {
    data = produce(data, (draft) => {
      draft.reset = value;
    });
    return methods;
  };
  const withProof = (value = true) => {
    data = produce(data, (draft) => {
      draft.withProof = value;
    });
    return methods;
  };
  const _toObject = () => ({
    accounts: data
  });
  const methods = {
    atLeast,
    exactly,
    withProof,
    reset,
    _toObject
  };
  return methods;
};

// src/modules/wallet-request/data-request/builders/persona.ts
import { produce as produce2 } from "immer";
import { boolean as boolean3, object as object3, optional as optional3 } from "valibot";
var schema = object3({
  withProof: optional3(boolean3())
});
var persona = (initialData = {
  withProof: false
}) => {
  let data = produce2(initialData, () => {
  });
  const withProof = (value = true) => {
    data = produce2(data, (draft) => {
      draft.withProof = value;
    });
    return methods;
  };
  const _toObject = () => ({
    persona: data
  });
  const methods = {
    withProof,
    _toObject
  };
  return methods;
};

// src/modules/wallet-request/data-request/builders/persona-data.ts
import { produce as produce3 } from "immer";
import { boolean as boolean4, object as object4, partial } from "valibot";
var PersonaDataRequestSchema = partial(
  object4({
    fullName: boolean4(),
    emailAddresses: NumberOfValues,
    phoneNumbers: NumberOfValues,
    reset: boolean4()
  })
);
var personaData = (initialData = {}) => {
  let data = produce3(initialData, () => {
  });
  const fullName = (value = true) => {
    data = produce3(data, (draft) => {
      draft.fullName = value;
    });
    return methods;
  };
  const createNumberOfValuesOptions = (key) => ({
    atLeast: (n) => {
      data = produce3(data, (draft) => {
        draft[key] = { quantifier: "atLeast", quantity: n };
      });
      return methods;
    },
    exactly: (n) => {
      data = produce3(data, (draft) => {
        draft[key] = { quantifier: "exactly", quantity: n };
      });
      return methods;
    }
  });
  const emailAddresses = (value = true) => {
    const options = createNumberOfValuesOptions("emailAddresses");
    options.exactly(value ? 1 : 0);
    return methods;
  };
  const phoneNumbers = (value = true) => {
    const options = createNumberOfValuesOptions("phoneNumbers");
    options.exactly(value ? 1 : 0);
    return methods;
  };
  const reset = (value = true) => {
    data = produce3(data, (draft) => {
      draft.reset = value;
    });
    return methods;
  };
  const _toObject = () => ({
    personaData: data
  });
  const methods = {
    fullName,
    emailAddresses,
    phoneNumbers,
    reset,
    _toObject
  };
  return methods;
};

// src/modules/wallet-request/data-request/builders/proof-of-ownership.ts
import { produce as produce4 } from "immer";
import { object as object5, string as string2, array as array2, optional as optional4 } from "valibot";
var schema2 = object5({
  accountAddresses: optional4(array2(string2())),
  identityAddress: optional4(string2())
});
var proofOfOwnership = (initialData = {}) => {
  let data = produce4(initialData, () => {
  });
  const accounts2 = (value) => {
    data = produce4(data, (draft) => {
      draft.accountAddresses = value;
    });
    return methods;
  };
  const identity = (value) => {
    data = produce4(data, (draft) => {
      draft.identityAddress = value;
    });
    return methods;
  };
  const _toObject = () => ({
    proofOfOwnership: data
  });
  const methods = {
    accounts: accounts2,
    identity,
    _toObject
  };
  return methods;
};

// src/modules/wallet-request/data-request/builders/index.ts
var config = (data) => {
  const _toObject = () => ({ ...data });
  const methods = {
    _toObject
  };
  return methods;
};
var DataRequestBuilder = {
  accounts,
  personaData,
  persona,
  config
};
var OneTimeDataRequestBuilder = {
  accounts,
  personaData,
  proofOfOwnership
};

// src/helpers/is-deep-equal.ts
var isDeepEqual = (a, b) => {
  const values = [null, void 0, false, true];
  if (values.includes(a) || values.includes(b) || typeof a === "number" || typeof b === "number") {
    return Object.is(a, b);
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) return false;
  for (const key of aKeys) {
    const value1 = a[key];
    const value2 = b[key];
    const isObjects = isObject(value1) && isObject(value2);
    if (isObjects && !isDeepEqual(value1, value2) || !isObjects && value1 !== value2) {
      return false;
    }
  }
  return true;
};
var isObject = (x) => {
  return x != null && typeof x === "object";
};

// src/modules/wallet-request/data-request/helpers/can-data-request-be-resolved-by-rdt-state.ts
var canDataRequestBeResolvedByRdtState = (dataRequest, state) => {
  if (dataRequest.discriminator === "authorizedRequest") {
    const isReset = dataRequest.reset?.accounts || dataRequest.reset?.personaData;
    const isOneTimeRequest = !!(dataRequest.oneTimeAccounts || dataRequest.oneTimePersonaData);
    const isChallengeRequest = dataRequest.auth.discriminator === "loginWithChallenge" || !!dataRequest.oneTimeAccounts?.challenge || !!dataRequest.ongoingAccounts?.challenge;
    if (isReset || isOneTimeRequest || isChallengeRequest) return false;
    let rdtStateSatisfiesRequest = false;
    if (dataRequest.ongoingAccounts) {
      const { quantifier, quantity } = dataRequest.ongoingAccounts.numberOfAccounts;
      rdtStateSatisfiesRequest = state.sharedData?.ongoingAccounts?.numberOfAccounts?.quantifier === quantifier && state.sharedData?.ongoingAccounts?.numberOfAccounts?.quantity === quantity;
    }
    if (dataRequest.ongoingPersonaData) {
      rdtStateSatisfiesRequest = isDeepEqual(
        dataRequest.ongoingPersonaData,
        state.sharedData?.ongoingPersonaData
      );
    }
    return rdtStateSatisfiesRequest;
  }
  return false;
};

// src/modules/wallet-request/data-request/helpers/to-wallet-request.ts
import { produce as produce6 } from "immer";

// src/modules/wallet-request/data-request/transformations/rdt-to-wallet.ts
import { produce as produce5 } from "immer";
import { ok as ok3 } from "neverthrow";
import { boolean as boolean5, object as object6, string as string3, optional as optional5, array as array3 } from "valibot";
var TransformRdtDataRequestToWalletRequestInput = object6({
  proofOfOwnership: optional5(
    object6({
      challenge: optional5(string3()),
      accountAddresses: optional5(array3(string3())),
      identityAddress: optional5(string3())
    })
  ),
  accounts: optional5(
    object6({
      numberOfAccounts: NumberOfValues,
      reset: boolean5(),
      oneTime: boolean5(),
      challenge: optional5(string3())
    })
  ),
  personaData: optional5(
    object6({
      fullName: optional5(boolean5()),
      phoneNumbers: optional5(NumberOfValues),
      emailAddresses: optional5(NumberOfValues),
      reset: boolean5(),
      oneTime: optional5(boolean5())
    })
  ),
  persona: optional5(
    object6({
      identityAddress: optional5(string3()),
      label: optional5(string3()),
      challenge: optional5(string3())
    })
  )
});
var isAuthorized = (input) => {
  const { persona: persona2, accounts: accounts2, personaData: personaData2, proofOfOwnership: proofOfOwnership2 } = input;
  const isPersonaLogin = !!persona2;
  const shouldResetData = accounts2?.reset || personaData2?.reset;
  const isOngoingAccountsRequest = accounts2 && !accounts2?.oneTime;
  const isOngoingPersonaDataRequest = personaData2 && !personaData2?.oneTime;
  const isAuthorizedRequest = !!(shouldResetData || isOngoingAccountsRequest || isOngoingPersonaDataRequest || isPersonaLogin || proofOfOwnership2);
  return isAuthorizedRequest;
};
var createLoginRequestItem = (input) => {
  if (input.persona?.challenge) {
    return {
      discriminator: "loginWithChallenge",
      challenge: input.persona.challenge
    };
  }
  if (input.persona?.identityAddress) {
    return {
      discriminator: "usePersona",
      identityAddress: input.persona?.identityAddress
    };
  }
  return {
    discriminator: "loginWithoutChallenge"
  };
};
var withAccountRequestItem = (input) => (requestItems) => {
  const updatedRequestItems = { ...requestItems };
  const { accounts: accounts2 } = input;
  if (accounts2) {
    const data = {
      challenge: accounts2.challenge,
      numberOfAccounts: accounts2.numberOfAccounts
    };
    const isOngoingRequest = updatedRequestItems.discriminator === "authorizedRequest" && !input.accounts?.oneTime;
    const isConnectOngoingRequest = updatedRequestItems.discriminator === "authorizedRequest";
    if (input.accounts?.oneTime) {
      updatedRequestItems["oneTimeAccounts"] = data;
    } else if (isOngoingRequest || isConnectOngoingRequest) {
      updatedRequestItems["ongoingAccounts"] = data;
    }
  }
  return updatedRequestItems;
};
var withProofOfOwnershipRequestItem = (input) => (requestItems) => {
  const updatedRequestItems = { ...requestItems };
  if (input.proofOfOwnership) {
    const { challenge, accountAddresses, identityAddress } = input.proofOfOwnership;
    if (challenge && updatedRequestItems.discriminator === "authorizedRequest") {
      updatedRequestItems["proofOfOwnership"] = {
        challenge
      };
      if (accountAddresses) {
        updatedRequestItems["proofOfOwnership"].accountAddresses = accountAddresses;
      }
      if (identityAddress) {
        updatedRequestItems["proofOfOwnership"].identityAddress = identityAddress;
      }
    }
  }
  return updatedRequestItems;
};
var withPersonaDataRequestItem = (input) => (requestItems) => {
  const updatedRequestItems = { ...requestItems };
  if (input.personaData) {
    const {
      fullName: isRequestingName,
      phoneNumbers: numberOfRequestedPhoneNumbers,
      emailAddresses: numberOfRequestedEmailAddresses
    } = input.personaData;
    if (input.personaData?.oneTime) {
      updatedRequestItems["oneTimePersonaData"] = {
        isRequestingName,
        numberOfRequestedPhoneNumbers,
        numberOfRequestedEmailAddresses
      };
    }
    const isOngoingRequest = updatedRequestItems.discriminator === "authorizedRequest" && !input.personaData?.oneTime;
    const isConnectOngoingRequest = updatedRequestItems.discriminator === "authorizedRequest";
    if (isOngoingRequest || isConnectOngoingRequest) {
      updatedRequestItems["ongoingPersonaData"] = {
        isRequestingName,
        numberOfRequestedPhoneNumbers,
        numberOfRequestedEmailAddresses
      };
    }
  }
  return updatedRequestItems;
};
var withResetRequestItem = (input) => (requestItems) => {
  const { accounts: accounts2, personaData: personaData2 } = input;
  return {
    ...requestItems,
    reset: { accounts: !!accounts2?.reset, personaData: !!personaData2?.reset }
  };
};
var createUnauthorizedRequestItems = (input) => ok3({
  discriminator: "unauthorizedRequest"
}).map(withAccountRequestItem(input)).map(withPersonaDataRequestItem(input)).map(withProofOfOwnershipRequestItem(input));
var createAuthorizedRequestItems = (input) => ok3({
  discriminator: "authorizedRequest",
  auth: createLoginRequestItem(input)
}).map(withAccountRequestItem(input)).map(withPersonaDataRequestItem(input)).map(withResetRequestItem(input)).map(withProofOfOwnershipRequestItem(input));
var transformConnectRequest = (isConnect, input) => ok3(
  isConnect ? produce5(input, (draft) => {
    if (draft.accounts) {
      draft.accounts.oneTime = false;
      draft.accounts.reset = false;
    }
    if (draft.personaData) {
      draft.personaData.oneTime = false;
      draft.personaData.reset = false;
    }
  }) : input
);
var transformRdtDataRequestToWalletRequest = (isConnect, input) => transformConnectRequest(isConnect, input).andThen(
  (transformed) => isAuthorized(transformed) ? createAuthorizedRequestItems(transformed) : createUnauthorizedRequestItems(transformed)
);

// src/modules/wallet-request/data-request/helpers/to-wallet-request.ts
var toWalletRequest = ({
  dataRequestState,
  isConnect,
  challenge,
  oneTime,
  walletData
}) => transformRdtDataRequestToWalletRequest(
  isConnect,
  produce6({}, (draft) => {
    if (dataRequestState.proofOfOwnership) {
      draft.proofOfOwnership = {
        ...dataRequestState.proofOfOwnership,
        challenge
      };
    }
    if (dataRequestState.accounts) {
      draft.accounts = {
        numberOfAccounts: dataRequestState.accounts.numberOfAccounts || {
          quantifier: "atLeast",
          quantity: 1
        },
        oneTime,
        reset: !!dataRequestState.accounts.reset,
        challenge: dataRequestState.accounts.withProof ? challenge : void 0
      };
    }
    if (dataRequestState.personaData)
      draft.personaData = {
        ...dataRequestState.personaData,
        reset: !!dataRequestState.personaData.reset,
        oneTime
      };
    if (!oneTime || dataRequestState.proofOfOwnership) {
      const persona2 = walletData.persona;
      if (walletData.persona) draft.persona = persona2;
      if (dataRequestState.persona?.withProof)
        draft.persona = { ...draft.persona ?? {}, challenge };
      if (Object.values(dataRequestState).length === 0)
        draft.persona = { challenge: void 0 };
    }
  })
);

// src/modules/wallet-request/data-request/transformations/shared-data.ts
import { produce as produce7 } from "immer";
var transformWalletRequestToSharedData = (walletInteraction, sharedData) => {
  const { items: walletDataRequest } = walletInteraction;
  if (walletDataRequest.discriminator === "authorizedRequest")
    return produce7({}, (draft) => {
      draft.persona = { proof: false };
      if (walletDataRequest.auth.discriminator === "loginWithChallenge")
        draft.persona.proof = !!walletDataRequest.auth.challenge;
      if (walletDataRequest.ongoingAccounts) {
        draft.ongoingAccounts = {
          proof: !!walletDataRequest.ongoingAccounts.challenge,
          numberOfAccounts: walletDataRequest.ongoingAccounts.numberOfAccounts
        };
      }
      if (walletDataRequest.ongoingPersonaData) {
        draft.ongoingPersonaData = walletDataRequest.ongoingPersonaData;
      }
    });
  return sharedData;
};
var transformSharedDataToDataRequestState = (sharedData) => produce7({}, (draft) => {
  if (sharedData.ongoingAccounts) {
    draft.accounts = {
      numberOfAccounts: sharedData.ongoingAccounts.numberOfAccounts,
      withProof: sharedData.ongoingAccounts.proof,
      reset: true
    };
  }
  if (sharedData.ongoingPersonaData) {
    draft.personaData = {
      fullName: sharedData.ongoingPersonaData.isRequestingName,
      phoneNumbers: sharedData.ongoingPersonaData.numberOfRequestedPhoneNumbers,
      emailAddresses: sharedData.ongoingPersonaData.numberOfRequestedEmailAddresses,
      reset: false
    };
  }
  if (sharedData.persona) {
    draft.persona = {
      withProof: false
    };
  }
});

// src/modules/wallet-request/data-request/transformations/wallet-to-rdt.ts
import { produce as produce8 } from "immer";
import { okAsync as okAsync2 } from "neverthrow";

// src/modules/state/state.module.ts
import { BehaviorSubject as BehaviorSubject2, Subscription, filter } from "rxjs";

// src/modules/state/types.ts
import {
  array as array4,
  boolean as boolean6,
  optional as optional6,
  literal as literal2,
  object as object7,
  variant,
  string as string4
} from "valibot";
var proofType = {
  persona: "persona",
  account: "account"
};
var SignedChallengePersona = object7({
  challenge: string4(),
  proof: Proof,
  address: string4(),
  type: literal2(proofType.persona)
});
var SignedChallengeAccount = object7({
  challenge: string4(),
  proof: Proof,
  address: string4(),
  type: literal2(proofType.account)
});
var SignedChallenge = variant("type", [
  SignedChallengePersona,
  SignedChallengeAccount
]);
var WalletDataPersonaDataFullName = object7({
  entry: literal2("fullName"),
  fields: PersonaDataName
});
var WalletDataPersonaDataEmailAddresses = object7({
  entry: literal2("emailAddresses"),
  fields: array4(string4())
});
var WalletDataPersonaDataPhoneNumbersAddresses = object7({
  entry: literal2("phoneNumbers"),
  fields: array4(string4())
});
var WalletDataPersonaData = variant("entry", [
  WalletDataPersonaDataFullName,
  WalletDataPersonaDataEmailAddresses,
  WalletDataPersonaDataPhoneNumbersAddresses
]);
var WalletData = object7({
  accounts: array4(Account),
  personaData: array4(WalletDataPersonaData),
  persona: optional6(Persona),
  proofs: array4(SignedChallenge)
});
var SharedData = object7({
  persona: optional6(object7({ proof: boolean6() })),
  ongoingAccounts: optional6(
    object7({
      numberOfAccounts: optional6(NumberOfValues),
      proof: boolean6()
    })
  ),
  ongoingPersonaData: optional6(PersonaDataRequestItem)
});
var RdtState = object7({
  loggedInTimestamp: string4(),
  walletData: WalletData,
  sharedData: SharedData
});
var walletDataDefault = {
  accounts: [],
  personaData: [],
  proofs: [],
  persona: void 0
};

// src/modules/state/state.module.ts
import { ok as ok4, okAsync } from "neverthrow";
var StateModule = (input) => {
  const logger = input?.logger?.getSubLogger({ name: "StateModule" });
  const storageModule = input.providers.storageModule;
  const subscriptions = new Subscription();
  const setState = (state) => storageModule.setState(state);
  const getState = () => storageModule.getState().orElse(() => okAsync(defaultState)).andThen((state) => state ? ok4(state) : ok4(defaultState));
  const patchState = (state) => getState().andThen(
    (oldState) => setState({ ...oldState, ...state })
  );
  const defaultState = {
    walletData: walletDataDefault,
    loggedInTimestamp: "",
    sharedData: {}
  };
  const resetState = () => storageModule.setState(defaultState).map(() => {
    emitWalletData();
  });
  const initializeState = () => getState().map(() => emitWalletData()).orElse(() => resetState());
  initializeState();
  const walletDataSubject = new BehaviorSubject2(
    void 0
  );
  const emitWalletData = () => {
    storageModule.getState().map((state) => {
      walletDataSubject.next(state?.walletData);
    });
  };
  const walletData$ = walletDataSubject.asObservable().pipe(filter((walletData) => !!walletData));
  return {
    setState,
    patchState,
    getState,
    walletData$,
    emitWalletData,
    getWalletData: () => walletDataSubject.value,
    reset: resetState,
    storage$: storageModule.storage$,
    destroy: () => {
      subscriptions.unsubscribe();
    }
  };
};

// src/modules/wallet-request/data-request/transformations/wallet-to-rdt.ts
var withAccounts = (input) => (walletData) => {
  let accounts2 = [];
  if (input.discriminator === "authorizedRequest") {
    const oneTimeAccounts = input.oneTimeAccounts?.accounts ?? [];
    const ongoingAccounts = input.ongoingAccounts?.accounts ?? [];
    accounts2 = [...oneTimeAccounts, ...ongoingAccounts];
  } else if (input.discriminator === "unauthorizedRequest") {
    const oneTimeAccounts = input.oneTimeAccounts?.accounts ?? [];
    accounts2 = oneTimeAccounts;
  }
  return produce8(walletData, (draft) => {
    draft.accounts = accounts2;
  });
};
var withPersonaDataEntries = (input) => {
  const entries = [];
  if (input.name) {
    entries.push({
      entry: "fullName",
      fields: input.name
    });
  }
  if (input.emailAddresses)
    entries.push({
      entry: "emailAddresses",
      fields: input.emailAddresses
    });
  if (input.phoneNumbers)
    entries.push({
      entry: "phoneNumbers",
      fields: input.phoneNumbers
    });
  return entries;
};
var convertOwnershipProofsToSignedChallenge = (challenge, proofs) => {
  return proofs.map((proof) => {
    const type = "identityAddress" in proof ? proofType.persona : proofType.account;
    const address = "identityAddress" in proof ? proof.identityAddress : proof.accountAddress;
    return {
      type,
      challenge,
      address,
      proof: proof.proof
    };
  });
};
var withPersonaData = (input) => (walletData) => produce8(walletData, (draft) => {
  if (input.discriminator === "authorizedRequest") {
    if (input.oneTimePersonaData)
      draft.personaData = withPersonaDataEntries(input.oneTimePersonaData);
    if (input.ongoingPersonaData)
      draft.personaData = withPersonaDataEntries(input.ongoingPersonaData);
  } else if (input.discriminator === "unauthorizedRequest" && input.oneTimePersonaData)
    draft.personaData = withPersonaDataEntries(input.oneTimePersonaData);
});
var withPersona = (input) => (walletData) => produce8(walletData, (draft) => {
  if (input.discriminator === "authorizedRequest")
    draft.persona = input.auth?.persona;
});
var withProofs = (input) => (walletData) => produce8(walletData, (draft) => {
  draft.proofs = [];
  if (input.discriminator === "authorizedRequest") {
    if (input.auth.discriminator === "loginWithChallenge")
      draft.proofs.push({
        challenge: input.auth.challenge,
        proof: input.auth.proof,
        address: input.auth.persona.identityAddress,
        type: proofType.persona
      });
    if (input.ongoingAccounts?.challenge && input.ongoingAccounts.proofs?.length) {
      const challenge = input.ongoingAccounts.challenge;
      const accountProofs = input.ongoingAccounts.proofs.map(
        ({ accountAddress, proof }) => ({
          proof,
          address: accountAddress,
          challenge,
          type: proofType.account
        })
      );
      draft.proofs.push(...accountProofs);
    }
    if (input.oneTimeAccounts?.challenge && input.oneTimeAccounts.proofs?.length) {
      const challenge = input.oneTimeAccounts.challenge;
      const accountProofs = input.oneTimeAccounts.proofs.map(
        ({ accountAddress, proof }) => ({
          proof,
          address: accountAddress,
          challenge,
          type: proofType.account
        })
      );
      draft.proofs.push(...accountProofs);
    }
    if (input.proofOfOwnership) {
      draft.proofs.push(
        ...convertOwnershipProofsToSignedChallenge(
          input.proofOfOwnership.challenge,
          input.proofOfOwnership.proofs
        )
      );
    }
  }
  if (input.discriminator === "unauthorizedRequest") {
    if (input.oneTimeAccounts?.challenge && input.oneTimeAccounts.proofs?.length) {
      const challenge = input.oneTimeAccounts.challenge;
      const accountProofs = input.oneTimeAccounts.proofs.map(
        ({ accountAddress, proof }) => ({
          proof,
          address: accountAddress,
          challenge,
          type: proofType.account
        })
      );
      draft.proofs.push(...accountProofs);
    }
  }
});
var transformWalletResponseToRdtWalletData = (response) => okAsync2({
  accounts: [],
  personaData: [],
  proofs: [],
  persona: void 0
}).map(withAccounts(response)).map(withPersonaData(response)).map(withPersona(response)).map(withProofs(response));

// src/modules/wallet-request/data-request/transformations/wallet-data-to-connect-button.ts
var transformWalletDataToConnectButton = (walletData) => {
  const accounts2 = walletData.accounts ?? [];
  const personaLabel = walletData?.persona?.label ?? "";
  const connected = !!walletData?.persona;
  const personaData2 = walletData?.personaData?.map((item) => {
    if (item.entry === "fullName") {
      const { variant: variant2, givenNames, familyName, nickname } = item.fields;
      const value = variant2 === "western" ? `${givenNames}${nickname ? ` "${nickname}" ` : " "}${familyName}` : `${familyName}${nickname ? ` "${nickname}" ` : " "}${givenNames}`;
      return {
        value,
        field: "fullName"
      };
    } else if (item.entry === "emailAddresses") {
      return {
        // currently only one email address is supported
        value: item.fields[0],
        field: "emailAddress"
      };
    } else if (item.entry === "phoneNumbers") {
      return {
        // currently only one phone number is supported
        value: item.fields[0],
        field: "phoneNumber"
      };
    }
    return;
  }).filter(
    (item) => !!item && !!item.value?.trim()
  );
  return { accounts: accounts2, personaLabel, connected, personaData: personaData2 };
};

// src/modules/wallet-request/data-request/data-request-state.module.ts
import { BehaviorSubject as BehaviorSubject3 } from "rxjs";
import { produce as produce9 } from "immer";
var DataRequestStateModule = (initialState) => {
  const state = new BehaviorSubject3(initialState);
  const reset = () => state.next(initialState);
  const update = (input) => state.next(input);
  const getState = () => state.getValue();
  const toDataRequestState = (...items) => items.filter((item) => typeof item._toObject === "function").reduce(
    (acc, item) => ({
      ...acc,
      ...item._toObject()
    }),
    {}
  );
  const setState = (...items) => {
    if (items.length === 0) reset();
    else {
      update(toDataRequestState(...items));
    }
  };
  const patchState = (...items) => {
    if (items.length === 0) return;
    update({ ...getState(), ...toDataRequestState(...items) });
  };
  const removeState = (...keys) => {
    update(
      produce9(getState(), (draft) => {
        keys.forEach((key) => {
          delete draft[key];
        });
      })
    );
  };
  return {
    reset,
    setState,
    getState,
    patchState,
    removeState,
    toDataRequestState,
    state$: state.asObservable()
  };
};

// src/modules/wallet-request/identity/identity.module.ts
import { err as err3, ok as ok5, okAsync as okAsync3 } from "neverthrow";

// src/modules/wallet-request/crypto/create-signature-message.ts
import { Buffer as Buffer5 } from "buffer";
var createSignatureMessage = ({
  interactionId,
  dAppDefinitionAddress,
  origin,
  logger
}) => {
  const prefix = "C";
  const prefixBuffer = Buffer5.from("C", "ascii");
  const lengthOfDappDefAddress = dAppDefinitionAddress.length;
  const lengthOfDappDefAddressBuffer = Buffer5.from(
    lengthOfDappDefAddress.toString(16),
    "hex"
  );
  const dappDefAddressBuffer = Buffer5.from(dAppDefinitionAddress, "utf-8");
  const originBuffer = Buffer5.from(origin, "utf-8");
  const interactionIdBuffer = Buffer5.from(interactionId, "utf-8");
  const messageBuffer = Buffer5.concat([
    prefixBuffer,
    interactionIdBuffer,
    lengthOfDappDefAddressBuffer,
    dappDefAddressBuffer,
    originBuffer
  ]);
  const blake2bHash = blake2b(messageBuffer).map((hash2) => {
    logger?.debug({
      method: "createSignatureMessage",
      messagePartsRaw: [
        prefix,
        interactionId,
        lengthOfDappDefAddress,
        dAppDefinitionAddress,
        origin
      ],
      messageParts: [
        prefixBuffer.toString("hex"),
        interactionIdBuffer.toString("hex"),
        lengthOfDappDefAddressBuffer.toString("hex"),
        dappDefAddressBuffer.toString("hex"),
        originBuffer.toString("hex")
      ],
      message: messageBuffer.toString("hex"),
      blake2bHash: hash2.toString("hex")
    });
    return Buffer5.from(hash2).toString("hex");
  }).mapErr((jsError) => ({ reason: "couldNotHashMessage", jsError }));
  return blake2bHash;
};

// src/modules/wallet-request/identity/identity.module.ts
var IdentityKind = {
  dApp: "dApp"
};
var IdentityModule = (input) => {
  const { storageModule, KeyPairModule } = input.providers;
  const keyPairFromSecret = (input2) => ok5(KeyPairModule(input2));
  const getIdentity = (kind) => storageModule.getItemById(kind).andThen(
    (identity) => identity ? keyPairFromSecret(identity.secret) : okAsync3(void 0)
  );
  const createIdentity = (kind) => ok5(KeyPairModule()).asyncAndThen(
    (keyPair) => storageModule.setItems({
      [kind]: {
        secret: keyPair.getPrivateKey(),
        createdAt: Date.now()
      }
    }).map(() => keyPair)
  );
  const getOrCreateIdentity = (kind) => getIdentity(kind).andThen((keyPair) => keyPair ? okAsync3(keyPair) : createIdentity(kind)).mapErr((error) => ({
    reason: "couldNotGetOrCreateIdentity",
    jsError: error
  }));
  const deriveSharedSecret = (kind, publicKey) => getIdentity(kind).mapErr(() => ({ reason: "couldNotDeriveSharedSecret" })).andThen(
    (identity) => identity ? identity.x25519.calculateSharedSecret(publicKey, input.dAppDefinitionAddress).mapErr(() => ({
      reason: "FailedToDeriveSharedSecret"
    })) : err3({ reason: "DappIdentityNotFound" })
  );
  const createSignature = ({
    kind,
    interactionId,
    dAppDefinitionAddress,
    origin
  }) => getOrCreateIdentity(kind).andThen(
    (identity) => createSignatureMessage({
      interactionId,
      dAppDefinitionAddress,
      origin,
      logger: input.logger
    }).andThen(
      (message) => identity.ed25519.sign(message).map((signature) => ({
        signature,
        publicKey: identity.x25519.getPublicKey(),
        identity: identity.ed25519.getPublicKey()
      })).mapErr((error) => ({
        reason: "couldNotSignMessage",
        jsError: error
      }))
    )
  );
  return {
    get: (kind) => getOrCreateIdentity(kind),
    deriveSharedSecret,
    createSignature
  };
};

// ../common/src/index.ts
var RequestStatus = {
  fail: "fail",
  ignored: "ignored",
  pending: "pending",
  success: "success",
  timedOut: "timedOut",
  cancelled: "cancelled",
  /**
   * Pending commit status is for preauthorization which was signed but not yet successfully committed to the network
   */
  pendingCommit: "pendingCommit"
};

// src/modules/wallet-request/request-items/request-item.module.ts
import { Subscription as Subscription2, filter as filter2, map, switchMap } from "rxjs";

// src/error.ts
var ErrorType = {
  rejectedByUser: "rejectedByUser",
  missingExtension: "missingExtension",
  canceledByUser: "canceledByUser",
  walletRequestValidation: "walletRequestValidation",
  walletResponseValidation: "walletResponseValidation",
  wrongNetwork: "wrongNetwork",
  failedToPrepareTransaction: "failedToPrepareTransaction",
  failedToCompileTransaction: "failedToCompileTransaction",
  failedToSignTransaction: "failedToSignTransaction",
  failedToSubmitTransaction: "failedToSubmitTransaction",
  failedToPollSubmittedTransaction: "failedToPollSubmittedTransaction",
  submittedTransactionWasDuplicate: "submittedTransactionWasDuplicate",
  submittedTransactionHasFailedTransactionStatus: "submittedTransactionHasFailedTransactionStatus",
  submittedTransactionHasRejectedTransactionStatus: "submittedTransactionHasRejectedTransactionStatus",
  failedToFindAccountWithEnoughFundsToLockFee: "failedToFindAccountWithEnoughFundsToLockFee",
  wrongAccountType: "wrongAccountType",
  unknownWebsite: "unknownWebsite",
  radixJsonNotFound: "radixJsonNotFound",
  unknownDappDefinitionAddress: "unknownDappDefinitionAddress",
  invalidPersona: "invalidPersona"
};
var defaultErrorMessage = (/* @__PURE__ */ new Map()).set(ErrorType.missingExtension, "extension could not be found").set(ErrorType.rejectedByUser, "user rejected request").set(ErrorType.canceledByUser, "user has canceled the request");
var SdkError = (error, interactionId, message, jsError) => ({
  error,
  interactionId,
  message: message || defaultErrorMessage.get(error) || "",
  jsError
});

// src/modules/wallet-request/request-items/request-item.module.ts
import { errAsync } from "neverthrow";
var RequestItemModule = (input) => {
  const logger = input?.logger?.getSubLogger({ name: "RequestItemModule" });
  const subscriptions = new Subscription2();
  const storageModule = input.providers.storageModule;
  const signals = /* @__PURE__ */ new Map();
  const createItem = ({
    type,
    walletInteraction,
    isOneTimeRequest
  }) => ({
    type,
    status: "pending",
    createdAt: Date.now(),
    interactionId: walletInteraction.interactionId,
    showCancel: true,
    walletInteraction,
    isOneTimeRequest
  });
  const add = (value, onSignal) => {
    const item = createItem(value);
    logger?.debug({
      method: "addRequestItem",
      item
    });
    if (onSignal) {
      signals.set(item.interactionId, onSignal);
    }
    return storageModule.setItems({ [item.interactionId]: item }).map(() => item);
  };
  const getAndRemoveSignal = (interactionId) => {
    if (signals.has(interactionId)) {
      const signal = signals.get(interactionId);
      signals.delete(interactionId);
      return signal;
    }
  };
  const patch = (id, partialValue) => {
    logger?.debug({
      method: "patchRequestItemStatus",
      item: { id, ...partialValue }
    });
    return storageModule.patchItem(id, partialValue);
  };
  const cancel = (id) => {
    logger?.debug({ method: "cancelRequestItem", id });
    return patch(id, { status: "fail", error: ErrorType.canceledByUser });
  };
  const isWalletInteractionRequired = (status) => [RequestStatus.pending, RequestStatus.pendingCommit].includes(
    status
  );
  const updateStatus = ({
    id,
    status,
    error,
    transactionIntentHash,
    metadata = {},
    walletData,
    walletResponse
  }) => {
    return storageModule.getItemById(id).mapErr(() => ({ reason: "couldNotReadFromStore" })).andThen((item) => {
      if (item) {
        if (status === RequestStatus.ignored && signals.has(id)) {
          signals.delete(id);
        }
        if (status === RequestStatus.success) {
          const signal = getAndRemoveSignal(id);
          signal?.(metadata?.parentTransactionIntentHash);
        }
        const updated = {
          ...item,
          walletData,
          transactionIntentHash,
          error,
          walletResponse,
          status: item.status === RequestStatus.ignored ? item.status : status,
          metadata: item.metadata ? { ...item.metadata, ...metadata } : metadata
        };
        if (!isWalletInteractionRequired(updated.status)) {
          delete updated.walletInteraction;
        }
        logger?.debug({ method: "updateRequestItemStatus", updated });
        return storageModule.setItems({ [id]: updated }).mapErr(() => ({ reason: "couldNotWriteToStore" }));
      }
      return errAsync({ reason: "itemNotFound" });
    });
  };
  const getPendingCommit = () => storageModule.getItemList().map(
    (items) => items.filter((item) => item.status === RequestStatus.pendingCommit)
  );
  const getPending = () => storageModule.getItemList().map((items) => items.filter((item) => item.status === "pending"));
  const requests$ = storageModule.storage$.pipe(
    switchMap(() => storageModule.getItemList()),
    map((result) => {
      if (result.isOk()) return result.value;
    }),
    filter2((items) => !!items)
  );
  return {
    add,
    cancel,
    updateStatus,
    patch,
    getAndRemoveSignal,
    getById: (id) => storageModule.getItemById(id),
    getPendingCommit,
    getPending,
    requests$,
    clear: storageModule.clear,
    destroy: () => {
      subscriptions.unsubscribe();
    }
  };
};

// src/modules/wallet-request/session/session.module.ts
import { okAsync as okAsync4 } from "neverthrow";
import { v4 as uuidV4 } from "uuid";
var SessionModule = (input) => {
  const storageModule = input.providers.storageModule;
  const getSession = () => storageModule.getItemList().mapErr((error) => ({
    reason: "couldNotReadSessionFromStore",
    jsError: error
  })).map((sessions) => sessions[0]);
  const getSessionById = (sessionId) => storageModule.getItemById(sessionId).mapErr((error) => ({ reason: "couldNotGetSessionById", jsError: error }));
  const createSession = () => {
    const sessionId = uuidV4();
    const newSession = {
      sessionId,
      createdAt: Date.now()
    };
    return storageModule.setItems({ [sessionId]: newSession }).map(() => newSession).mapErr((error) => ({ reason: "couldNotCreateSession", jsError: error }));
  };
  const patchSession = (sessionId, value) => storageModule.patchItem(sessionId, value).mapErr((error) => ({ reason: "couldNotPatchSession", jsError: error }));
  const getCurrentSession = () => getSession().andThen(
    (session) => session ? okAsync4(session) : createSession()
  );
  return {
    getCurrentSession,
    getSession,
    store: storageModule,
    getSessionById,
    patchSession
  };
};

// src/modules/wallet-request/transport/connector-extension/subjects.ts
import { Subject as Subject2 } from "rxjs";
var ConnectorExtensionSubjects = () => ({
  outgoingMessageSubject: new Subject2(),
  incomingMessageSubject: new Subject2(),
  responseSubject: new Subject2(),
  messageLifeCycleEventSubject: new Subject2()
});

// src/modules/wallet-request/transport/connector-extension/connector-extension.module.ts
import { ResultAsync as ResultAsync6, err as err7, ok as ok9, okAsync as okAsync6 } from "neverthrow";
import {
  Subject as Subject4,
  Subscription as Subscription3,
  filter as filter3,
  first,
  firstValueFrom as firstValueFrom2,
  from,
  map as map3,
  merge as merge2,
  mergeMap,
  of as of2,
  race,
  share,
  shareReplay,
  switchMap as switchMap3,
  takeUntil,
  tap,
  timer as timer2
} from "rxjs";

// src/helpers/exponential-backoff.ts
import { err as err4, ok as ok6 } from "neverthrow";
import { map as map2, merge, of, Subject as Subject3, switchMap as switchMap2, timer } from "rxjs";
var ExponentialBackoff = ({
  maxDelayTime = 1e4,
  multiplier = 2,
  timeout,
  interval = 2e3
} = {}) => {
  const trigger = new Subject3();
  const stop = new Subject3();
  let numberOfRetries = 0;
  const backoff$ = merge(
    of(0),
    trigger.pipe(
      map2(() => {
        numberOfRetries = numberOfRetries + 1;
        return numberOfRetries;
      })
    )
  ).pipe(
    switchMap2((numberOfRetries2) => {
      const delayTime = numberOfRetries2 * interval * multiplier;
      const delay2 = delayTime > maxDelayTime ? maxDelayTime : delayTime;
      return timer(delay2).pipe(map2(() => ok6(numberOfRetries2)));
    })
  );
  const withBackoffAndTimeout$ = merge(
    stop.asObservable().pipe(map2(() => err4({ error: "stopped" }))),
    timeout ? merge(
      backoff$,
      timer(timeout).pipe(map2(() => err4({ error: "timeout" })))
    ) : backoff$
  );
  return {
    trigger,
    withBackoff$: withBackoffAndTimeout$,
    stop: () => stop.next()
  };
};

// src/helpers/fetch-wrapper.ts
import { ResultAsync as ResultAsync4, errAsync as errAsync2, okAsync as okAsync5 } from "neverthrow";

// src/helpers/parse-json.ts
import { err as err5, ok as ok7 } from "neverthrow";
var parseJSON = (text) => {
  try {
    return ok7(JSON.parse(text));
  } catch (error) {
    return err5(error);
  }
};

// src/helpers/fetch-wrapper.ts
var typedError = (error) => error;
var resolveFetch = (fetchable) => ResultAsync4.fromPromise(fetchable, typedError).mapErr((error) => ({
  reason: "FailedToFetch",
  error,
  status: 0
}));
var fetchWrapper = (fetchable) => resolveFetch(fetchable).andThen(
  (response) => ResultAsync4.fromPromise(response.text(), typedError).andThen((text) => text ? parseJSON(text) : okAsync5(text)).mapErr((error) => ({
    status: response.status,
    reason: "FailedToParseResponseToJson",
    error
  })).andThen(
    (data) => response.ok ? okAsync5({
      status: response.status,
      data
    }) : errAsync2({
      status: response.status,
      reason: "RequestStatusNotOk",
      data
    })
  )
);

// src/helpers/logger.ts
import { Logger as TsLogger } from "tslog";
var Logger = (minLevel) => new TsLogger({
  minLevel: minLevel ?? 2,
  prettyLogTemplate: "{{hh}}:{{MM}}:{{ss}}:{{ms}}	{{name}}	{{logLevelName}}	"
});

// src/helpers/stringify.ts
import { err as err6, ok as ok8 } from "neverthrow";
var stringify = (input) => {
  try {
    return ok8(JSON.stringify(input));
  } catch (error) {
    return err6(error);
  }
};

// src/helpers/remove-undefined.ts
var removeUndefined = (input) => stringify(input).andThen(parseJSON);

// src/helpers/typed-error.ts
var typedError2 = (error) => error;

// src/helpers/unwrap-observable.ts
import { ResultAsync as ResultAsync5 } from "neverthrow";
import { firstValueFrom } from "rxjs";
var unwrapObservable = (input) => ResultAsync5.fromPromise(
  firstValueFrom(input),
  (error) => error
).andThen((result) => result);

// src/helpers/validate-wallet-response.ts
import { Result as Result3 } from "neverthrow";
import { parse } from "valibot";
var validateWalletResponse = (walletResponse) => {
  const fn = Result3.fromThrowable(
    (_) => parse(WalletInteractionResponse, _),
    (error) => error
  );
  return fn(walletResponse).mapErr(
    (response) => SdkError(
      "walletResponseValidation",
      walletResponse?.interactionId,
      "Invalid input",
      response
    )
  );
};

// src/helpers/generate-rola-challenge.ts
var generateRolaChallenge = () => [...globalThis.crypto.getRandomValues(new Uint8Array(32))].map((x) => x.toString(16).padStart(2, "0")).join("");

// src/helpers/validate-rola-challenge.ts
var validateRolaChallenge = (challenge) => typeof challenge === "string" && /^[0-9a-f]{64}$/i.test(challenge);

// src/helpers/parse-signed-challenge.ts
import { safeParse } from "valibot";
var parseSignedChallenge = (value) => safeParse(SignedChallenge, value);

// src/modules/wallet-request/transport/connector-extension/connector-extension.module.ts
import { v4 as uuidV42 } from "uuid";
var ConnectorExtensionModule = (input) => {
  let isExtensionHandlingSessions = false;
  const logger = input?.logger?.getSubLogger({
    name: "ConnectorExtensionModule"
  });
  const subjects = input?.subjects ?? ConnectorExtensionSubjects();
  const subscription = new Subscription3();
  const extensionDetectionTime = input?.extensionDetectionTime ?? 200;
  const requestResolverModule = input.providers.requestResolverModule;
  const storage = input.providers.storageModule.getPartition("connectorExtension");
  subscription.add(
    subjects.incomingMessageSubject.pipe(
      tap((message) => {
        logger?.debug({
          method: "incomingMessageSubject",
          message
        });
        if ("eventType" in message) {
          subjects.messageLifeCycleEventSubject.next(message);
        } else {
          subjects.responseSubject.next(message);
        }
      })
    ).subscribe()
  );
  subscription.add(
    subjects.responseSubject.pipe(
      mergeMap(
        (walletResponse) => from(requestResolverModule.addWalletResponses([walletResponse]))
      )
    ).subscribe()
  );
  subscription.add(
    subjects.outgoingMessageSubject.pipe(
      tap((payload) => {
        logger?.debug({
          method: "outgoingMessageSubject",
          payload
        });
        input.providers.environmentModule.globalThis.dispatchEvent(
          new CustomEvent(eventType.outgoingMessage, {
            detail: payload
          })
        );
      })
    ).subscribe()
  );
  const wrapOutgoingInteraction = (interaction) => {
    if (!isExtensionHandlingSessions) {
      return okAsync6(interaction);
    }
    return storage.getState().andThen((state) => {
      const isAuthorizedRequest = interaction.items.discriminator === "authorizedRequest";
      const sessionId = isAuthorizedRequest ? state?.sessionId || uuidV42() : state?.sessionId;
      const wrappedRequest = {
        interactionId: interaction.interactionId,
        interaction,
        sessionId,
        discriminator: "walletInteraction"
      };
      return isAuthorizedRequest ? storage.setState({ sessionId }).map(() => wrappedRequest) : okAsync6(wrappedRequest);
    });
  };
  const handleIncomingMessage = (event) => {
    const message = event.detail;
    subjects.incomingMessageSubject.next(message);
  };
  addEventListener(eventType.incomingMessage, handleIncomingMessage);
  const sendWalletInteraction = (walletInteraction, callbackFns) => {
    const cancelRequestSubject = new Subject4();
    const maybeResolved$ = from(
      requestResolverModule.getWalletResponseById(
        walletInteraction.interactionId
      )
    ).pipe(filter3((result) => result.isOk() && !!result.value));
    const walletResponse$ = subjects.responseSubject.pipe(
      filter3(
        (response) => response.interactionId === walletInteraction.interactionId
      ),
      map3((walletResponse) => ok9(walletResponse))
    );
    const cancelResponse$ = subjects.messageLifeCycleEventSubject.pipe(
      filter3(
        ({ interactionId, eventType: eventType2 }) => walletInteraction.interactionId === interactionId && ["requestCancelSuccess", "requestCancelFail"].includes(eventType2)
      ),
      map3((message) => {
        const error = SdkError("canceledByUser", message.interactionId);
        logger?.debug(`\u{1F535}\u2B06\uFE0F\u274C walletRequestCanceled`, error);
        return message;
      })
    );
    const sendCancelRequest = () => {
      subjects.outgoingMessageSubject.next({
        interactionId: walletInteraction.interactionId,
        metadata: walletInteraction.metadata,
        ...isExtensionHandlingSessions ? { discriminator: "cancelWalletInteraction" } : { items: { discriminator: "cancelRequest" } }
      });
      setTimeout(() => {
        cancelRequestSubject.next(
          err7(SdkError("canceledByUser", walletInteraction.interactionId))
        );
      });
      return ResultAsync6.fromSafePromise(
        firstValueFrom2(
          merge2(
            walletResponse$.pipe(map3(() => "requestCancelFail")),
            cancelResponse$.pipe(map3(({ eventType: eventType2 }) => eventType2))
          )
        )
      );
    };
    if (callbackFns.requestControl)
      callbackFns.requestControl({
        cancelRequest: () => sendCancelRequest().andThen(
          (eventType2) => eventType2 === "requestCancelSuccess" ? ok9("requestCancelSuccess") : err7("requestCancelFail")
        ),
        getRequest: () => walletInteraction
      });
    const walletResponseOrCancelRequest$ = merge2(
      maybeResolved$,
      walletResponse$,
      cancelRequestSubject
    ).pipe(first());
    const messageLifeCycleEvent$ = subjects.messageLifeCycleEventSubject.pipe(
      filter3(
        ({ interactionId }) => walletInteraction.interactionId === interactionId
      ),
      tap((event) => {
        if (callbackFns.eventCallback)
          callbackFns.eventCallback(event.eventType);
      }),
      takeUntil(walletResponse$),
      share()
    );
    const messageEventSubscription = messageLifeCycleEvent$.subscribe();
    const missingExtensionError$ = timer2(extensionDetectionTime).pipe(
      map3(
        () => err7(SdkError("missingExtension", walletInteraction.interactionId))
      )
    );
    const extensionMissingError$ = merge2(
      missingExtensionError$,
      messageLifeCycleEvent$
    ).pipe(
      first(),
      filter3((value) => !("eventType" in value))
    );
    const sendWalletRequest$ = extensionStatus$.pipe(
      filter3((status) => status.isExtensionAvailable),
      switchMap3(() => of2(wrapOutgoingInteraction(walletInteraction))),
      tap((result) => {
        result.map((message) => {
          subjects.outgoingMessageSubject.next(message);
        });
      }),
      filter3((_) => false)
    );
    return unwrapObservable(
      merge2(
        walletResponseOrCancelRequest$,
        extensionMissingError$,
        sendWalletRequest$
      ).pipe(
        tap(() => {
          messageEventSubscription.unsubscribe();
        })
      )
    );
  };
  const extensionStatusEvent$ = subjects.messageLifeCycleEventSubject.pipe(
    filter3(
      (event) => event.eventType === "extensionStatus"
    )
  );
  const extensionStatus$ = of2(true).pipe(
    tap(() => {
      subjects.outgoingMessageSubject.next({
        interactionId: uuidV42(),
        discriminator: "extensionStatus"
      });
    }),
    switchMap3(
      () => race(
        extensionStatusEvent$,
        merge2(
          extensionStatusEvent$,
          timer2(extensionDetectionTime).pipe(
            map3(
              () => ({
                eventType: "extensionStatus",
                isWalletLinked: false,
                isExtensionAvailable: false,
                canHandleSessions: false
              })
            )
          )
        )
      )
    ),
    tap((event) => {
      isExtensionHandlingSessions = event.canHandleSessions || false;
    }),
    shareReplay(1)
  );
  return {
    id: "connector-extension",
    isSupported: () => !input.providers.environmentModule.isMobile(),
    send: sendWalletInteraction,
    isAvailable$: extensionStatus$.pipe(
      map3(({ isExtensionAvailable }) => isExtensionAvailable)
    ),
    isLinked$: extensionStatus$.pipe(
      map3(({ isWalletLinked }) => isWalletLinked)
    ),
    showQrCode: () => {
      input.providers.environmentModule.globalThis.dispatchEvent(
        new CustomEvent(eventType.outgoingMessage, {
          detail: { discriminator: "openPopup" }
        })
      );
    },
    disconnect: () => {
      storage.clear();
    },
    destroy: () => {
      subscription.unsubscribe();
      removeEventListener(eventType.incomingMessage, handleIncomingMessage);
    }
  };
};

// src/modules/wallet-request/transport/radix-connect-relay/deep-link.module.ts
import { errAsync as errAsync3, okAsync as okAsync7 } from "neverthrow";
var DeepLinkModule = (input) => {
  const { walletUrl } = input;
  const logger = input?.logger?.getSubLogger({ name: "DeepLinkModule" });
  const isTelegramMiniApp = input.providers.environmentModule.isTMA();
  const deepLinkToWallet = (values) => {
    const outboundUrl = new URL(walletUrl);
    Object.entries(values).forEach(([key, value]) => {
      outboundUrl.searchParams.append(key, value);
    });
    logger?.debug({
      method: "deepLinkToWallet",
      data: { ...values }
    });
    if (input.providers.environmentModule.isMobile()) {
      const deepLink = outboundUrl.toString();
      if (isTelegramMiniApp)
        input.providers.environmentModule.globalThis.open(deepLink, "_blank");
      else if (input.providers.environmentModule.globalThis.location?.href)
        input.providers.environmentModule.globalThis.location.href = deepLink;
      return okAsync7(void 0);
    }
    return errAsync3(SdkError("UnhandledEnvironment", ""));
  };
  return {
    deepLinkToWallet
  };
};

// src/modules/wallet-request/transport/radix-connect-relay/radix-connect-relay.module.ts
import { ResultAsync as ResultAsync8, errAsync as errAsync4 } from "neverthrow";
import { Subscription as Subscription4 } from "rxjs";

// src/modules/wallet-request/encryption/helpers/buffer-reader.ts
import { err as err8, ok as ok10 } from "neverthrow";
import { Buffer as Buffer6 } from "buffer";
var createBufferReader = (buffer) => {
  let offset = 0;
  let bytesLeftToRead = buffer.length;
  const readNextBuffer = (byteCount) => {
    if (byteCount < 0) return err8(Error(`'byteCount' must not be negative`));
    if (byteCount === 0) {
      return ok10(Buffer6.alloc(0));
    }
    if (offset + byteCount > buffer.length)
      return err8(Error(`Out of buffer's boundary`));
    const bufToReturn = Buffer6.alloc(byteCount);
    buffer.copy(bufToReturn, 0, offset, offset + byteCount);
    if (bufToReturn.length !== byteCount) {
      return err8(Error(`Incorrect length of newly read buffer...`));
    }
    offset += byteCount;
    bytesLeftToRead -= byteCount;
    return ok10(bufToReturn);
  };
  const finishedParsing = () => {
    if (bytesLeftToRead < 0) {
      return err8(Error(`Incorrect implementation, read too many bytes.`));
    }
    return ok10(bytesLeftToRead === 0);
  };
  return {
    readNextBuffer,
    finishedParsing,
    remainingBytes: () => finishedParsing().andThen((finished) => {
      if (finished) return ok10(Buffer6.alloc(0));
      const leftBuf = Buffer6.alloc(bytesLeftToRead);
      buffer.copy(leftBuf, 0, offset);
      return ok10(leftBuf);
    })
  };
};
var readBuffer = (buffer) => createBufferReader(buffer).readNextBuffer;

// src/modules/wallet-request/encryption/helpers/sealbox.ts
import { Buffer as Buffer7 } from "buffer";
import { Result as Result5 } from "neverthrow";
var transformBufferToSealbox = (buffer) => {
  const readNextBuffer = readBuffer(buffer);
  const nonceLength = 12;
  const authTagLength = 16;
  return Result5.combine([
    readNextBuffer(nonceLength),
    readNextBuffer(buffer.length - nonceLength - authTagLength),
    readNextBuffer(authTagLength)
  ]).map(([iv, ciphertext, authTag]) => ({
    iv,
    ciphertext,
    authTag,
    combined: Buffer7.concat([iv, ciphertext, authTag]),
    ciphertextAndAuthTag: Buffer7.concat([ciphertext, authTag])
  }));
};

// src/modules/wallet-request/encryption/encryption.module.ts
import { ResultAsync as ResultAsync7 } from "neverthrow";
import { Buffer as Buffer8 } from "buffer";
var EncryptionModule = () => {
  const cryptoDecrypt = (data, encryptionKey, iv) => ResultAsync7.fromPromise(
    crypto.subtle.decrypt({ name: "AES-GCM", iv }, encryptionKey, data),
    typedError2
  ).map(Buffer8.from);
  const cryptoEncrypt = (data, encryptionKey, iv) => ResultAsync7.fromPromise(
    crypto.subtle.encrypt(
      {
        name: "AES-GCM",
        iv
      },
      encryptionKey,
      data
    ),
    typedError2
  ).map(Buffer8.from);
  const getKey = (encryptionKey) => ResultAsync7.fromPromise(
    crypto.subtle.importKey(
      "raw",
      encryptionKey,
      {
        name: "AES-GCM",
        length: 256
      },
      false,
      ["encrypt", "decrypt"]
    ),
    typedError2
  );
  const decrypt = (data, encryptionKey, iv) => getKey(encryptionKey).andThen(
    (cryptoKey) => cryptoDecrypt(data, cryptoKey, iv)
  );
  const encrypt = (data, encryptionKey, iv = createIV()) => getKey(encryptionKey).andThen((cryptoKey) => cryptoEncrypt(data, cryptoKey, iv)).map((ciphertext) => ({
    combined: Buffer8.concat([iv, ciphertext]),
    iv,
    ciphertext
  }));
  const createIV = () => Buffer8.from(crypto.getRandomValues(new Uint8Array(12)));
  return { encrypt, decrypt, createIV };
};

// src/modules/wallet-request/transport/radix-connect-relay/radix-connect-relay-api.service.ts
var RadixConnectRelayApiService = (input) => {
  const baseUrl = input.baseUrl;
  const logger = input.logger?.getSubLogger({ name: "RadixConnectRelayApi" });
  const callApi = (body) => {
    logger?.debug({ method: `callApi.${body.method}`, body });
    return fetchWrapper(
      fetch(baseUrl, {
        method: "POST",
        body: JSON.stringify(body)
      })
    ).map((response) => {
      logger?.debug({
        method: `callApi.${body.method}.success`,
        response
      });
      return response;
    }).mapErr((error) => {
      logger?.debug({
        method: `callApi.${body.method}.error`,
        error
      });
      return SdkError(
        "RadixConnectRelayRequestFailed",
        body.interactionId ?? ""
      );
    });
  };
  const getResponses = (sessionId) => callApi({
    method: "getResponses",
    sessionId
  }).map((value) => value.data);
  return {
    getResponses
  };
};

// src/modules/wallet-request/transport/radix-connect-relay/helpers/base64url.ts
import base64url from "base64url";
var base64urlEncode = (value) => base64url.encode(Buffer.from(JSON.stringify(value)));

// src/modules/wallet-request/transport/radix-connect-relay/radix-connect-relay.module.ts
var RadixConnectRelayModule = (input) => {
  const logger = input.logger?.getSubLogger({ name: "RadixConnectRelayModule" });
  const { baseUrl, providers, walletUrl } = input;
  const { storageModule, requestResolverModule } = providers;
  const encryptionModule = providers?.encryptionModule ?? EncryptionModule();
  const deepLinkModule = providers?.deepLinkModule ?? DeepLinkModule({
    logger,
    walletUrl,
    providers: {
      environmentModule: input.providers.environmentModule
    }
  });
  const identityModule = providers?.identityModule ?? IdentityModule({
    logger,
    dAppDefinitionAddress: input.dAppDefinitionAddress,
    providers: {
      storageModule: storageModule.getPartition("identities"),
      KeyPairModule: Curve25519
    }
  });
  const sessionModule = providers?.sessionModule ?? SessionModule({
    providers: {
      storageModule: storageModule.getPartition("sessions")
    }
  });
  const radixConnectRelayApiService = RadixConnectRelayApiService({
    baseUrl: `${baseUrl}/api/v1`,
    logger
  });
  const subscriptions = new Subscription4();
  const wait = (timer3 = 1500) => new Promise((resolve) => setTimeout(resolve, timer3));
  const decryptWalletResponse = (walletResponse) => {
    if ("error" in walletResponse) {
      return errAsync4({ reason: walletResponse.error });
    }
    return identityModule.get("dApp").andThen(
      (dAppIdentity) => dAppIdentity.x25519.calculateSharedSecret(
        walletResponse.publicKey,
        input.dAppDefinitionAddress
      ).mapErr(() => ({ reason: "FailedToDeriveSharedSecret" })).asyncAndThen(
        (sharedSecret) => decryptWalletResponseData(sharedSecret, walletResponse.data)
      )
    );
  };
  const checkRelayLoop = async () => {
    await requestResolverModule.getPendingRequestIds().andThen(
      () => sessionModule.getCurrentSession().map((session) => session.sessionId).andThen(radixConnectRelayApiService.getResponses).andThen(
        (responses) => ResultAsync8.combine(responses.map(decryptWalletResponse))
      ).andThen(requestResolverModule.addWalletResponses)
    );
    await wait();
    checkRelayLoop();
  };
  if (input.providers.environmentModule.isMobile()) {
    checkRelayLoop();
  }
  const sendWalletInteractionRequest = ({
    session,
    walletInteraction,
    signature,
    publicKey,
    identity
  }) => requestResolverModule.getPendingRequestById(walletInteraction.interactionId).andThen(
    () => requestResolverModule.markRequestAsSent(
      walletInteraction.interactionId
    )
  ).andThen(
    () => deepLinkModule.deepLinkToWallet({
      sessionId: session.sessionId,
      request: base64urlEncode(walletInteraction),
      signature,
      publicKey,
      identity,
      origin: walletInteraction.metadata.origin,
      dAppDefinitionAddress: walletInteraction.metadata.dAppDefinitionAddress
    })
  ).mapErr(
    () => SdkError("FailedToSendDappRequest", walletInteraction.interactionId)
  );
  const sendToWallet = (walletInteraction, callbackFns) => ResultAsync8.combine([
    sessionModule.getCurrentSession().mapErr(
      (error) => SdkError(error.reason, walletInteraction.interactionId)
    ),
    identityModule.get("dApp").mapErr(
      (error) => SdkError(error.reason, walletInteraction.interactionId)
    )
  ]).andThen(
    ([session, dAppIdentity]) => identityModule.createSignature({
      dAppDefinitionAddress: walletInteraction.metadata.dAppDefinitionAddress,
      interactionId: walletInteraction.interactionId,
      origin: walletInteraction.metadata.origin,
      kind: "dApp"
    }).mapErr(
      (error) => SdkError(error.reason, walletInteraction.interactionId)
    ).andThen(
      ({ signature }) => sendWalletInteractionRequest({
        session,
        walletInteraction,
        signature,
        identity: dAppIdentity.ed25519.getPublicKey(),
        publicKey: dAppIdentity.x25519.getPublicKey()
      })
    ).andThen(
      () => requestResolverModule.waitForWalletResponse(
        walletInteraction.interactionId
      )
    ).map((requestItem) => requestItem.walletResponse)
  );
  const decryptWalletResponseData = (sharedSecretHex, value) => transformBufferToSealbox(Buffer.from(value, "hex")).asyncAndThen(
    ({ ciphertextAndAuthTag, iv }) => encryptionModule.decrypt(
      ciphertextAndAuthTag,
      Buffer.from(sharedSecretHex, "hex"),
      iv
    )
  ).andThen(
    (decrypted) => parseJSON(decrypted.toString("utf-8"))
  ).mapErr((error) => ({
    reason: "FailedToDecryptWalletResponseData",
    jsError: error
  }));
  return {
    id: "radix-connect-relay",
    isSupported: () => input.providers.environmentModule.isMobile(),
    send: sendToWallet,
    disconnect: () => {
    },
    destroy: () => {
      subscriptions.unsubscribe();
    }
  };
};

// src/modules/wallet-request/wallet-request-sdk.ts
import { ResultAsync as ResultAsync9, err as err9, errAsync as errAsync5, ok as ok11, okAsync as okAsync8 } from "neverthrow";
import { parse as parse2 } from "valibot";
import { v4 as uuidV43 } from "uuid";
var WalletRequestSdk = (input) => {
  const metadata = {
    version: 2,
    dAppDefinitionAddress: input.dAppDefinitionAddress,
    networkId: input.networkId,
    origin: input.origin || input.providers.environmentModule.globalThis?.location?.origin || ""
  };
  const interactionIdFactory = input.providers.interactionIdFactory ?? uuidV43;
  parse2(Metadata, metadata);
  const logger = input?.logger?.getSubLogger({ name: "WalletSdk" });
  const availableTransports = input.providers.transports;
  const requestInterceptorDefault = async (walletInteraction) => walletInteraction;
  const requestInterceptor = input.requestInterceptor ?? requestInterceptorDefault;
  logger?.debug({ metadata });
  const createWalletInteraction = (items, interactionId = interactionIdFactory()) => ({
    items,
    interactionId,
    metadata
  });
  const withInterceptor = (payload) => ResultAsync9.fromPromise(
    requestInterceptor(payload),
    (error) => SdkError("requestInterceptorError", payload.interactionId, error.message)
  );
  const getTransport = (interactionId) => {
    const transport = availableTransports.find(
      (transport2) => transport2.isSupported()
    );
    return transport ? ok11(transport) : err9({
      error: "SupportedTransportNotFound",
      interactionId,
      message: "No supported transport found"
    });
  };
  const sendInteraction = ({
    interactionId = uuidV43(),
    items
  }, callbackFns = {}) => withInterceptor({
    items,
    interactionId,
    metadata
  }).andThen(
    (walletInteraction) => getTransport(walletInteraction.interactionId).asyncAndThen(
      (transport) => transport.send(walletInteraction, callbackFns)
    ).andThen(
      (response) => response.discriminator === "failure" ? errAsync5(response) : okAsync8(response)
    )
  );
  return {
    sendInteraction,
    createWalletInteraction,
    getTransport
  };
};

// src/modules/wallet-request/wallet-request.ts
import {
  Subject as Subject6,
  Subscription as Subscription6,
  filter as filter6,
  firstValueFrom as firstValueFrom5,
  map as map5,
  switchMap as switchMap5,
  tap as tap3
} from "rxjs";
import { ResultAsync as ResultAsync14, err as err16, ok as ok14, okAsync as okAsync14 } from "neverthrow";

// src/modules/wallet-request/request-resolver/request-resolver.module.ts
import { err as err10, ok as ok12, okAsync as okAsync9, Result as Result7, ResultAsync as ResultAsync10 } from "neverthrow";
import { filter as filter4, firstValueFrom as firstValueFrom3, map as map4 } from "rxjs";
var RequestResolverModule = (input) => {
  const WAIT_TIME = 1e3;
  const { providers } = input;
  const { requestItemModule, storageModule, resolvers } = providers;
  const logger = input.logger?.getSubLogger({ name: "RequestResolverModule" });
  let shouldRun = true;
  const walletResponses = storageModule.getPartition("walletResponses");
  const getPendingRequests = () => requestItemModule.getPending().orElse((error) => {
    logger?.error({ method: "getPendingRequests", error });
    return ok12([]);
  }).andThen(
    (pendingItems) => pendingItems.length === 0 ? err10("PendingItemsNotFound") : ok12(pendingItems)
  );
  const getPendingRequestById = (interactionId) => requestItemModule.getById(interactionId).mapErr(() => SdkError("FailedToGetPendingItems", interactionId)).andThen(
    (pendingItem) => pendingItem?.status === "pending" ? ok12(pendingItem) : err10(SdkError("PendingItemNotFound", interactionId))
  );
  const getWalletResponseById = (interactionId) => requestItemModule.getById(interactionId).mapErr(() => SdkError("FailedToGetWalletResponse", interactionId)).map((item) => item?.walletResponse);
  const markRequestAsSent = (interactionId) => requestItemModule.patch(interactionId, { sentToWallet: true });
  const addWalletResponses = (responses) => Result7.combine(responses.map(validateWalletResponse)).asyncAndThen(
    () => walletResponses.setItems(
      responses.reduce(
        (acc, response) => {
          acc[response.interactionId] = response;
          return acc;
        },
        {}
      )
    )
  ).mapErr((error) => logger?.error({ method: "addWalletResponses", error }));
  const toRequestItemMap = (items) => items.reduce(
    (acc, item) => ({ ...acc, [item.interactionId]: item }),
    {}
  );
  const matchRequestItemToResponses = (requestItems) => {
    const ids = Object.keys(requestItems);
    return walletResponses.getItemList().map(
      (responses) => responses.filter((response) => ids.includes(response.interactionId))
    ).andThen(
      (responses) => responses.length ? ok12(responses) : err10("WalletResponsesNotFound")
    ).map(
      (responses) => responses.map((response) => ({
        walletInteractionResponse: response,
        requestItem: requestItems[response.interactionId]
      }))
    );
  };
  const resolveRequests = (unresolvedRequests) => ResultAsync10.combine(unresolvedRequests.map(resolveRequest)).map(
    () => unresolvedRequests
  );
  const cleanup = (requestItems) => {
    return okAsync9(void 0);
  };
  const resolveRequest = ({
    requestItem,
    walletInteractionResponse
  }) => {
    const { walletInteraction } = requestItem;
    return ResultAsync10.combine(
      resolvers.map(
        (resolver) => resolver({ walletInteraction, walletInteractionResponse, requestItem })
      )
    );
  };
  const waitForWalletResponse = (interactionId) => ResultAsync10.fromSafePromise(
    firstValueFrom3(
      requestItemModule.requests$.pipe(
        filter4(
          (items) => items.some(
            (item) => item.interactionId === interactionId && item.status !== "pending"
          )
        ),
        map4(
          (items) => items.find((item) => item.interactionId === interactionId)
        )
      )
    )
  );
  const requestResolverLoop = async () => {
    await getPendingRequests().map(toRequestItemMap).andThen(matchRequestItemToResponses).andThen(resolveRequests).map(
      (unresolvedRequests) => unresolvedRequests.map((item) => item.requestItem)
    ).andThen(cleanup);
    await new Promise((resolve) => setTimeout(resolve, WAIT_TIME));
    if (shouldRun) requestResolverLoop();
  };
  requestResolverLoop();
  return {
    waitForWalletResponse,
    getPendingRequestById,
    getPendingRequestIds: () => getPendingRequests().map(
      (items) => items.map((item) => item.interactionId)
    ),
    markRequestAsSent,
    addWalletResponses,
    getWalletResponseById,
    destroy: () => {
      shouldRun = false;
    }
  };
};

// src/modules/wallet-request/request-resolver/resolvers/data-response.ts
import { err as err11, okAsync as okAsync10 } from "neverthrow";
var matchResponse = (input) => {
  if (input.discriminator === "success") {
    if (input.items.discriminator === "authorizedRequest" || input.items.discriminator === "unauthorizedRequest") {
      return input.items;
    }
  }
};
var useDataRequestController = (getDataRequestController, interactionId) => (walletData) => {
  const maybeDataRequestController = getDataRequestController();
  if (!maybeDataRequestController) return okAsync10(walletData);
  return maybeDataRequestController(walletData).map(() => walletData).mapErr((error) => SdkError(error.error, interactionId, error.message));
};
var handleAuthorizedRequestResponse = ({
  requestItem,
  walletInteraction,
  walletData,
  stateModule
}) => stateModule.getState().andThen(
  (state) => stateModule.setState({
    loggedInTimestamp: requestItem.type === "loginRequest" ? Date.now().toString() : state.loggedInTimestamp,
    walletData,
    sharedData: transformWalletRequestToSharedData(
      walletInteraction,
      state.sharedData
    )
  }).andTee(() => stateModule.emitWalletData())
).orElse(
  () => err11(SdkError("FailedToUpdateRdtState", walletInteraction.interactionId))
);
var dataResponseResolver = (dependencies) => ({ walletInteraction, walletInteractionResponse, requestItem }) => {
  const dataResponse = matchResponse(walletInteractionResponse);
  if (!dataResponse) return okAsync10(void 0);
  const { requestItemModule, getDataRequestController, stateModule } = dependencies;
  const { interactionId } = walletInteraction;
  return transformWalletResponseToRdtWalletData(dataResponse).andThen(
    useDataRequestController(getDataRequestController, interactionId)
  ).andThen(
    (walletData) => dataResponse.discriminator === "authorizedRequest" ? handleAuthorizedRequestResponse({
      requestItem,
      walletInteraction,
      walletData,
      stateModule
    }).map(() => walletData) : okAsync10(walletData)
  ).andThen(
    (walletData) => requestItemModule.updateStatus({
      id: walletInteraction.interactionId,
      status: "success",
      walletData,
      walletResponse: walletInteractionResponse
    }).mapErr(
      (error) => SdkError(error.reason, walletInteraction.interactionId)
    )
  ).andTee(() => dependencies.updateConnectButtonStatus("success")).orElse((error) => {
    dependencies.updateConnectButtonStatus("fail");
    return err11(error);
  }).map(() => void 0);
};

// src/modules/wallet-request/request-resolver/resolvers/failed-response.ts
import { err as err12, okAsync as okAsync11 } from "neverthrow";
var matchResponse2 = (input) => {
  if (input.discriminator === "failure") {
    return input;
  }
};
var failedResponseResolver = (dependencies) => ({ walletInteraction, walletInteractionResponse }) => {
  const failedResponse = matchResponse2(walletInteractionResponse);
  if (!failedResponse) return okAsync11(void 0);
  const { interactionId } = walletInteraction;
  const { requestItemModule } = dependencies;
  return requestItemModule.updateStatus({
    id: interactionId,
    status: "fail",
    walletResponse: walletInteractionResponse
  }).orElse((error) => {
    dependencies.updateConnectButtonStatus("fail");
    return err12(SdkError(error.reason, interactionId));
  }).andTee(() => dependencies.updateConnectButtonStatus("fail")).map(() => void 0);
};

// src/modules/wallet-request/request-resolver/resolvers/send-transaction-response.ts
import { err as err14, okAsync as okAsync12 } from "neverthrow";

// src/modules/gateway/types.ts
var TransactionStatus = {
  Unknown: "Unknown",
  CommittedSuccess: "CommittedSuccess",
  CommittedFailure: "CommittedFailure",
  Pending: "Pending",
  Rejected: "Rejected"
};
var RadixNetwork = {
  Mainnet: 1,
  Stokenet: 2,
  Gilganet: 32,
  Enkinet: 33,
  Hammunet: 34,
  Nergalnet: 35,
  Mardunet: 36,
  Dumunet: 37
};
var RadixNetworkConfig = {
  Mainnet: {
    networkName: "Mainnet",
    networkId: RadixNetwork.Mainnet,
    gatewayUrl: "https://mainnet.radixdlt.com",
    dashboardUrl: "https://dashboard.radixdlt.com"
  },
  Stokenet: {
    networkName: "Stokenet",
    networkId: RadixNetwork.Stokenet,
    gatewayUrl: "https://babylon-stokenet-gateway.radixdlt.com",
    dashboardUrl: "https://stokenet-dashboard.radixdlt.com"
  },
  Mardunet: {
    networkName: "Mardunet",
    networkId: RadixNetwork.Mardunet,
    gatewayUrl: "https://mardunet-gateway.radixdlt.com",
    dashboardUrl: "https://mardunet-dashboard.rdx-works-main.extratools.works"
  },
  Gilganet: {
    networkName: "Gilganet",
    networkId: RadixNetwork.Gilganet,
    gatewayUrl: "https://gilganet-gateway.radixdlt.com",
    dashboardUrl: "https://gilganet-dashboard.rdx-works-main.extratools.works"
  },
  Enkinet: {
    networkName: "Enkinet",
    networkId: RadixNetwork.Enkinet,
    gatewayUrl: "https://enkinet-gateway.radixdlt.com",
    dashboardUrl: "https://enkinet-dashboard.rdx-works-main.extratools.works"
  },
  Hammunet: {
    networkName: "Hammunet",
    networkId: RadixNetwork.Hammunet,
    gatewayUrl: "https://hammunet-gateway.radixdlt.com",
    dashboardUrl: "https://hammunet-dashboard.rdx-works-main.extratools.works"
  },
  Dumunet: {
    networkName: "Dumunet",
    networkId: RadixNetwork.Dumunet,
    gatewayUrl: "https://dumunet-gateway.radixdlt.com",
    dashboardUrl: "https://dumunet-dashboard.rdx-works-main.extratools.works"
  }
};
var RadixNetworkConfigById = Object.values(RadixNetworkConfig).reduce(
  (prev, config2) => {
    prev[config2.networkId] = config2;
    return prev;
  },
  {}
);

// src/modules/gateway/helpers/generate-gateway-api-config.ts
var generateGatewayApiConfig = ({
  networkId,
  dAppDefinitionAddress,
  gatewayBaseUrl,
  applicationName,
  applicationVersion
}) => ({
  basePath: gatewayBaseUrl ?? RadixNetworkConfigById[networkId].gatewayUrl,
  applicationName: applicationName ?? "Unknown",
  applicationVersion: applicationVersion ?? "Unknown",
  applicationDappDefinitionAddress: dAppDefinitionAddress
});

// src/version.ts
var __VERSION__ = "2.2.1";

// src/modules/gateway/gateway.service.ts
var GatewayApiService = ({
  basePath,
  applicationName,
  applicationVersion,
  applicationDappDefinitionAddress
}) => {
  const fetchWithHeaders = (url, body) => fetchWrapper(
    fetch(`${basePath}${url}`, {
      method: "POST",
      body: JSON.stringify(body),
      headers: {
        "Content-Type": "application/json",
        "RDX-Client-Name": "@radixdlt/radix-dapp-toolkit",
        "RDX-Client-Version": __VERSION__,
        "RDX-App-Name": applicationName,
        "RDX-App-Version": applicationVersion,
        "RDX-App-Dapp-Definition": applicationDappDefinitionAddress
      }
    })
  ).map((response) => response.data);
  const getTransactionStatus = (transactionIntentHash) => fetchWithHeaders("/transaction/status", {
    intent_hash: transactionIntentHash
  });
  const getSubintentStatus = (subintentHash) => fetchWithHeaders("/transaction/subintent-status", {
    subintent_hash: subintentHash
  });
  const getEntityMetadataPage = (address) => fetchWithHeaders("/state/entity/page/metadata", { address });
  return {
    getSubintentStatus,
    getTransactionStatus,
    getEntityMetadataPage
  };
};

// src/modules/gateway/gateway.module.ts
import { ResultAsync as ResultAsync12, err as err13, ok as ok13 } from "neverthrow";
import { filter as filter5, first as first2, firstValueFrom as firstValueFrom4, switchMap as switchMap4 } from "rxjs";
var GatewayModule = (input) => {
  const logger = input.logger?.getSubLogger({ name: "GatewayModule" });
  const gatewayApi = input?.providers?.gatewayApiService ?? GatewayApiService(input.clientConfig);
  const poll = (hash2, apiCall, exponentialBackoff) => {
    return ResultAsync12.fromPromise(
      firstValueFrom4(
        exponentialBackoff.withBackoff$.pipe(
          switchMap4((result) => {
            if (result.isErr())
              return [
                err13(
                  SdkError("failedToPoll", "", void 0, {
                    error: result.error,
                    context: "GatewayModule.poll.retry.withBackoff$",
                    hash: hash2
                  })
                )
              ];
            logger?.debug(`Polling ${hash2} retry #${result.value + 1}`);
            return apiCall().orElse((response) => {
              if (response.reason === "FailedToFetch") {
                logger?.debug({
                  error: response,
                  context: "unexpected error, retrying"
                });
                exponentialBackoff.trigger.next();
                return ok13(void 0);
              }
              logger?.debug(response);
              return err13(
                SdkError("failedToPoll", "", void 0, {
                  error: response,
                  hash: hash2,
                  context: "GatewayModule.poll"
                })
              );
            });
          }),
          filter5(
            (result) => result.isOk() && !!result.value || result.isErr()
          ),
          first2()
        )
      ),
      (error) => error
    ).andThen((result) => result);
  };
  const pollTransactionStatus = (transactionIntentHash) => {
    const exponentialBackoff = ExponentialBackoff(input.retryConfig);
    return poll(
      transactionIntentHash,
      () => gatewayApi.getTransactionStatus(transactionIntentHash).map(({ status }) => {
        const completedStatus = /* @__PURE__ */ new Set([
          "CommittedSuccess",
          "CommittedFailure",
          "Rejected"
        ]);
        if (completedStatus.has(status)) return status;
        exponentialBackoff.trigger.next();
        return;
      }),
      exponentialBackoff
    );
  };
  const pollSubintentStatus = (subintentHash, expirationTimestamp) => {
    const exponentialBackoff = ExponentialBackoff({
      ...input.retryConfig,
      maxDelayTime: 6e4,
      timeout: new Date(expirationTimestamp * 1e3)
    });
    return {
      stop: exponentialBackoff.stop,
      result: poll(
        subintentHash,
        () => gatewayApi.getSubintentStatus(subintentHash).map(
          ({ subintent_status, finalized_at_transaction_intent_hash }) => {
            if (subintent_status === "CommittedSuccess") {
              return {
                subintentStatus: subintent_status,
                transactionIntentHash: finalized_at_transaction_intent_hash
              };
            }
            exponentialBackoff.trigger.next();
            return;
          }
        ),
        exponentialBackoff
      )
    };
  };
  return {
    pollSubintentStatus,
    pollTransactionStatus,
    gatewayApi,
    configuration: input.clientConfig
  };
};

// src/modules/wallet-request/request-resolver/resolvers/send-transaction-response.ts
var matchResponse3 = (input) => {
  if (input.discriminator === "success" && input.items.discriminator === "transaction") {
    return input.items;
  }
};
var determineFailedTransaction = (status) => {
  const failedTransactionStatus = [
    TransactionStatus.Rejected,
    TransactionStatus.CommittedFailure
  ];
  return failedTransactionStatus.includes(status);
};
var sendTransactionResponseResolver = (dependencies) => ({ walletInteraction, walletInteractionResponse }) => {
  const transactionResponse = matchResponse3(walletInteractionResponse);
  if (!transactionResponse) return okAsync12(void 0);
  const { gatewayModule, requestItemModule, updateConnectButtonStatus } = dependencies;
  const { interactionId } = walletInteraction;
  const {
    send: { transactionIntentHash }
  } = transactionResponse;
  return requestItemModule.getById(interactionId).mapErr(() => SdkError("FailedToGetItemWithInteractionId", interactionId)).andTee(
    () => requestItemModule.getAndRemoveSignal(interactionId)?.(
      transactionIntentHash
    )
  ).andThen(() => gatewayModule.pollTransactionStatus(transactionIntentHash)).andThen((status) => {
    const isFailedTransaction = determineFailedTransaction(status);
    const requestItemStatus = isFailedTransaction ? "fail" : "success";
    return requestItemModule.updateStatus({
      id: interactionId,
      status: requestItemStatus,
      transactionIntentHash,
      metadata: { transactionStatus: status },
      walletResponse: walletInteractionResponse
    }).orElse((error) => err14(SdkError(error.reason, interactionId))).andThen(() => {
      updateConnectButtonStatus(requestItemStatus);
      return okAsync12(void 0);
    }).orElse((error) => {
      updateConnectButtonStatus("fail");
      return err14(error);
    });
  }).map(() => void 0);
};

// src/modules/wallet-request/request-resolver/resolvers/pre-authorization-response.ts
import { err as err15, okAsync as okAsync13 } from "neverthrow";
var matchResponse4 = (input) => {
  if (input.discriminator === "success" && input.items.discriminator === "preAuthorizationResponse") {
    return input.items.response;
  }
};
var preAuthorizationResponseResolver = (dependencies) => ({ walletInteraction, walletInteractionResponse }) => {
  const response = matchResponse4(walletInteractionResponse);
  if (!response) return okAsync13(void 0);
  const { signedPartialTransaction, expirationTimestamp, subintentHash } = response;
  const { interactionId } = walletInteraction;
  const { requestItemModule } = dependencies;
  return requestItemModule.updateStatus({
    id: interactionId,
    status: RequestStatus.pendingCommit,
    transactionIntentHash: subintentHash,
    walletResponse: walletInteractionResponse,
    metadata: {
      signedPartialTransaction,
      expirationTimestamp,
      subintentHash
    }
  }).orElse((error) => {
    dependencies.updateConnectButtonStatus("fail");
    return err15(SdkError(error.reason, interactionId));
  }).andTee(() => dependencies.updateConnectButtonStatus("success")).map(() => void 0);
};

// src/modules/wallet-request/pre-authorization-request/preauthorization-polling-module.ts
import { ResultAsync as ResultAsync13 } from "neverthrow";
import { Subscription as Subscription5, tap as tap2 } from "rxjs";
var PreauthorizationPollingModule = (input) => {
  const logger = input?.logger?.getSubLogger({
    name: "PreauthorizationPolling"
  });
  const {
    providers: { requestItemModule, ignoreTransactionSubject }
  } = input;
  let shouldRun = true;
  const WAIT_TIME = 1e3;
  const activePolling = /* @__PURE__ */ new Map();
  const subscriptions = new Subscription5();
  subscriptions.add(
    ignoreTransactionSubject.pipe(
      tap2((id) => {
        if (activePolling.has(id)) {
          activePolling.get(id)?.stop();
          activePolling.delete(id);
        }
      })
    ).subscribe()
  );
  const preauthorizationPollingLoop = async () => {
    await requestItemModule.getPendingCommit().andThen((lookedUpItems) => {
      const timedOutItems = [];
      const lookupItems = [];
      lookedUpItems.forEach((item) => {
        if (Number(item.metadata?.expirationTimestamp) * 1e3 < Date.now()) {
          timedOutItems.push(item);
        } else {
          lookupItems.push(item);
        }
      });
      lookupItems.forEach((item) => {
        if (!activePolling.has(item.interactionId)) {
          const polling = input.providers.gatewayModule.pollSubintentStatus(
            item.transactionIntentHash,
            item.metadata?.expirationTimestamp
          );
          activePolling.set(item.interactionId, polling);
          polling.result.andTee(
            (result) => requestItemModule.updateStatus({
              id: item.interactionId,
              status: RequestStatus.success,
              metadata: {
                parentTransactionIntentHash: result.transactionIntentHash
              }
            })
          ).mapErr(() => {
            activePolling.delete(item.interactionId);
          });
        }
      });
      return ResultAsync13.combine(
        timedOutItems.map((item) => {
          if (activePolling.has(item.interactionId)) {
            activePolling.get(item.interactionId)?.stop();
            activePolling.delete(item.interactionId);
          }
          return requestItemModule.updateStatus({
            id: item.interactionId,
            status: RequestStatus.timedOut
          });
        })
      );
    });
    await new Promise((resolve) => setTimeout(resolve, WAIT_TIME));
    if (shouldRun) preauthorizationPollingLoop();
  };
  preauthorizationPollingLoop();
  return {
    destroy: () => {
      shouldRun = false;
      subscriptions.unsubscribe();
    }
  };
};

// src/modules/wallet-request/wallet-request.ts
var WalletRequestModule = (input) => {
  const logger = input.logger?.getSubLogger({ name: "WalletRequestModule" });
  const useCache = input.useCache;
  const networkId = input.networkId;
  const cancelRequestSubject = new Subject6();
  const ignoreTransactionSubject = new Subject6();
  const interactionStatusChangeSubject = new Subject6();
  const gatewayModule = input.providers.gatewayModule;
  const dAppDefinitionAddress = input.dAppDefinitionAddress;
  const stateModule = input.providers.stateModule;
  const storageModule = input.providers.storageModule;
  const dataRequestStateModule = input.providers.dataRequestStateModule ?? DataRequestStateModule({});
  const requestItemModule = input.providers.requestItemModule ?? RequestItemModule({
    logger,
    providers: {
      gatewayModule,
      storageModule: storageModule.getPartition("requests")
    }
  });
  const preauthorizationPollingModule = input.providers.preauthorizationPollingModule ?? PreauthorizationPollingModule({
    logger,
    providers: {
      gatewayModule,
      requestItemModule,
      ignoreTransactionSubject
    }
  });
  const updateConnectButtonStatus = (status) => {
    interactionStatusChangeSubject.next(status);
  };
  const requestResolverModule = input.providers.requestResolverModule ?? RequestResolverModule({
    logger,
    providers: {
      storageModule,
      requestItemModule,
      resolvers: [
        sendTransactionResponseResolver({
          gatewayModule,
          requestItemModule,
          updateConnectButtonStatus
        }),
        preAuthorizationResponseResolver({
          requestItemModule,
          updateConnectButtonStatus
        }),
        failedResponseResolver({
          requestItemModule,
          updateConnectButtonStatus
        }),
        dataResponseResolver({
          requestItemModule,
          getDataRequestController: () => dataRequestControl,
          stateModule,
          updateConnectButtonStatus
        })
      ]
    }
  });
  const transports = input.providers.transports ?? [
    ConnectorExtensionModule({
      logger,
      providers: {
        storageModule,
        requestResolverModule,
        environmentModule: input.providers.environmentModule
      }
    }),
    RadixConnectRelayModule({
      logger,
      walletUrl: "radixWallet://connect",
      baseUrl: "https://radix-connect-relay.radixdlt.com",
      dAppDefinitionAddress: input.dAppDefinitionAddress,
      providers: {
        storageModule,
        requestResolverModule,
        environmentModule: input.providers.environmentModule
      }
    })
  ];
  const walletRequestSdk = input.providers.walletRequestSdk ?? WalletRequestSdk({
    logger,
    networkId,
    origin: input.origin,
    dAppDefinitionAddress,
    requestInterceptor: input.requestInterceptor,
    providers: {
      transports,
      environmentModule: input.providers.environmentModule
    }
  });
  const cancelRequestControl = (id) => {
    const messageLifeCycleEvent = new Subject6();
    return {
      eventCallback: (event) => {
        messageLifeCycleEvent.next(event);
      },
      requestControl: ({ cancelRequest: cancelRequest2, getRequest }) => {
        firstValueFrom5(
          messageLifeCycleEvent.pipe(
            filter6((event) => event === "receivedByWallet"),
            map5(() => getRequest()),
            tap3((request) => {
              if (["transaction", "preAuthorizationRequest"].includes(
                request.items.discriminator
              ))
                requestItemModule.patch(id, { showCancel: false });
            })
          )
        );
        firstValueFrom5(
          cancelRequestSubject.pipe(
            filter6((requestItemId) => requestItemId === id),
            switchMap5(
              () => requestItemModule.cancel(id).andThen(() => cancelRequest2())
            )
          )
        );
        firstValueFrom5(
          ignoreTransactionSubject.pipe(
            filter6((requestItemId) => requestItemId === id),
            switchMap5(
              () => requestItemModule.updateStatus({
                id,
                status: "ignored"
              }).andThen(() => cancelRequest2())
            )
          )
        );
      }
    };
  };
  let challengeGeneratorFn = () => Promise.resolve("");
  let connectResponseCallback;
  let dataRequestControl;
  const isChallengeNeeded = (dataRequestState) => dataRequestState.accounts?.withProof || dataRequestState.persona?.withProof || dataRequestState.proofOfOwnership;
  const getChallenge = (dataRequestState) => {
    if (!isChallengeNeeded(dataRequestState)) return okAsync14(void 0);
    return ResultAsync14.fromPromise(
      challengeGeneratorFn(),
      () => SdkError("ChallengeGeneratorError", "", "failed to generate challenge")
    ).andThen(
      (challenge) => validateRolaChallenge(challenge) ? ok14(challenge) : err16(SdkError("ChallengeValidationError", "", "challenge is invalid"))
    );
  };
  const provideConnectResponseCallback = (fn) => {
    connectResponseCallback = (result) => fn(result);
  };
  const provideDataRequestControl = (fn) => {
    dataRequestControl = (walletData) => ResultAsync14.fromPromise(fn(walletData), () => ({
      error: "LoginRejectedByDapp",
      message: "Login rejected by dApp"
    }));
  };
  const sendRequestAndAwaitResponse = (walletInteraction) => {
    updateConnectButtonStatus("pending");
    return ResultAsync14.combine([
      walletRequestSdk.sendInteraction(
        walletInteraction,
        cancelRequestControl(walletInteraction.interactionId)
      ),
      requestResolverModule.waitForWalletResponse(
        walletInteraction.interactionId
      )
    ]).map(([_, response]) => response);
  };
  const sendOneTimeRequest = (...items) => sendRequest({
    dataRequestState: dataRequestStateModule.toDataRequestState(...items),
    isConnect: false,
    oneTime: true
  });
  const sendDataRequest = (walletInteraction) => sendRequestAndAwaitResponse(walletInteraction).andThen((response) => {
    logger?.debug({ method: "sendDataRequest.successResponse", response });
    return ok14(response.walletData);
  }).mapErr((error) => {
    logger?.debug({ method: "sendDataRequest.errorResponse", error });
    return error;
  });
  const getRdtState = () => stateModule.getState().mapErr(() => SdkError("FailedToReadRdtState", ""));
  const addNewRequest = (type, walletInteraction, isOneTimeRequest, signal) => requestItemModule.add(
    {
      type,
      walletInteraction,
      isOneTimeRequest
    },
    signal
  ).mapErr(
    ({ message }) => SdkError(
      "FailedToCreateRequestItem",
      walletInteraction.interactionId,
      message
    )
  );
  const sendPreAuthorizationRequest = (value) => {
    const walletInteraction = walletRequestSdk.createWalletInteraction({
      discriminator: "preAuthorizationRequest",
      request: value.toRequestItem()
    });
    return addNewRequest(
      "preAuthorizationRequest",
      walletInteraction,
      false,
      value.getOnSubmittedSuccessFn?.()
    ).andThen(() => sendRequestAndAwaitResponse(walletInteraction)).map(
      (requestItem) => ({
        ...requestItem.metadata
      })
    );
  };
  const sendRequest = ({
    isConnect,
    oneTime,
    dataRequestState
  }) => ResultAsync14.combine([
    getChallenge(dataRequestState),
    getRdtState()
  ]).andThen(
    ([challenge, state]) => toWalletRequest({
      dataRequestState,
      isConnect,
      oneTime,
      challenge,
      walletData: state.walletData
    }).mapErr(() => SdkError("FailedToTransformWalletRequest", "")).asyncAndThen((walletDataRequest) => {
      const walletInteraction = walletRequestSdk.createWalletInteraction(walletDataRequest);
      if (canDataRequestBeResolvedByRdtState(walletDataRequest, state) && useCache)
        return okAsync14(state.walletData);
      const isLoginRequest = !state.walletData.persona && walletDataRequest.discriminator === "authorizedRequest";
      const isProofOfOwnershipRequest = walletDataRequest.discriminator === "authorizedRequest" && !!walletDataRequest.proofOfOwnership;
      const requestType = isLoginRequest ? "loginRequest" : isProofOfOwnershipRequest ? "proofRequest" : "dataRequest";
      return addNewRequest(requestType, walletInteraction, oneTime).andThen(
        () => sendDataRequest(walletInteraction)
      );
    })
  );
  const setRequestDataState = (...items) => {
    dataRequestStateModule.setState(...items);
    return {
      sendRequest: () => sendRequest({
        dataRequestState: dataRequestStateModule.getState(),
        isConnect: false,
        oneTime: false
      })
    };
  };
  const updateSharedAccounts = () => stateModule.getState().mapErr((err18) => {
    logger?.error(err18);
    return {
      error: "FailedToReadRdtState",
      message: "failed to read rdt state",
      jsError: err18
    };
  }).andThen(
    (state) => sendRequest({
      dataRequestState: transformSharedDataToDataRequestState(
        state.sharedData
      ),
      isConnect: false,
      oneTime: false
    })
  );
  const subscriptions = new Subscription6();
  const sendTransaction = (value) => {
    const createTransactionRequest = () => {
      const walletInteraction = walletRequestSdk.createWalletInteraction({
        discriminator: "transaction",
        send: {
          blobs: value.blobs,
          transactionManifest: value.transactionManifest,
          message: value.message,
          version: value.version ?? 1
        }
      });
      return requestItemModule.add(
        {
          type: "sendTransaction",
          walletInteraction,
          isOneTimeRequest: false
        },
        value.onTransactionId
      ).mapErr(
        () => SdkError("FailedToAddRequestItem", walletInteraction.interactionId)
      ).map(() => walletInteraction);
    };
    return createTransactionRequest().andThen(
      (walletInteraction) => sendRequestAndAwaitResponse(walletInteraction)
    ).andThen(({ status, transactionIntentHash, metadata, interactionId }) => {
      const output2 = {
        transactionIntentHash,
        status: metadata.transactionStatus
      };
      return status === "success" ? ok14(output2) : err16(SdkError(output2.status, interactionId));
    });
  };
  const getTransport = () => transports.find((transport) => transport.isSupported());
  const getPendingRequests = () => requestItemModule.getPending();
  const cancelRequest = (id) => {
    cancelRequestSubject.next(id);
    requestItemModule.cancel(id);
    interactionStatusChangeSubject.next("fail");
    updateConnectButtonStatus("fail");
  };
  const ignoreTransaction = (id) => {
    ignoreTransactionSubject.next(id);
    requestItemModule.updateStatus({
      id,
      status: "ignored"
    });
    interactionStatusChangeSubject.next("fail");
  };
  const provideChallengeGenerator = (fn) => {
    challengeGeneratorFn = fn;
  };
  const disconnect = () => {
    requestItemModule.getPending().map((items) => {
      items.forEach((item) => {
        if (item.showCancel) cancelRequestSubject.next(item.interactionId);
      });
    });
    stateModule.reset();
    requestItemModule.clear();
    transports.forEach((transport) => transport?.disconnect());
  };
  const destroy = () => {
    stateModule.destroy();
    requestItemModule.destroy();
    requestResolverModule.destroy();
    preauthorizationPollingModule.destroy();
    input.providers.transports?.forEach((transport) => transport.destroy());
    subscriptions.unsubscribe();
  };
  return {
    sendRequest: (input2) => sendRequest({
      isConnect: input2.isConnect,
      oneTime: input2.oneTime,
      dataRequestState: dataRequestStateModule.getState()
    }).andThen((response) => {
      if (connectResponseCallback) connectResponseCallback(ok14(response));
      return ok14(response);
    }).orElse((error) => {
      if (connectResponseCallback) connectResponseCallback(err16(error));
      return err16(error);
    }),
    sendTransaction,
    sendPreAuthorizationRequest,
    cancelRequest,
    ignoreTransaction,
    requestItemModule,
    provideChallengeGenerator,
    provideDataRequestControl,
    provideConnectResponseCallback,
    sendOneTimeRequest,
    setRequestDataState,
    getPendingRequests,
    getTransport,
    updateSharedAccounts,
    dataRequestStateModule,
    interactionStatusChange$: interactionStatusChangeSubject.asObservable(),
    requestItems$: requestItemModule.requests$,
    disconnect,
    destroy
  };
};

// src/modules/wallet-request/pre-authorization-request/subintent-builder.ts
var SubintentRequestBuilder = () => {
  let state = {
    discriminator: "subintent",
    version: 1,
    manifestVersion: 2
  };
  let onSubmittedSuccessFn;
  const onSubmittedSuccess = (callback) => {
    onSubmittedSuccessFn = callback;
    return api;
  };
  const setExpiration = (type, value) => {
    state.expiration = type === "atTime" ? {
      discriminator: "expireAtTime",
      unixTimestampSeconds: value
    } : {
      discriminator: "expireAfterDelay",
      expireAfterSeconds: value
    };
    return api;
  };
  const addBlobs = (...blobs) => {
    state.blobs = blobs;
    return api;
  };
  const message = (message2) => {
    state.message = message2;
    return api;
  };
  const manifest = (value) => {
    state.subintentManifest = value;
    return { setExpiration };
  };
  const toRequestItem = () => state;
  const rawConfig = (rawConfig2) => {
    state = { ...rawConfig2, discriminator: "subintent" };
    return { toRequestItem };
  };
  const api = {
    addBlobs,
    message,
    toRequestItem,
    onSubmittedSuccess,
    getOnSubmittedSuccessFn: () => onSubmittedSuccessFn
  };
  return { manifest, rawConfig };
};

// src/modules/connect-button/connect-button-noop.module.ts
import { NEVER } from "rxjs";
var ConnectButtonNoopModule = () => {
  return {
    status$: NEVER,
    onConnect$: NEVER,
    onDisconnect$: NEVER,
    onUpdateSharedAccounts$: NEVER,
    onShowPopover$: NEVER,
    onCancelRequestItem$: NEVER,
    onLinkClick$: NEVER,
    setStatus: () => {
    },
    setMode: () => {
    },
    setTheme: () => {
    },
    setActiveTab: () => {
    },
    setIsMobile: () => {
    },
    setIsWalletLinked: () => {
    },
    setIsExtensionAvailable: () => {
    },
    setConnected: () => {
    },
    setLoggedInTimestamp: () => {
    },
    setRequestItems: () => {
    },
    setAccounts: () => {
    },
    setPersonaData: () => {
    },
    setPersonaLabel: () => {
    },
    setDappName: () => {
    },
    destroy: () => {
    },
    disconnect: () => {
    }
  };
};

// src/modules/connect-button/connect-button.module.ts
var ConnectButtonModule = (input) => {
  if (!input.providers.environmentModule.isBrowser()) {
    return ConnectButtonNoopModule();
  }
  import("./connect-button-CHA436HC.js");
  const logger = input?.logger?.getSubLogger({ name: "ConnectButtonModule" });
  const subjects = input.subjects || ConnectButtonSubjects({
    providers: { environmentModule: input.providers.environmentModule }
  });
  const dAppDefinitionAddress = input.dAppDefinitionAddress;
  const { baseUrl, accountsPath, transactionPath, subintentPath } = input.explorer ?? {
    baseUrl: RadixNetworkConfigById[input.networkId].dashboardUrl,
    transactionPath: "/transaction/",
    subintentPath: "/subintent/",
    accountsPath: "/account/"
  };
  const stateModule = input.providers.stateModule;
  const gatewayModule = input.providers.gatewayModule;
  const walletRequestModule = input.providers.walletRequestModule;
  const onConnectDefault = (done) => {
    done();
  };
  const onConnect = input.onConnect || onConnectDefault;
  const transport = walletRequestModule.getTransport();
  const getConnectButtonElement = () => document.querySelector("radix-connect-button");
  const subscriptions = new Subscription7();
  const onConnectButtonRender$ = fromEvent(input.providers.environmentModule.globalThis, "onConnectButtonRender");
  subscriptions.add(
    onConnectButtonRender$.pipe(
      map6(() => getConnectButtonElement()),
      filter7((element) => !!element),
      switchMap6((connectButtonElement) => {
        logger?.debug({ observable: `onConnectButtonRender$` });
        const onConnect$ = fromEvent(connectButtonElement, "onConnect").pipe(
          tap4(() => {
            onConnect((value) => subjects.onConnect.next(value));
          })
        );
        const onDisconnect$ = fromEvent(
          connectButtonElement,
          "onDisconnect"
        ).pipe(tap4(() => subjects.onDisconnect.next()));
        const onLinkClick$ = fromEvent(connectButtonElement, "onLinkClick").pipe(
          tap4((ev) => {
            subjects.onLinkClick.next(ev.detail);
          })
        );
        const onDestroy$ = fromEvent(connectButtonElement, "onDestroy").pipe(
          map6(() => {
            logger?.debug({ observable: `onDestroy$` });
            return true;
          })
        );
        const onCancelRequestItem$ = fromEvent(
          connectButtonElement,
          "onCancelRequestItem"
        ).pipe(
          tap4((event) => {
            const id = event.detail.id;
            logger?.debug({ method: "onCancelRequestItem", id });
            subjects.onCancelRequestItem.next(id);
          })
        );
        const onIgnoreTransactionItem$ = fromEvent(
          connectButtonElement,
          "onIgnoreTransactionItem"
        ).pipe(
          tap4((event) => {
            const id = event.detail.id;
            logger?.debug({
              method: "onIgnoreTransactionItem",
              id
            });
            subjects.onIgnoreTransactionItem.next(id);
          })
        );
        const onUpdateSharedAccounts$ = fromEvent(
          connectButtonElement,
          "onUpdateSharedAccounts"
        ).pipe(
          tap4(() => {
            logger?.debug(`onUpdateSharedAccounts`);
            subjects.onUpdateSharedAccounts.next();
          })
        );
        const onShowPopover$ = fromEvent(
          connectButtonElement,
          "onShowPopover"
        ).pipe(tap4(() => subjects.onShowPopover.next()));
        const isWalletLinked$ = subjects.isWalletLinked.pipe(
          tap4((value) => connectButtonElement.isWalletLinked = value)
        );
        const isExtensionAvailable$ = subjects.isExtensionAvailable.pipe(
          tap4((value) => connectButtonElement.isExtensionAvailable = value)
        );
        const status$ = subjects.status.pipe(
          tap4((value) => connectButtonElement.status = value)
        );
        const mode$ = subjects.mode.pipe(
          tap4((value) => connectButtonElement.mode = value)
        );
        const connected$ = subjects.connected.pipe(
          tap4((value) => connectButtonElement.connected = value)
        );
        const isMobile$ = subjects.isMobile.pipe(
          tap4((value) => connectButtonElement.isMobile = value)
        );
        const loggedInTimestamp$ = subjects.loggedInTimestamp.pipe(
          tap4((value) => connectButtonElement.loggedInTimestamp = value)
        );
        const activeTab$ = subjects.activeTab.pipe(
          tap4((value) => connectButtonElement.activeTab = value)
        );
        const requestItems$ = subjects.requestItems.pipe(
          tap4((items) => connectButtonElement.requestItems = items)
        );
        const showPopoverMenu$ = subjects.showPopoverMenu.pipe(
          tap4((value) => {
            value ? connectButtonElement.setAttribute("showPopoverMenu", "true") : connectButtonElement.removeAttribute("showPopoverMenu");
          })
        );
        const accounts$ = subjects.accounts.pipe(
          tap4((items) => connectButtonElement.accounts = items)
        );
        const personaData$ = subjects.personaData.pipe(
          tap4((items) => connectButtonElement.personaData = items)
        );
        const personaLabel$ = subjects.personaLabel.pipe(
          tap4((items) => connectButtonElement.personaLabel = items)
        );
        const dAppName$ = subjects.dAppName.pipe(
          tap4((value) => connectButtonElement.dAppName = value)
        );
        const theme$ = subjects.theme.pipe(
          tap4((value) => connectButtonElement.theme = value)
        );
        const connectButtonEvents$ = merge3(
          onConnect$,
          status$,
          theme$,
          mode$,
          connected$,
          showPopoverMenu$,
          requestItems$,
          loggedInTimestamp$,
          isMobile$,
          activeTab$,
          isWalletLinked$,
          isExtensionAvailable$,
          onDisconnect$,
          onCancelRequestItem$,
          onIgnoreTransactionItem$,
          accounts$,
          personaData$,
          personaLabel$,
          onUpdateSharedAccounts$,
          onShowPopover$,
          dAppName$,
          onLinkClick$
        ).pipe(map6(() => false));
        return merge3(connectButtonEvents$, onDestroy$).pipe(
          filter7((shouldDestroy) => !!shouldDestroy),
          first3(),
          finalize(() => {
            logger?.debug({ observable: `onConnectButtonRender$.finalize` });
          })
        );
      })
    ).subscribe()
  );
  subscriptions.add(
    (transport && transport.isAvailable$ || of3(true)).pipe(tap4((value) => subjects.isExtensionAvailable.next(value))).subscribe()
  );
  subscriptions.add(
    (transport && transport.isLinked$ || of3(true)).pipe(tap4((value) => subjects.isWalletLinked.next(value))).subscribe()
  );
  subscriptions.add(
    subjects.onLinkClick.pipe(
      tap4(({ type, data }) => {
        if (["account", "transaction", "subintent"].includes(type)) {
          if (!baseUrl || !window) return;
          const url = `${baseUrl}${type === "transaction" ? transactionPath : type === "subintent" ? subintentPath : accountsPath}${data}`;
          window.open(url);
        } else if (type === "setupGuide")
          window.open("https://wallet.radixdlt.com");
        else if (type === "getWallet") {
          window.open("https://app.radixdlt.com/qr-code");
        } else if (type === "showQrCode" && transport?.showQrCode)
          transport.showQrCode();
      })
    ).subscribe()
  );
  const connectButtonApi = {
    status$: subjects.status.asObservable(),
    onConnect$: subjects.onConnect.asObservable(),
    onDisconnect$: subjects.onDisconnect.asObservable(),
    onShowPopover$: subjects.onShowPopover.asObservable(),
    onUpdateSharedAccounts$: subjects.onUpdateSharedAccounts.asObservable(),
    onCancelRequestItem$: subjects.onCancelRequestItem.asObservable(),
    onIgnoreTransactionItem$: subjects.onIgnoreTransactionItem.asObservable(),
    onLinkClick$: subjects.onLinkClick.asObservable(),
    setTheme: (value) => subjects.theme.next(value),
    setMode: (value) => subjects.mode.next(value),
    setActiveTab: (value) => subjects.activeTab.next(value),
    setIsMobile: (value) => subjects.isMobile.next(value),
    setIsWalletLinked: (value) => subjects.isWalletLinked.next(value),
    setIsExtensionAvailable: (value) => subjects.isExtensionAvailable.next(value),
    setLoggedInTimestamp: (value) => subjects.loggedInTimestamp.next(value),
    setConnected: (value) => subjects.connected.next(value),
    setShowPopoverMenu: (value) => subjects.showPopoverMenu.next(value),
    setRequestItems: (items) => subjects.requestItems.next(items),
    setAccounts: (accounts2) => subjects.accounts.next(accounts2),
    setPersonaData: (personaData2) => subjects.personaData.next(personaData2),
    setPersonaLabel: (personaLabel) => subjects.personaLabel.next(personaLabel),
    setDappName: (dAppName) => subjects.dAppName.next(dAppName),
    disconnect: () => {
      subjects.connected.next(false);
      subjects.status.next("default");
    },
    destroy: () => {
      subscriptions.unsubscribe();
    }
  };
  const setPropsFromState = () => stateModule.getState().map((state) => {
    const { personaData: personaData2, accounts: accounts2, personaLabel, connected } = transformWalletDataToConnectButton(state.walletData);
    connectButtonApi.setLoggedInTimestamp(state.loggedInTimestamp);
    connectButtonApi.setAccounts(accounts2);
    connectButtonApi.setPersonaData(personaData2);
    connectButtonApi.setPersonaLabel(personaLabel);
    connectButtonApi.setConnected(connected);
  });
  subscriptions.add(
    stateModule.storage$.pipe(switchMap6(() => setPropsFromState())).subscribe()
  );
  subscriptions.add(
    subjects.onCancelRequestItem.pipe(
      tap4((value) => {
        walletRequestModule.cancelRequest(value);
      })
    ).subscribe()
  );
  subscriptions.add(
    subjects.onIgnoreTransactionItem.pipe(
      tap4((value) => {
        walletRequestModule.ignoreTransaction(value);
      })
    ).subscribe()
  );
  subscriptions.add(
    walletRequestModule.requestItems$.pipe(
      tap4((items) => {
        connectButtonApi.setRequestItems([...items].reverse());
      })
    ).subscribe()
  );
  subscriptions.add(
    subjects.onShowPopover.pipe(
      tap4(() => {
        walletRequestModule.getPendingRequests().map((pendingRequests) => {
          if (pendingRequests.length > 0) {
            subjects.activeTab.next("requests");
          }
        });
      })
    ).subscribe()
  );
  subscriptions.add(
    subjects.onConnect.pipe(
      switchMap6(
        () => stateModule.reset().andThen(
          () => walletRequestModule.sendRequest({
            isConnect: true,
            oneTime: false
          })
        ).map(
          () => input.providers.environmentModule.isMobile() && subjects.showPopoverMenu.next(false)
        )
      )
    ).subscribe()
  );
  subscriptions.add(
    subjects.onUpdateSharedAccounts.pipe(switchMap6(() => walletRequestModule.updateSharedAccounts())).subscribe()
  );
  subscriptions.add(
    subjects.onDisconnect.pipe(
      tap4(() => {
        subjects.connected.next(false);
        subjects.status.next("default");
        walletRequestModule.disconnect();
        if (input.onDisconnect) input.onDisconnect();
      })
    ).subscribe()
  );
  const setPendingOrDefault = () => walletRequestModule.getPendingRequests().andTee(
    (items) => subjects.status.next(items.length ? "pending" : "default")
  );
  subscriptions.add(
    walletRequestModule.interactionStatusChange$.pipe(
      mergeMap2(
        (newStatus) => of3(
          subjects.status.next(
            newStatus === "success" ? "success" : newStatus === "fail" ? "error" : "pending"
          )
        ).pipe(
          delay(2e3),
          concatMap(() => setPendingOrDefault())
        )
      )
    ).subscribe()
  );
  setPendingOrDefault();
  if (dAppDefinitionAddress) {
    gatewayModule.gatewayApi.getEntityMetadataPage(dAppDefinitionAddress).map(
      (details) => details?.items.find((item) => item.key === "name")?.value?.typed?.value
    ).map((dAppName) => {
      subjects.dAppName.next(dAppName ?? "Unnamed dApp");
    });
  }
  return connectButtonApi;
};

// src/modules/connect-button/types.ts
var ConnectButtonStatus = {
  pending: "pending",
  success: "success",
  default: "default",
  error: "error"
};

// src/modules/environment/environment.module.ts
var EnvironmentModule = () => {
  const isMobile = (userAgent) => {
    const ua = userAgent.toLowerCase();
    return /(mobi|ipod|phone|blackberry|opera mini|fennec|minimo|symbian|psp|nintendo ds|archos|skyfire|puffin|blazer|bolt|gobrowser|iris|maemo|semc|teashark|uzard|ipad|tablet|(android(?!.*mobile))|(windows(?!.*phone)(.*touch))|kindle|playbook|silk|(puffin(?!.*(IP|AP|WP))))/.test(
      ua
    );
  };
  const getNavigator = () => {
    return typeof navigator !== "undefined" ? navigator : void 0;
  };
  const isTMA = () => Object.keys(globalThis?.Telegram?.WebView?.initParams || {}).length > 0;
  return {
    get globalThis() {
      return globalThis;
    },
    isMobile: (userAgent) => {
      return isMobile(userAgent ?? getNavigator()?.userAgent ?? "");
    },
    isTMA,
    isBrowser: () => ![typeof window, typeof document].includes("undefined")
  };
};

// src/modules/storage/local-storage.module.ts
import { err as err17, ok as ok15, Result as Result8, ResultAsync as ResultAsync15 } from "neverthrow";
import { filter as filter8, fromEvent as fromEvent2, map as map7, merge as merge4, mergeMap as mergeMap3, of as of4 } from "rxjs";
var LocalStorageModule = (storageKey, {
  providers
}) => {
  const _window = providers.environmentModule.globalThis;
  const getDataAsync = () => new Promise((resolve, reject) => {
    try {
      resolve(localStorage.getItem(storageKey));
    } catch (error) {
      reject(error);
    }
  });
  const setDataAsync = (value) => new Promise((resolve, reject) => {
    try {
      localStorage.setItem(storageKey, value);
      resolve();
    } catch (error) {
      reject(error);
    }
  });
  const getItems = () => ResultAsync15.fromPromise(getDataAsync(), typedError2).andThen(
    (data) => data ? parseJSON(data) : ok15({})
  );
  const getState = () => ResultAsync15.fromPromise(getDataAsync(), typedError2).andThen(
    (data) => data ? parseJSON(data) : ok15(void 0)
  );
  const getItemById = (id) => ResultAsync15.fromPromise(getDataAsync(), typedError2).andThen((data) => data ? parseJSON(data) : ok15(void 0)).map((items) => items ? items[id] : void 0);
  const removeItemById = (id) => getItems().andThen((items) => {
    const { [id]: _, ...newItems } = items;
    return stringify(newItems).asyncAndThen((serialized) => {
      const result = ResultAsync15.fromPromise(
        setDataAsync(serialized),
        typedError2
      ).map(() => {
        _window.dispatchEvent(
          new StorageEvent("storage", {
            key: storageKey,
            oldValue: JSON.stringify(items),
            newValue: serialized
          })
        );
      });
      return result;
    });
  });
  const patchItem = (id, patch) => getItemById(id).andThen((item) => {
    return item ? setItems({ [id]: { ...item, ...patch } }) : err17(new Error("Item not found"));
  });
  const setItems = (item) => getItems().andThen(
    (data) => stringify({ ...data, ...item }).asyncAndThen((serialized) => {
      const result = ResultAsync15.fromPromise(
        setDataAsync(serialized),
        typedError2
      ).map(() => {
        _window.dispatchEvent(
          new StorageEvent("storage", {
            key: storageKey,
            oldValue: JSON.stringify(data),
            newValue: serialized
          })
        );
      });
      return result;
    })
  );
  const getItemList = () => getItems().map(Object.values);
  const setState = (newValue) => getState().andThen(
    (oldValue) => stringify({ ...oldValue ?? {}, ...newValue }).asyncAndThen(
      (serialized) => {
        const result = ResultAsync15.fromPromise(
          setDataAsync(serialized),
          typedError2
        ).map(() => {
          _window.dispatchEvent(
            new StorageEvent("storage", {
              key: storageKey,
              oldValue: JSON.stringify(oldValue),
              newValue: serialized
            })
          );
        });
        return result;
      }
    )
  );
  const patchState = (newValue) => getState().mapErr(() => ({ reason: "FailedToReadFromLocalStorage" })).andThen(
    (oldState) => oldState ? setState({ ...oldState, ...newValue }).mapErr(() => ({
      reason: "FailedToWriteToLocalStorage"
    })) : err17({ reason: "PatchingStateFailed" })
  );
  const getPartition = (partitionKey) => LocalStorageModule(`${storageKey}:${partitionKey}`, { providers });
  const storage$ = merge4(
    fromEvent2(providers.environmentModule.globalThis, "storage"),
    of4({ key: storageKey, newValue: null, oldValue: null })
  ).pipe(
    filter8((item) => item.key === storageKey),
    mergeMap3((event) => {
      const { key, newValue, oldValue } = event;
      if (!key) return [];
      const [rdt, accountDefinition, networkId, partition] = key.split(":");
      if (rdt === "rdt" && accountDefinition && networkId) {
        const oldValueResult = oldValue ? parseJSON(oldValue) : ok15(void 0);
        const newValueResult = newValue ? parseJSON(newValue) : ok15(void 0);
        return [
          Result8.combine([oldValueResult, newValueResult]).map(
            ([oldValue2, newValue2]) => ({
              key,
              partition,
              newValue: newValue2,
              oldValue: oldValue2
            })
          )
        ];
      }
      return [];
    }),
    filter8((result) => result.isOk()),
    map7(({ value }) => value)
  );
  const clear = () => ResultAsync15.fromPromise(
    new Promise((resolve) => resolve(localStorage.removeItem(storageKey))),
    typedError2
  );
  return {
    getItems,
    getItemById,
    removeItemById,
    patchItem,
    setItems,
    getItemList,
    getPartition,
    setState,
    getState,
    patchState,
    clear,
    storage$
  };
};

// src/radix-dapp-toolkit.ts
polyfills_default();
var RadixDappToolkit = (options) => {
  const dAppDefinitionAddress = options.dAppDefinitionAddress ?? options.applicationDappDefinitionAddress;
  const {
    networkId,
    providers,
    logger,
    onDisconnect,
    gatewayBaseUrl,
    applicationName,
    applicationVersion,
    useCache = true
  } = options || {};
  const environmentModule = providers?.environmentModule ?? EnvironmentModule();
  const storageModule = providers?.storageModule ?? LocalStorageModule(`rdt:${dAppDefinitionAddress}:${networkId}`, {
    providers: {
      environmentModule
    }
  });
  const stateModule = providers?.stateModule ?? StateModule({
    logger,
    providers: {
      storageModule: storageModule.getPartition("state")
    }
  });
  const gatewayModule = providers?.gatewayModule ?? GatewayModule({
    logger,
    clientConfig: generateGatewayApiConfig({
      networkId,
      dAppDefinitionAddress,
      gatewayBaseUrl,
      applicationName,
      applicationVersion
    })
  });
  const walletRequestModule = providers?.walletRequestModule ?? WalletRequestModule({
    logger,
    useCache,
    networkId,
    dAppDefinitionAddress,
    requestInterceptor: options.requestInterceptor,
    providers: {
      stateModule,
      storageModule,
      gatewayModule,
      environmentModule
    }
  });
  const connectButtonModule = providers?.connectButtonModule ?? ConnectButtonModule({
    logger,
    networkId,
    explorer: options.explorer,
    onDisconnect,
    dAppDefinitionAddress,
    providers: {
      stateModule,
      environmentModule,
      walletRequestModule,
      gatewayModule
    }
  });
  return {
    walletApi: {
      setRequestData: walletRequestModule.setRequestDataState,
      sendRequest: () => walletRequestModule.sendRequest({
        isConnect: false,
        oneTime: false
      }),
      provideChallengeGenerator: (fn) => walletRequestModule.provideChallengeGenerator(fn),
      dataRequestControl: (fn) => {
        walletRequestModule.provideDataRequestControl(fn);
      },
      provideConnectResponseCallback: walletRequestModule.provideConnectResponseCallback,
      updateSharedAccounts: () => walletRequestModule.updateSharedAccounts(),
      sendOneTimeRequest: walletRequestModule.sendOneTimeRequest,
      sendPreAuthorizationRequest: walletRequestModule.sendPreAuthorizationRequest,
      sendTransaction: (input) => walletRequestModule.sendTransaction(input),
      walletData$: stateModule.walletData$,
      getWalletData: stateModule.getWalletData
    },
    buttonApi: {
      setTheme: connectButtonModule.setTheme,
      setMode: connectButtonModule.setMode,
      status$: connectButtonModule.status$
    },
    gatewayApi: {
      clientConfig: gatewayModule.configuration
    },
    disconnect: () => {
      walletRequestModule.disconnect();
      connectButtonModule.disconnect();
      if (onDisconnect) onDisconnect();
    },
    destroy: () => {
      stateModule.destroy();
      walletRequestModule.destroy();
      connectButtonModule.destroy();
    }
  };
};
export {
  Account,
  AccountProof,
  AccountsRequestItem,
  AccountsRequestResponseItem,
  AnswerIO,
  AuthLoginRequestItem,
  AuthLoginRequestResponseItem,
  AuthLoginWithChallengeRequestItem,
  AuthLoginWithChallengeRequestResponseItem,
  AuthLoginWithoutChallengeRequestItem,
  AuthLoginWithoutChallengeRequestResponseItem,
  AuthRequestItem,
  AuthRequestResponseItem,
  AuthUsePersonaRequestItem,
  CancelRequest,
  CancelWalletInteractionExtensionInteraction,
  ConnectButtonModule,
  ConnectButtonStatus,
  ConnectButtonSubjects,
  ConnectorExtensionModule,
  ConnectorExtensionSubjects,
  Curve25519,
  DataRequestBuilder,
  DataRequestStateModule,
  DeepLinkModule,
  EnvironmentModule,
  ExpireAfterDelay,
  ExpireAtTime,
  ExponentialBackoff,
  ExtensionInteraction,
  GatewayApiService,
  GatewayModule,
  IceCandidateIO,
  IceCandidatePayloadIO,
  IceCandidatesIO,
  IdentityKind,
  IdentityModule,
  LocalStorageModule,
  Logger,
  LoginRequestResponseItem,
  MessageLifeCycleEvent,
  MessageLifeCycleExtensionStatusEvent,
  Metadata,
  NumberOfValues,
  OfferIO,
  OneTimeDataRequestBuilder,
  OpenPopupExtensionInteraction,
  Persona,
  PersonaDataName,
  PersonaDataNameVariant,
  PersonaDataRequestItem,
  PersonaDataRequestResponseItem,
  PersonaProof,
  Proof,
  ProofOfOwnershipRequestItem,
  ProofOfOwnershipResponseItem,
  RadixConnectRelayModule,
  RadixDappToolkit,
  RadixNetwork,
  RadixNetworkConfig,
  RadixNetworkConfigById,
  RdtState,
  RequestItemModule,
  ResetRequestItem,
  SendTransactionItem,
  SendTransactionResponseItem,
  SessionModule,
  SharedData,
  SignalingServerMessage,
  SignedChallenge,
  SignedChallengeAccount,
  SignedChallengePersona,
  Sources,
  StateModule,
  StatusExtensionInteraction,
  SubintentRequestBuilder,
  SubintentRequestItem,
  SubintentResponseItem,
  TransactionStatus,
  TransformRdtDataRequestToWalletRequestInput,
  WalletAuthorizedRequestItems,
  WalletAuthorizedRequestResponseItems,
  WalletData,
  WalletDataPersonaData,
  WalletDataPersonaDataEmailAddresses,
  WalletDataPersonaDataFullName,
  WalletDataPersonaDataPhoneNumbersAddresses,
  WalletInteraction,
  WalletInteractionExtensionInteraction,
  WalletInteractionFailureResponse,
  WalletInteractionItems,
  WalletInteractionResponse,
  WalletInteractionSuccessResponse,
  WalletPreAuthorizationItems,
  WalletPreAuthorizationResponseItems,
  WalletRequestItems,
  WalletRequestModule,
  WalletRequestResponseItems,
  WalletRequestSdk,
  WalletTransactionItems,
  WalletUnauthorizedRequestItems,
  blake2b,
  canDataRequestBeResolvedByRdtState,
  config,
  eventType,
  extensionInteractionDiscriminator,
  fetchWrapper,
  generateGatewayApiConfig,
  generateRolaChallenge,
  messageLifeCycleEventType,
  parseJSON,
  parseSignedChallenge,
  personaDataFullNameVariant,
  proofType,
  removeUndefined,
  stringify,
  toWalletRequest,
  transformRdtDataRequestToWalletRequest,
  transformSharedDataToDataRequestState,
  transformWalletDataToConnectButton,
  transformWalletRequestToSharedData,
  transformWalletResponseToRdtWalletData,
  typedError2 as typedError,
  unwrapObservable,
  validateRolaChallenge,
  validateWalletResponse,
  walletDataDefault
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
