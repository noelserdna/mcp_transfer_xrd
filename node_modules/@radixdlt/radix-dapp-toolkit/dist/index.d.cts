import * as neverthrow from 'neverthrow';
import { ResultAsync, Result } from 'neverthrow';
import * as rxjs from 'rxjs';
import { Subject, Observable, ReplaySubject, BehaviorSubject } from 'rxjs';
import { R as RadixButtonStatus, a as RadixButtonTheme, d as RequestItem, A as Account$1, c as RequestStatusTypes } from './index-Cc3enzrB.cjs';
import * as valibot from 'valibot';
import { InferOutput, ValiError } from 'valibot';
import { Logger as Logger$1 } from 'tslog';
import * as node_modules_tslog_dist_types_interfaces from 'node_modules/tslog/dist/types/interfaces';
import { Buffer } from 'buffer';

/**
 * Wallet schemas
 */
type Account = InferOutput<typeof Account>;
declare const Account: valibot.ObjectSchema<{
    readonly address: valibot.StringSchema<undefined>;
    readonly label: valibot.StringSchema<undefined>;
    readonly appearanceId: valibot.NumberSchema<undefined>;
}, undefined>;
type Proof = InferOutput<typeof Proof>;
declare const Proof: valibot.ObjectSchema<{
    readonly publicKey: valibot.StringSchema<undefined>;
    readonly signature: valibot.StringSchema<undefined>;
    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
}, undefined>;
type AccountProof = InferOutput<typeof AccountProof>;
declare const AccountProof: valibot.ObjectSchema<{
    readonly accountAddress: valibot.StringSchema<undefined>;
    readonly proof: valibot.ObjectSchema<{
        readonly publicKey: valibot.StringSchema<undefined>;
        readonly signature: valibot.StringSchema<undefined>;
        readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
    }, undefined>;
}, undefined>;
type PersonaProof = InferOutput<typeof PersonaProof>;
declare const PersonaProof: valibot.ObjectSchema<{
    readonly identityAddress: valibot.StringSchema<undefined>;
    readonly proof: valibot.ObjectSchema<{
        readonly publicKey: valibot.StringSchema<undefined>;
        readonly signature: valibot.StringSchema<undefined>;
        readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
    }, undefined>;
}, undefined>;
type ProofOfOwnershipRequestItem = InferOutput<typeof ProofOfOwnershipRequestItem>;
declare const ProofOfOwnershipRequestItem: valibot.ObjectSchema<{
    readonly challenge: valibot.StringSchema<undefined>;
    readonly identityAddress: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
    readonly accountAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
}, undefined>;
declare const ProofOfOwnershipResponseItem: valibot.ObjectSchema<{
    readonly challenge: valibot.StringSchema<undefined>;
    readonly proofs: valibot.ArraySchema<valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly accountAddress: valibot.StringSchema<undefined>;
        readonly proof: valibot.ObjectSchema<{
            readonly publicKey: valibot.StringSchema<undefined>;
            readonly signature: valibot.StringSchema<undefined>;
            readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
        }, undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly identityAddress: valibot.StringSchema<undefined>;
        readonly proof: valibot.ObjectSchema<{
            readonly publicKey: valibot.StringSchema<undefined>;
            readonly signature: valibot.StringSchema<undefined>;
            readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
        }, undefined>;
    }, undefined>], undefined>, undefined>;
}, undefined>;
type Persona = InferOutput<typeof Persona>;
declare const Persona: valibot.ObjectSchema<{
    readonly identityAddress: valibot.StringSchema<undefined>;
    readonly label: valibot.StringSchema<undefined>;
}, undefined>;
declare const personaDataFullNameVariant: {
    readonly western: "western";
    readonly eastern: "eastern";
};
type PersonaDataNameVariant = InferOutput<typeof PersonaDataNameVariant>;
declare const PersonaDataNameVariant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
type PersonaDataName = InferOutput<typeof PersonaDataName>;
declare const PersonaDataName: valibot.ObjectSchema<{
    readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
    readonly familyName: valibot.StringSchema<undefined>;
    readonly nickname: valibot.StringSchema<undefined>;
    readonly givenNames: valibot.StringSchema<undefined>;
}, undefined>;
type NumberOfValues = InferOutput<typeof NumberOfValues>;
declare const NumberOfValues: valibot.ObjectSchema<{
    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
}, undefined>;
type AccountsRequestItem = InferOutput<typeof AccountsRequestItem>;
declare const AccountsRequestItem: valibot.ObjectSchema<{
    readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
    readonly numberOfAccounts: valibot.ObjectSchema<{
        readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
        readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
    }, undefined>;
}, undefined>;
type AccountsRequestResponseItem = InferOutput<typeof AccountsRequestResponseItem>;
declare const AccountsRequestResponseItem: valibot.SchemaWithPipe<[valibot.ObjectSchema<{
    readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
        readonly address: valibot.StringSchema<undefined>;
        readonly label: valibot.StringSchema<undefined>;
        readonly appearanceId: valibot.NumberSchema<undefined>;
    }, undefined>, undefined>;
    readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
    readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
        readonly accountAddress: valibot.StringSchema<undefined>;
        readonly proof: valibot.ObjectSchema<{
            readonly publicKey: valibot.StringSchema<undefined>;
            readonly signature: valibot.StringSchema<undefined>;
            readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
        }, undefined>;
    }, undefined>, undefined>, never>;
}, undefined>, valibot.CheckAction<{
    accounts: {
        address: string;
        label: string;
        appearanceId: number;
    }[];
    challenge?: string | undefined;
    proofs?: {
        accountAddress: string;
        proof: {
            curve: "curve25519" | "secp256k1";
            publicKey: string;
            signature: string;
        };
    }[] | undefined;
}, "missing challenge or proofs">]>;
type PersonaDataRequestItem = InferOutput<typeof PersonaDataRequestItem>;
declare const PersonaDataRequestItem: valibot.ObjectSchema<{
    readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
    readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
        readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
    }, undefined>, never>;
    readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
        readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
    }, undefined>, never>;
}, undefined>;
type PersonaDataRequestResponseItem = InferOutput<typeof PersonaDataRequestResponseItem>;
declare const PersonaDataRequestResponseItem: valibot.ObjectSchema<{
    readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
        readonly familyName: valibot.StringSchema<undefined>;
        readonly nickname: valibot.StringSchema<undefined>;
        readonly givenNames: valibot.StringSchema<undefined>;
    }, undefined>, never>;
    readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
}, undefined>;
type ResetRequestItem = InferOutput<typeof ResetRequestItem>;
declare const ResetRequestItem: valibot.ObjectSchema<{
    readonly accounts: valibot.BooleanSchema<undefined>;
    readonly personaData: valibot.BooleanSchema<undefined>;
}, undefined>;
type LoginRequestResponseItem = InferOutput<typeof LoginRequestResponseItem>;
declare const LoginRequestResponseItem: valibot.SchemaWithPipe<[valibot.ObjectSchema<{
    readonly persona: valibot.ObjectSchema<{
        readonly identityAddress: valibot.StringSchema<undefined>;
        readonly label: valibot.StringSchema<undefined>;
    }, undefined>;
    readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
    readonly proof: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly publicKey: valibot.StringSchema<undefined>;
        readonly signature: valibot.StringSchema<undefined>;
        readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
    }, undefined>, never>;
}, undefined>, valibot.CheckAction<{
    persona: {
        label: string;
        identityAddress: string;
    };
    proof?: {
        curve: "curve25519" | "secp256k1";
        publicKey: string;
        signature: string;
    } | undefined;
    challenge?: string | undefined;
}, "missing challenge or proof">]>;
type WalletUnauthorizedRequestItems = InferOutput<typeof WalletUnauthorizedRequestItems>;
declare const WalletUnauthorizedRequestItems: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"unauthorizedRequest", undefined>;
    readonly oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly numberOfAccounts: valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>;
    }, undefined>, never>;
    readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
        readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
    }, undefined>, never>;
}, undefined>;
type AuthUsePersonaRequestItem = InferOutput<typeof AuthUsePersonaRequestItem>;
declare const AuthUsePersonaRequestItem: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
    readonly identityAddress: valibot.StringSchema<undefined>;
}, undefined>;
type AuthLoginWithoutChallengeRequestItem = InferOutput<typeof AuthLoginWithoutChallengeRequestItem>;
declare const AuthLoginWithoutChallengeRequestItem: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
}, undefined>;
type AuthLoginWithChallengeRequestItem = InferOutput<typeof AuthLoginWithChallengeRequestItem>;
declare const AuthLoginWithChallengeRequestItem: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
    readonly challenge: valibot.StringSchema<undefined>;
}, undefined>;
declare const AuthLoginRequestItem: valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
    readonly challenge: valibot.StringSchema<undefined>;
}, undefined>], undefined>;
declare const AuthRequestItem: valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
    readonly identityAddress: valibot.StringSchema<undefined>;
}, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
    readonly challenge: valibot.StringSchema<undefined>;
}, undefined>], undefined>], undefined>;
type WalletAuthorizedRequestItems = InferOutput<typeof WalletAuthorizedRequestItems>;
declare const WalletAuthorizedRequestItems: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"authorizedRequest", undefined>;
    readonly auth: valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
        readonly identityAddress: valibot.StringSchema<undefined>;
    }, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
        readonly challenge: valibot.StringSchema<undefined>;
    }, undefined>], undefined>], undefined>;
    readonly reset: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly accounts: valibot.BooleanSchema<undefined>;
        readonly personaData: valibot.BooleanSchema<undefined>;
    }, undefined>, never>;
    readonly proofOfOwnership: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.StringSchema<undefined>;
        readonly identityAddress: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly accountAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    }, undefined>, never>;
    readonly oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly numberOfAccounts: valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>;
    }, undefined>, never>;
    readonly ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly numberOfAccounts: valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>;
    }, undefined>, never>;
    readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
        readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
    }, undefined>, never>;
    readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
        readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
    }, undefined>, never>;
}, undefined>;
type WalletRequestItems = InferOutput<typeof WalletRequestItems>;
declare const WalletRequestItems: valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"unauthorizedRequest", undefined>;
    readonly oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly numberOfAccounts: valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>;
    }, undefined>, never>;
    readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
        readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
    }, undefined>, never>;
}, undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"authorizedRequest", undefined>;
    readonly auth: valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
        readonly identityAddress: valibot.StringSchema<undefined>;
    }, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
        readonly challenge: valibot.StringSchema<undefined>;
    }, undefined>], undefined>], undefined>;
    readonly reset: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly accounts: valibot.BooleanSchema<undefined>;
        readonly personaData: valibot.BooleanSchema<undefined>;
    }, undefined>, never>;
    readonly proofOfOwnership: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.StringSchema<undefined>;
        readonly identityAddress: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly accountAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    }, undefined>, never>;
    readonly oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly numberOfAccounts: valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>;
    }, undefined>, never>;
    readonly ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly numberOfAccounts: valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>;
    }, undefined>, never>;
    readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
        readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
    }, undefined>, never>;
    readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
        readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
    }, undefined>, never>;
}, undefined>], undefined>;
type SendTransactionItem = InferOutput<typeof SendTransactionItem>;
declare const SendTransactionItem: valibot.ObjectSchema<{
    readonly transactionManifest: valibot.StringSchema<undefined>;
    readonly version: valibot.NumberSchema<undefined>;
    readonly blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
}, undefined>;
type WalletTransactionItems = InferOutput<typeof WalletTransactionItems>;
declare const WalletTransactionItems: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"transaction", undefined>;
    readonly send: valibot.ObjectSchema<{
        readonly transactionManifest: valibot.StringSchema<undefined>;
        readonly version: valibot.NumberSchema<undefined>;
        readonly blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
    }, undefined>;
}, undefined>;
type SendTransactionResponseItem = InferOutput<typeof SendTransactionResponseItem>;
declare const SendTransactionResponseItem: valibot.ObjectSchema<{
    readonly transactionIntentHash: valibot.StringSchema<undefined>;
}, undefined>;
type WalletTransactionResponseItems = InferOutput<typeof WalletTransactionResponseItems>;
declare const WalletTransactionResponseItems: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"transaction", undefined>;
    readonly send: valibot.ObjectSchema<{
        readonly transactionIntentHash: valibot.StringSchema<undefined>;
    }, undefined>;
}, undefined>;
type CancelRequest = InferOutput<typeof CancelRequest>;
declare const CancelRequest: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"cancelRequest", undefined>;
}, undefined>;
type ExpireAtTime = InferOutput<typeof ExpireAtTime>;
declare const ExpireAtTime: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"expireAtTime", undefined>;
    readonly unixTimestampSeconds: valibot.NumberSchema<undefined>;
}, undefined>;
type ExpireAfterDelay = InferOutput<typeof ExpireAfterDelay>;
declare const ExpireAfterDelay: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"expireAfterDelay", undefined>;
    readonly expireAfterSeconds: valibot.NumberSchema<undefined>;
}, undefined>;
type SubintentRequestItem = InferOutput<typeof SubintentRequestItem>;
declare const SubintentRequestItem: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"subintent", undefined>;
    /**
     * Version of the message interface
     */
    readonly version: valibot.NumberSchema<undefined>;
    /**
     * Version of the Transaction Manifest
     */
    readonly manifestVersion: valibot.NumberSchema<undefined>;
    readonly subintentManifest: valibot.StringSchema<undefined>;
    readonly blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
    readonly expiration: valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"expireAtTime", undefined>;
        readonly unixTimestampSeconds: valibot.NumberSchema<undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"expireAfterDelay", undefined>;
        readonly expireAfterSeconds: valibot.NumberSchema<undefined>;
    }, undefined>], undefined>;
}, undefined>;
type SubintentResponseItem = InferOutput<typeof SubintentResponseItem>;
declare const SubintentResponseItem: valibot.ObjectSchema<{
    readonly expirationTimestamp: valibot.NumberSchema<undefined>;
    readonly subintentHash: valibot.StringSchema<undefined>;
    readonly signedPartialTransaction: valibot.StringSchema<undefined>;
}, undefined>;
type WalletPreAuthorizationItems = InferOutput<typeof WalletPreAuthorizationItems>;
declare const WalletPreAuthorizationItems: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"preAuthorizationRequest", undefined>;
    readonly request: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"subintent", undefined>;
        /**
         * Version of the message interface
         */
        readonly version: valibot.NumberSchema<undefined>;
        /**
         * Version of the Transaction Manifest
         */
        readonly manifestVersion: valibot.NumberSchema<undefined>;
        readonly subintentManifest: valibot.StringSchema<undefined>;
        readonly blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly expiration: valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"expireAtTime", undefined>;
            readonly unixTimestampSeconds: valibot.NumberSchema<undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"expireAfterDelay", undefined>;
            readonly expireAfterSeconds: valibot.NumberSchema<undefined>;
        }, undefined>], undefined>;
    }, undefined>, never>;
}, undefined>;
type WalletInteractionItems = InferOutput<typeof WalletInteractionItems>;
declare const WalletInteractionItems: valibot.UnionSchema<[valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"unauthorizedRequest", undefined>;
    readonly oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly numberOfAccounts: valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>;
    }, undefined>, never>;
    readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
        readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
    }, undefined>, never>;
}, undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"authorizedRequest", undefined>;
    readonly auth: valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
        readonly identityAddress: valibot.StringSchema<undefined>;
    }, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
        readonly challenge: valibot.StringSchema<undefined>;
    }, undefined>], undefined>], undefined>;
    readonly reset: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly accounts: valibot.BooleanSchema<undefined>;
        readonly personaData: valibot.BooleanSchema<undefined>;
    }, undefined>, never>;
    readonly proofOfOwnership: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.StringSchema<undefined>;
        readonly identityAddress: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly accountAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    }, undefined>, never>;
    readonly oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly numberOfAccounts: valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>;
    }, undefined>, never>;
    readonly ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly numberOfAccounts: valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>;
    }, undefined>, never>;
    readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
        readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
    }, undefined>, never>;
    readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
        readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
    }, undefined>, never>;
}, undefined>], undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"transaction", undefined>;
    readonly send: valibot.ObjectSchema<{
        readonly transactionManifest: valibot.StringSchema<undefined>;
        readonly version: valibot.NumberSchema<undefined>;
        readonly blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
    }, undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"cancelRequest", undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"preAuthorizationRequest", undefined>;
    readonly request: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"subintent", undefined>;
        /**
         * Version of the message interface
         */
        readonly version: valibot.NumberSchema<undefined>;
        /**
         * Version of the Transaction Manifest
         */
        readonly manifestVersion: valibot.NumberSchema<undefined>;
        readonly subintentManifest: valibot.StringSchema<undefined>;
        readonly blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly expiration: valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"expireAtTime", undefined>;
            readonly unixTimestampSeconds: valibot.NumberSchema<undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"expireAfterDelay", undefined>;
            readonly expireAfterSeconds: valibot.NumberSchema<undefined>;
        }, undefined>], undefined>;
    }, undefined>, never>;
}, undefined>], undefined>;
type Metadata = InferOutput<typeof Metadata>;
declare const Metadata: valibot.ObjectSchema<{
    readonly version: valibot.LiteralSchema<2, undefined>;
    readonly networkId: valibot.NumberSchema<undefined>;
    readonly dAppDefinitionAddress: valibot.StringSchema<undefined>;
    readonly origin: valibot.StringSchema<undefined>;
}, undefined>;
type WalletInteraction = InferOutput<typeof WalletInteraction>;
declare const WalletInteraction: valibot.ObjectSchema<{
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly metadata: valibot.ObjectSchema<{
        readonly version: valibot.LiteralSchema<2, undefined>;
        readonly networkId: valibot.NumberSchema<undefined>;
        readonly dAppDefinitionAddress: valibot.StringSchema<undefined>;
        readonly origin: valibot.StringSchema<undefined>;
    }, undefined>;
    readonly items: valibot.UnionSchema<[valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"unauthorizedRequest", undefined>;
        readonly oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly numberOfAccounts: valibot.ObjectSchema<{
                readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
            }, undefined>;
        }, undefined>, never>;
        readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
            readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
            }, undefined>, never>;
            readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
            }, undefined>, never>;
        }, undefined>, never>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"authorizedRequest", undefined>;
        readonly auth: valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
            readonly identityAddress: valibot.StringSchema<undefined>;
        }, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
            readonly challenge: valibot.StringSchema<undefined>;
        }, undefined>], undefined>], undefined>;
        readonly reset: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly accounts: valibot.BooleanSchema<undefined>;
            readonly personaData: valibot.BooleanSchema<undefined>;
        }, undefined>, never>;
        readonly proofOfOwnership: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly challenge: valibot.StringSchema<undefined>;
            readonly identityAddress: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly accountAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        }, undefined>, never>;
        readonly oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly numberOfAccounts: valibot.ObjectSchema<{
                readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
            }, undefined>;
        }, undefined>, never>;
        readonly ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly numberOfAccounts: valibot.ObjectSchema<{
                readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
            }, undefined>;
        }, undefined>, never>;
        readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
            readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
            }, undefined>, never>;
            readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
            }, undefined>, never>;
        }, undefined>, never>;
        readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
            readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
            }, undefined>, never>;
            readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
            }, undefined>, never>;
        }, undefined>, never>;
    }, undefined>], undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"transaction", undefined>;
        readonly send: valibot.ObjectSchema<{
            readonly transactionManifest: valibot.StringSchema<undefined>;
            readonly version: valibot.NumberSchema<undefined>;
            readonly blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
            readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        }, undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"cancelRequest", undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"preAuthorizationRequest", undefined>;
        readonly request: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"subintent", undefined>;
            /**
             * Version of the message interface
             */
            readonly version: valibot.NumberSchema<undefined>;
            /**
             * Version of the Transaction Manifest
             */
            readonly manifestVersion: valibot.NumberSchema<undefined>;
            readonly subintentManifest: valibot.StringSchema<undefined>;
            readonly blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
            readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly expiration: valibot.UnionSchema<[valibot.ObjectSchema<{
                readonly discriminator: valibot.LiteralSchema<"expireAtTime", undefined>;
                readonly unixTimestampSeconds: valibot.NumberSchema<undefined>;
            }, undefined>, valibot.ObjectSchema<{
                readonly discriminator: valibot.LiteralSchema<"expireAfterDelay", undefined>;
                readonly expireAfterSeconds: valibot.NumberSchema<undefined>;
            }, undefined>], undefined>;
        }, undefined>, never>;
    }, undefined>], undefined>;
}, undefined>;
type WalletUnauthorizedRequestResponseItems = InferOutput<typeof WalletUnauthorizedRequestResponseItems>;
declare const WalletUnauthorizedRequestResponseItems: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"unauthorizedRequest", undefined>;
    readonly oneTimeAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
        readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            readonly address: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
            readonly appearanceId: valibot.NumberSchema<undefined>;
        }, undefined>, undefined>;
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            readonly accountAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>, undefined>, never>;
    }, undefined>, valibot.CheckAction<{
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
        }[] | undefined;
    }, "missing challenge or proofs">]>, never>;
    readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
            readonly familyName: valibot.StringSchema<undefined>;
            readonly nickname: valibot.StringSchema<undefined>;
            readonly givenNames: valibot.StringSchema<undefined>;
        }, undefined>, never>;
        readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    }, undefined>, never>;
}, undefined>;
type AuthLoginWithoutChallengeRequestResponseItem = InferOutput<typeof AuthLoginWithoutChallengeRequestResponseItem>;
declare const AuthLoginWithoutChallengeRequestResponseItem: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
    readonly persona: valibot.ObjectSchema<{
        readonly identityAddress: valibot.StringSchema<undefined>;
        readonly label: valibot.StringSchema<undefined>;
    }, undefined>;
}, undefined>;
type AuthLoginWithChallengeRequestResponseItem = InferOutput<typeof AuthLoginWithChallengeRequestResponseItem>;
declare const AuthLoginWithChallengeRequestResponseItem: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
    readonly persona: valibot.ObjectSchema<{
        readonly identityAddress: valibot.StringSchema<undefined>;
        readonly label: valibot.StringSchema<undefined>;
    }, undefined>;
    readonly challenge: valibot.StringSchema<undefined>;
    readonly proof: valibot.ObjectSchema<{
        readonly publicKey: valibot.StringSchema<undefined>;
        readonly signature: valibot.StringSchema<undefined>;
        readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
    }, undefined>;
}, undefined>;
type WalletPreAuthorizationResponseItems = InferOutput<typeof WalletPreAuthorizationResponseItems>;
declare const WalletPreAuthorizationResponseItems: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"preAuthorizationResponse", undefined>;
    readonly response: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly expirationTimestamp: valibot.NumberSchema<undefined>;
        readonly subintentHash: valibot.StringSchema<undefined>;
        readonly signedPartialTransaction: valibot.StringSchema<undefined>;
    }, undefined>, never>;
}, undefined>;
declare const AuthLoginRequestResponseItem: valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
    readonly persona: valibot.ObjectSchema<{
        readonly identityAddress: valibot.StringSchema<undefined>;
        readonly label: valibot.StringSchema<undefined>;
    }, undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
    readonly persona: valibot.ObjectSchema<{
        readonly identityAddress: valibot.StringSchema<undefined>;
        readonly label: valibot.StringSchema<undefined>;
    }, undefined>;
    readonly challenge: valibot.StringSchema<undefined>;
    readonly proof: valibot.ObjectSchema<{
        readonly publicKey: valibot.StringSchema<undefined>;
        readonly signature: valibot.StringSchema<undefined>;
        readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
    }, undefined>;
}, undefined>], undefined>;
type AuthUsePersonaRequestResponseItem = InferOutput<typeof AuthUsePersonaRequestResponseItem>;
declare const AuthUsePersonaRequestResponseItem: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
    readonly persona: valibot.ObjectSchema<{
        readonly identityAddress: valibot.StringSchema<undefined>;
        readonly label: valibot.StringSchema<undefined>;
    }, undefined>;
}, undefined>;
type AuthRequestResponseItem = InferOutput<typeof AuthRequestResponseItem>;
declare const AuthRequestResponseItem: valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
    readonly persona: valibot.ObjectSchema<{
        readonly identityAddress: valibot.StringSchema<undefined>;
        readonly label: valibot.StringSchema<undefined>;
    }, undefined>;
}, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
    readonly persona: valibot.ObjectSchema<{
        readonly identityAddress: valibot.StringSchema<undefined>;
        readonly label: valibot.StringSchema<undefined>;
    }, undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
    readonly persona: valibot.ObjectSchema<{
        readonly identityAddress: valibot.StringSchema<undefined>;
        readonly label: valibot.StringSchema<undefined>;
    }, undefined>;
    readonly challenge: valibot.StringSchema<undefined>;
    readonly proof: valibot.ObjectSchema<{
        readonly publicKey: valibot.StringSchema<undefined>;
        readonly signature: valibot.StringSchema<undefined>;
        readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
    }, undefined>;
}, undefined>], undefined>], undefined>;
type WalletAuthorizedRequestResponseItems = InferOutput<typeof WalletAuthorizedRequestResponseItems>;
declare const WalletAuthorizedRequestResponseItems: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"authorizedRequest", undefined>;
    readonly auth: valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
        readonly persona: valibot.ObjectSchema<{
            readonly identityAddress: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
        }, undefined>;
    }, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
        readonly persona: valibot.ObjectSchema<{
            readonly identityAddress: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
        }, undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
        readonly persona: valibot.ObjectSchema<{
            readonly identityAddress: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
        }, undefined>;
        readonly challenge: valibot.StringSchema<undefined>;
        readonly proof: valibot.ObjectSchema<{
            readonly publicKey: valibot.StringSchema<undefined>;
            readonly signature: valibot.StringSchema<undefined>;
            readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
        }, undefined>;
    }, undefined>], undefined>], undefined>;
    readonly proofOfOwnership: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.StringSchema<undefined>;
        readonly proofs: valibot.ArraySchema<valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly accountAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly identityAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>], undefined>, undefined>;
    }, undefined>, never>;
    readonly oneTimeAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
        readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            readonly address: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
            readonly appearanceId: valibot.NumberSchema<undefined>;
        }, undefined>, undefined>;
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            readonly accountAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>, undefined>, never>;
    }, undefined>, valibot.CheckAction<{
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
        }[] | undefined;
    }, "missing challenge or proofs">]>, never>;
    readonly ongoingAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
        readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            readonly address: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
            readonly appearanceId: valibot.NumberSchema<undefined>;
        }, undefined>, undefined>;
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            readonly accountAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>, undefined>, never>;
    }, undefined>, valibot.CheckAction<{
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
        }[] | undefined;
    }, "missing challenge or proofs">]>, never>;
    readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
            readonly familyName: valibot.StringSchema<undefined>;
            readonly nickname: valibot.StringSchema<undefined>;
            readonly givenNames: valibot.StringSchema<undefined>;
        }, undefined>, never>;
        readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    }, undefined>, never>;
    readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
            readonly familyName: valibot.StringSchema<undefined>;
            readonly nickname: valibot.StringSchema<undefined>;
            readonly givenNames: valibot.StringSchema<undefined>;
        }, undefined>, never>;
        readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    }, undefined>, never>;
}, undefined>;
type WalletRequestResponseItems = InferOutput<typeof WalletRequestResponseItems>;
declare const WalletRequestResponseItems: valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"unauthorizedRequest", undefined>;
    readonly oneTimeAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
        readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            readonly address: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
            readonly appearanceId: valibot.NumberSchema<undefined>;
        }, undefined>, undefined>;
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            readonly accountAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>, undefined>, never>;
    }, undefined>, valibot.CheckAction<{
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
        }[] | undefined;
    }, "missing challenge or proofs">]>, never>;
    readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
            readonly familyName: valibot.StringSchema<undefined>;
            readonly nickname: valibot.StringSchema<undefined>;
            readonly givenNames: valibot.StringSchema<undefined>;
        }, undefined>, never>;
        readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    }, undefined>, never>;
}, undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"authorizedRequest", undefined>;
    readonly auth: valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
        readonly persona: valibot.ObjectSchema<{
            readonly identityAddress: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
        }, undefined>;
    }, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
        readonly persona: valibot.ObjectSchema<{
            readonly identityAddress: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
        }, undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
        readonly persona: valibot.ObjectSchema<{
            readonly identityAddress: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
        }, undefined>;
        readonly challenge: valibot.StringSchema<undefined>;
        readonly proof: valibot.ObjectSchema<{
            readonly publicKey: valibot.StringSchema<undefined>;
            readonly signature: valibot.StringSchema<undefined>;
            readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
        }, undefined>;
    }, undefined>], undefined>], undefined>;
    readonly proofOfOwnership: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.StringSchema<undefined>;
        readonly proofs: valibot.ArraySchema<valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly accountAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly identityAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>], undefined>, undefined>;
    }, undefined>, never>;
    readonly oneTimeAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
        readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            readonly address: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
            readonly appearanceId: valibot.NumberSchema<undefined>;
        }, undefined>, undefined>;
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            readonly accountAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>, undefined>, never>;
    }, undefined>, valibot.CheckAction<{
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
        }[] | undefined;
    }, "missing challenge or proofs">]>, never>;
    readonly ongoingAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
        readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            readonly address: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
            readonly appearanceId: valibot.NumberSchema<undefined>;
        }, undefined>, undefined>;
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            readonly accountAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>, undefined>, never>;
    }, undefined>, valibot.CheckAction<{
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
        }[] | undefined;
    }, "missing challenge or proofs">]>, never>;
    readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
            readonly familyName: valibot.StringSchema<undefined>;
            readonly nickname: valibot.StringSchema<undefined>;
            readonly givenNames: valibot.StringSchema<undefined>;
        }, undefined>, never>;
        readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    }, undefined>, never>;
    readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
            readonly familyName: valibot.StringSchema<undefined>;
            readonly nickname: valibot.StringSchema<undefined>;
            readonly givenNames: valibot.StringSchema<undefined>;
        }, undefined>, never>;
        readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    }, undefined>, never>;
}, undefined>], undefined>;
type WalletInteractionResponseItems = InferOutput<typeof WalletInteractionResponseItems>;
declare const WalletInteractionResponseItems: valibot.UnionSchema<[valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"unauthorizedRequest", undefined>;
    readonly oneTimeAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
        readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            readonly address: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
            readonly appearanceId: valibot.NumberSchema<undefined>;
        }, undefined>, undefined>;
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            readonly accountAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>, undefined>, never>;
    }, undefined>, valibot.CheckAction<{
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
        }[] | undefined;
    }, "missing challenge or proofs">]>, never>;
    readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
            readonly familyName: valibot.StringSchema<undefined>;
            readonly nickname: valibot.StringSchema<undefined>;
            readonly givenNames: valibot.StringSchema<undefined>;
        }, undefined>, never>;
        readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    }, undefined>, never>;
}, undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"authorizedRequest", undefined>;
    readonly auth: valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
        readonly persona: valibot.ObjectSchema<{
            readonly identityAddress: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
        }, undefined>;
    }, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
        readonly persona: valibot.ObjectSchema<{
            readonly identityAddress: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
        }, undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
        readonly persona: valibot.ObjectSchema<{
            readonly identityAddress: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
        }, undefined>;
        readonly challenge: valibot.StringSchema<undefined>;
        readonly proof: valibot.ObjectSchema<{
            readonly publicKey: valibot.StringSchema<undefined>;
            readonly signature: valibot.StringSchema<undefined>;
            readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
        }, undefined>;
    }, undefined>], undefined>], undefined>;
    readonly proofOfOwnership: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.StringSchema<undefined>;
        readonly proofs: valibot.ArraySchema<valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly accountAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly identityAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>], undefined>, undefined>;
    }, undefined>, never>;
    readonly oneTimeAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
        readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            readonly address: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
            readonly appearanceId: valibot.NumberSchema<undefined>;
        }, undefined>, undefined>;
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            readonly accountAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>, undefined>, never>;
    }, undefined>, valibot.CheckAction<{
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
        }[] | undefined;
    }, "missing challenge or proofs">]>, never>;
    readonly ongoingAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
        readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            readonly address: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
            readonly appearanceId: valibot.NumberSchema<undefined>;
        }, undefined>, undefined>;
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            readonly accountAddress: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>, undefined>, never>;
    }, undefined>, valibot.CheckAction<{
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
        }[] | undefined;
    }, "missing challenge or proofs">]>, never>;
    readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
            readonly familyName: valibot.StringSchema<undefined>;
            readonly nickname: valibot.StringSchema<undefined>;
            readonly givenNames: valibot.StringSchema<undefined>;
        }, undefined>, never>;
        readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    }, undefined>, never>;
    readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
            readonly familyName: valibot.StringSchema<undefined>;
            readonly nickname: valibot.StringSchema<undefined>;
            readonly givenNames: valibot.StringSchema<undefined>;
        }, undefined>, never>;
        readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    }, undefined>, never>;
}, undefined>], undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"transaction", undefined>;
    readonly send: valibot.ObjectSchema<{
        readonly transactionIntentHash: valibot.StringSchema<undefined>;
    }, undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"preAuthorizationResponse", undefined>;
    readonly response: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly expirationTimestamp: valibot.NumberSchema<undefined>;
        readonly subintentHash: valibot.StringSchema<undefined>;
        readonly signedPartialTransaction: valibot.StringSchema<undefined>;
    }, undefined>, never>;
}, undefined>], undefined>;
type WalletInteractionSuccessResponse = InferOutput<typeof WalletInteractionSuccessResponse>;
declare const WalletInteractionSuccessResponse: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"success", undefined>;
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly items: valibot.UnionSchema<[valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"unauthorizedRequest", undefined>;
        readonly oneTimeAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
            readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                readonly address: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
                readonly appearanceId: valibot.NumberSchema<undefined>;
            }, undefined>, undefined>;
            readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                readonly accountAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>, undefined>, never>;
        }, undefined>, valibot.CheckAction<{
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    curve: "curve25519" | "secp256k1";
                    publicKey: string;
                    signature: string;
                };
            }[] | undefined;
        }, "missing challenge or proofs">]>, never>;
        readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
                readonly familyName: valibot.StringSchema<undefined>;
                readonly nickname: valibot.StringSchema<undefined>;
                readonly givenNames: valibot.StringSchema<undefined>;
            }, undefined>, never>;
            readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
            readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        }, undefined>, never>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"authorizedRequest", undefined>;
        readonly auth: valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
            readonly persona: valibot.ObjectSchema<{
                readonly identityAddress: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
            }, undefined>;
        }, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
            readonly persona: valibot.ObjectSchema<{
                readonly identityAddress: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
            }, undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
            readonly persona: valibot.ObjectSchema<{
                readonly identityAddress: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
            }, undefined>;
            readonly challenge: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>], undefined>], undefined>;
        readonly proofOfOwnership: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly challenge: valibot.StringSchema<undefined>;
            readonly proofs: valibot.ArraySchema<valibot.UnionSchema<[valibot.ObjectSchema<{
                readonly accountAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>, valibot.ObjectSchema<{
                readonly identityAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>], undefined>, undefined>;
        }, undefined>, never>;
        readonly oneTimeAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
            readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                readonly address: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
                readonly appearanceId: valibot.NumberSchema<undefined>;
            }, undefined>, undefined>;
            readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                readonly accountAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>, undefined>, never>;
        }, undefined>, valibot.CheckAction<{
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    curve: "curve25519" | "secp256k1";
                    publicKey: string;
                    signature: string;
                };
            }[] | undefined;
        }, "missing challenge or proofs">]>, never>;
        readonly ongoingAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
            readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                readonly address: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
                readonly appearanceId: valibot.NumberSchema<undefined>;
            }, undefined>, undefined>;
            readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                readonly accountAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>, undefined>, never>;
        }, undefined>, valibot.CheckAction<{
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    curve: "curve25519" | "secp256k1";
                    publicKey: string;
                    signature: string;
                };
            }[] | undefined;
        }, "missing challenge or proofs">]>, never>;
        readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
                readonly familyName: valibot.StringSchema<undefined>;
                readonly nickname: valibot.StringSchema<undefined>;
                readonly givenNames: valibot.StringSchema<undefined>;
            }, undefined>, never>;
            readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
            readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        }, undefined>, never>;
        readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
                readonly familyName: valibot.StringSchema<undefined>;
                readonly nickname: valibot.StringSchema<undefined>;
                readonly givenNames: valibot.StringSchema<undefined>;
            }, undefined>, never>;
            readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
            readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        }, undefined>, never>;
    }, undefined>], undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"transaction", undefined>;
        readonly send: valibot.ObjectSchema<{
            readonly transactionIntentHash: valibot.StringSchema<undefined>;
        }, undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"preAuthorizationResponse", undefined>;
        readonly response: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly expirationTimestamp: valibot.NumberSchema<undefined>;
            readonly subintentHash: valibot.StringSchema<undefined>;
            readonly signedPartialTransaction: valibot.StringSchema<undefined>;
        }, undefined>, never>;
    }, undefined>], undefined>;
}, undefined>;
type WalletInteractionFailureResponse = InferOutput<typeof WalletInteractionFailureResponse>;
declare const WalletInteractionFailureResponse: valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"failure", undefined>;
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly error: valibot.StringSchema<undefined>;
    readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
}, undefined>;
type WalletInteractionResponse = InferOutput<typeof WalletInteractionResponse>;
declare const WalletInteractionResponse: valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"success", undefined>;
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly items: valibot.UnionSchema<[valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"unauthorizedRequest", undefined>;
        readonly oneTimeAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
            readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                readonly address: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
                readonly appearanceId: valibot.NumberSchema<undefined>;
            }, undefined>, undefined>;
            readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                readonly accountAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>, undefined>, never>;
        }, undefined>, valibot.CheckAction<{
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    curve: "curve25519" | "secp256k1";
                    publicKey: string;
                    signature: string;
                };
            }[] | undefined;
        }, "missing challenge or proofs">]>, never>;
        readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
                readonly familyName: valibot.StringSchema<undefined>;
                readonly nickname: valibot.StringSchema<undefined>;
                readonly givenNames: valibot.StringSchema<undefined>;
            }, undefined>, never>;
            readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
            readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        }, undefined>, never>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"authorizedRequest", undefined>;
        readonly auth: valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
            readonly persona: valibot.ObjectSchema<{
                readonly identityAddress: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
            }, undefined>;
        }, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
            readonly persona: valibot.ObjectSchema<{
                readonly identityAddress: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
            }, undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
            readonly persona: valibot.ObjectSchema<{
                readonly identityAddress: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
            }, undefined>;
            readonly challenge: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>], undefined>], undefined>;
        readonly proofOfOwnership: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly challenge: valibot.StringSchema<undefined>;
            readonly proofs: valibot.ArraySchema<valibot.UnionSchema<[valibot.ObjectSchema<{
                readonly accountAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>, valibot.ObjectSchema<{
                readonly identityAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>], undefined>, undefined>;
        }, undefined>, never>;
        readonly oneTimeAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
            readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                readonly address: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
                readonly appearanceId: valibot.NumberSchema<undefined>;
            }, undefined>, undefined>;
            readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                readonly accountAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>, undefined>, never>;
        }, undefined>, valibot.CheckAction<{
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    curve: "curve25519" | "secp256k1";
                    publicKey: string;
                    signature: string;
                };
            }[] | undefined;
        }, "missing challenge or proofs">]>, never>;
        readonly ongoingAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
            readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                readonly address: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
                readonly appearanceId: valibot.NumberSchema<undefined>;
            }, undefined>, undefined>;
            readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                readonly accountAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>, undefined>, never>;
        }, undefined>, valibot.CheckAction<{
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    curve: "curve25519" | "secp256k1";
                    publicKey: string;
                    signature: string;
                };
            }[] | undefined;
        }, "missing challenge or proofs">]>, never>;
        readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
                readonly familyName: valibot.StringSchema<undefined>;
                readonly nickname: valibot.StringSchema<undefined>;
                readonly givenNames: valibot.StringSchema<undefined>;
            }, undefined>, never>;
            readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
            readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        }, undefined>, never>;
        readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
                readonly familyName: valibot.StringSchema<undefined>;
                readonly nickname: valibot.StringSchema<undefined>;
                readonly givenNames: valibot.StringSchema<undefined>;
            }, undefined>, never>;
            readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
            readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        }, undefined>, never>;
    }, undefined>], undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"transaction", undefined>;
        readonly send: valibot.ObjectSchema<{
            readonly transactionIntentHash: valibot.StringSchema<undefined>;
        }, undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"preAuthorizationResponse", undefined>;
        readonly response: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly expirationTimestamp: valibot.NumberSchema<undefined>;
            readonly subintentHash: valibot.StringSchema<undefined>;
            readonly signedPartialTransaction: valibot.StringSchema<undefined>;
        }, undefined>, never>;
    }, undefined>], undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"failure", undefined>;
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly error: valibot.StringSchema<undefined>;
    readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
}, undefined>], undefined>;
declare const extensionInteractionDiscriminator: {
    readonly extensionStatus: "extensionStatus";
    readonly openPopup: "openPopup";
    readonly cancelWalletInteraction: "cancelWalletInteraction";
    readonly walletInteraction: "walletInteraction";
};
declare const StatusExtensionInteraction: valibot.ObjectSchema<{
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly discriminator: valibot.LiteralSchema<"extensionStatus", undefined>;
}, undefined>;
type StatusExtensionInteraction = InferOutput<typeof StatusExtensionInteraction>;
declare const OpenPopupExtensionInteraction: valibot.ObjectSchema<{
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly discriminator: valibot.LiteralSchema<"openPopup", undefined>;
}, undefined>;
type OpenPopupExtensionInteraction = InferOutput<typeof OpenPopupExtensionInteraction>;
type WalletInteractionExtensionInteraction = InferOutput<typeof WalletInteractionExtensionInteraction>;
declare const WalletInteractionExtensionInteraction: valibot.ObjectSchema<{
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly discriminator: valibot.LiteralSchema<"walletInteraction", undefined>;
    readonly interaction: valibot.ObjectSchema<{
        readonly interactionId: valibot.StringSchema<undefined>;
        readonly metadata: valibot.ObjectSchema<{
            readonly version: valibot.LiteralSchema<2, undefined>;
            readonly networkId: valibot.NumberSchema<undefined>;
            readonly dAppDefinitionAddress: valibot.StringSchema<undefined>;
            readonly origin: valibot.StringSchema<undefined>;
        }, undefined>;
        readonly items: valibot.UnionSchema<[valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"unauthorizedRequest", undefined>;
            readonly oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
                readonly numberOfAccounts: valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>;
            }, undefined>, never>;
            readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
                readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>, never>;
                readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>, never>;
            }, undefined>, never>;
        }, undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"authorizedRequest", undefined>;
            readonly auth: valibot.UnionSchema<[valibot.ObjectSchema<{
                readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
                readonly identityAddress: valibot.StringSchema<undefined>;
            }, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
                readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
            }, undefined>, valibot.ObjectSchema<{
                readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
                readonly challenge: valibot.StringSchema<undefined>;
            }, undefined>], undefined>], undefined>;
            readonly reset: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly accounts: valibot.BooleanSchema<undefined>;
                readonly personaData: valibot.BooleanSchema<undefined>;
            }, undefined>, never>;
            readonly proofOfOwnership: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly challenge: valibot.StringSchema<undefined>;
                readonly identityAddress: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
                readonly accountAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
            }, undefined>, never>;
            readonly oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
                readonly numberOfAccounts: valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>;
            }, undefined>, never>;
            readonly ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
                readonly numberOfAccounts: valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>;
            }, undefined>, never>;
            readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
                readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>, never>;
                readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>, never>;
            }, undefined>, never>;
            readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
                readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>, never>;
                readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>, never>;
            }, undefined>, never>;
        }, undefined>], undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"transaction", undefined>;
            readonly send: valibot.ObjectSchema<{
                readonly transactionManifest: valibot.StringSchema<undefined>;
                readonly version: valibot.NumberSchema<undefined>;
                readonly blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
                readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            }, undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"cancelRequest", undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"preAuthorizationRequest", undefined>;
            readonly request: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly discriminator: valibot.LiteralSchema<"subintent", undefined>;
                /**
                 * Version of the message interface
                 */
                readonly version: valibot.NumberSchema<undefined>;
                /**
                 * Version of the Transaction Manifest
                 */
                readonly manifestVersion: valibot.NumberSchema<undefined>;
                readonly subintentManifest: valibot.StringSchema<undefined>;
                readonly blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
                readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
                readonly expiration: valibot.UnionSchema<[valibot.ObjectSchema<{
                    readonly discriminator: valibot.LiteralSchema<"expireAtTime", undefined>;
                    readonly unixTimestampSeconds: valibot.NumberSchema<undefined>;
                }, undefined>, valibot.ObjectSchema<{
                    readonly discriminator: valibot.LiteralSchema<"expireAfterDelay", undefined>;
                    readonly expireAfterSeconds: valibot.NumberSchema<undefined>;
                }, undefined>], undefined>;
            }, undefined>, never>;
        }, undefined>], undefined>;
    }, undefined>;
    readonly sessionId: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
}, undefined>;
type CancelWalletInteractionExtensionInteraction = InferOutput<typeof CancelWalletInteractionExtensionInteraction>;
declare const CancelWalletInteractionExtensionInteraction: valibot.ObjectSchema<{
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly discriminator: valibot.LiteralSchema<"cancelWalletInteraction", undefined>;
    readonly metadata: valibot.ObjectSchema<{
        readonly version: valibot.LiteralSchema<2, undefined>;
        readonly networkId: valibot.NumberSchema<undefined>;
        readonly dAppDefinitionAddress: valibot.StringSchema<undefined>;
        readonly origin: valibot.StringSchema<undefined>;
    }, undefined>;
}, undefined>;
declare const ExtensionInteraction: valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly discriminator: valibot.LiteralSchema<"extensionStatus", undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly discriminator: valibot.LiteralSchema<"openPopup", undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly discriminator: valibot.LiteralSchema<"walletInteraction", undefined>;
    readonly interaction: valibot.ObjectSchema<{
        readonly interactionId: valibot.StringSchema<undefined>;
        readonly metadata: valibot.ObjectSchema<{
            readonly version: valibot.LiteralSchema<2, undefined>;
            readonly networkId: valibot.NumberSchema<undefined>;
            readonly dAppDefinitionAddress: valibot.StringSchema<undefined>;
            readonly origin: valibot.StringSchema<undefined>;
        }, undefined>;
        readonly items: valibot.UnionSchema<[valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"unauthorizedRequest", undefined>;
            readonly oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
                readonly numberOfAccounts: valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>;
            }, undefined>, never>;
            readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
                readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>, never>;
                readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>, never>;
            }, undefined>, never>;
        }, undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"authorizedRequest", undefined>;
            readonly auth: valibot.UnionSchema<[valibot.ObjectSchema<{
                readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
                readonly identityAddress: valibot.StringSchema<undefined>;
            }, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
                readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
            }, undefined>, valibot.ObjectSchema<{
                readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
                readonly challenge: valibot.StringSchema<undefined>;
            }, undefined>], undefined>], undefined>;
            readonly reset: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly accounts: valibot.BooleanSchema<undefined>;
                readonly personaData: valibot.BooleanSchema<undefined>;
            }, undefined>, never>;
            readonly proofOfOwnership: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly challenge: valibot.StringSchema<undefined>;
                readonly identityAddress: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
                readonly accountAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
            }, undefined>, never>;
            readonly oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
                readonly numberOfAccounts: valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>;
            }, undefined>, never>;
            readonly ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
                readonly numberOfAccounts: valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>;
            }, undefined>, never>;
            readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
                readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>, never>;
                readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>, never>;
            }, undefined>, never>;
            readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
                readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>, never>;
                readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                    readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                    readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
                }, undefined>, never>;
            }, undefined>, never>;
        }, undefined>], undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"transaction", undefined>;
            readonly send: valibot.ObjectSchema<{
                readonly transactionManifest: valibot.StringSchema<undefined>;
                readonly version: valibot.NumberSchema<undefined>;
                readonly blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
                readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            }, undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"cancelRequest", undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"preAuthorizationRequest", undefined>;
            readonly request: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly discriminator: valibot.LiteralSchema<"subintent", undefined>;
                /**
                 * Version of the message interface
                 */
                readonly version: valibot.NumberSchema<undefined>;
                /**
                 * Version of the Transaction Manifest
                 */
                readonly manifestVersion: valibot.NumberSchema<undefined>;
                readonly subintentManifest: valibot.StringSchema<undefined>;
                readonly blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
                readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
                readonly expiration: valibot.UnionSchema<[valibot.ObjectSchema<{
                    readonly discriminator: valibot.LiteralSchema<"expireAtTime", undefined>;
                    readonly unixTimestampSeconds: valibot.NumberSchema<undefined>;
                }, undefined>, valibot.ObjectSchema<{
                    readonly discriminator: valibot.LiteralSchema<"expireAfterDelay", undefined>;
                    readonly expireAfterSeconds: valibot.NumberSchema<undefined>;
                }, undefined>], undefined>;
            }, undefined>, never>;
        }, undefined>], undefined>;
    }, undefined>;
    readonly sessionId: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
}, undefined>, valibot.ObjectSchema<{
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly discriminator: valibot.LiteralSchema<"cancelWalletInteraction", undefined>;
    readonly metadata: valibot.ObjectSchema<{
        readonly version: valibot.LiteralSchema<2, undefined>;
        readonly networkId: valibot.NumberSchema<undefined>;
        readonly dAppDefinitionAddress: valibot.StringSchema<undefined>;
        readonly origin: valibot.StringSchema<undefined>;
    }, undefined>;
}, undefined>], undefined>;
type ExtensionInteraction = InferOutput<typeof ExtensionInteraction>;
declare const messageLifeCycleEventType: {
    readonly extensionStatus: "extensionStatus";
    readonly receivedByExtension: "receivedByExtension";
    readonly receivedByWallet: "receivedByWallet";
    readonly requestCancelSuccess: "requestCancelSuccess";
    readonly requestCancelFail: "requestCancelFail";
};
declare const MessageLifeCycleExtensionStatusEvent: valibot.ObjectSchema<{
    readonly eventType: valibot.LiteralSchema<"extensionStatus", undefined>;
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly isWalletLinked: valibot.BooleanSchema<undefined>;
    readonly isExtensionAvailable: valibot.BooleanSchema<undefined>;
    readonly canHandleSessions: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
}, undefined>;
type MessageLifeCycleExtensionStatusEvent = InferOutput<typeof MessageLifeCycleExtensionStatusEvent>;
declare const MessageLifeCycleEvent: valibot.ObjectSchema<{
    readonly eventType: valibot.UnionSchema<[valibot.LiteralSchema<"extensionStatus", undefined>, valibot.LiteralSchema<"receivedByExtension", undefined>, valibot.LiteralSchema<"receivedByWallet", undefined>, valibot.LiteralSchema<"requestCancelSuccess", undefined>, valibot.LiteralSchema<"requestCancelFail", undefined>], undefined>;
    readonly interactionId: valibot.StringSchema<undefined>;
}, undefined>;
type MessageLifeCycleEvent = InferOutput<typeof MessageLifeCycleEvent>;
type IncomingMessage = InferOutput<typeof IncomingMessage>;
declare const IncomingMessage: valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly eventType: valibot.UnionSchema<[valibot.LiteralSchema<"extensionStatus", undefined>, valibot.LiteralSchema<"receivedByExtension", undefined>, valibot.LiteralSchema<"receivedByWallet", undefined>, valibot.LiteralSchema<"requestCancelSuccess", undefined>, valibot.LiteralSchema<"requestCancelFail", undefined>], undefined>;
    readonly interactionId: valibot.StringSchema<undefined>;
}, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"success", undefined>;
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly items: valibot.UnionSchema<[valibot.UnionSchema<[valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"unauthorizedRequest", undefined>;
        readonly oneTimeAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
            readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                readonly address: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
                readonly appearanceId: valibot.NumberSchema<undefined>;
            }, undefined>, undefined>;
            readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                readonly accountAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>, undefined>, never>;
        }, undefined>, valibot.CheckAction<{
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    curve: "curve25519" | "secp256k1";
                    publicKey: string;
                    signature: string;
                };
            }[] | undefined;
        }, "missing challenge or proofs">]>, never>;
        readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
                readonly familyName: valibot.StringSchema<undefined>;
                readonly nickname: valibot.StringSchema<undefined>;
                readonly givenNames: valibot.StringSchema<undefined>;
            }, undefined>, never>;
            readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
            readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        }, undefined>, never>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"authorizedRequest", undefined>;
        readonly auth: valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"usePersona", undefined>;
            readonly persona: valibot.ObjectSchema<{
                readonly identityAddress: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
            }, undefined>;
        }, undefined>, valibot.UnionSchema<[valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"loginWithoutChallenge", undefined>;
            readonly persona: valibot.ObjectSchema<{
                readonly identityAddress: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
            }, undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly discriminator: valibot.LiteralSchema<"loginWithChallenge", undefined>;
            readonly persona: valibot.ObjectSchema<{
                readonly identityAddress: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
            }, undefined>;
            readonly challenge: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
        }, undefined>], undefined>], undefined>;
        readonly proofOfOwnership: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly challenge: valibot.StringSchema<undefined>;
            readonly proofs: valibot.ArraySchema<valibot.UnionSchema<[valibot.ObjectSchema<{
                readonly accountAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>, valibot.ObjectSchema<{
                readonly identityAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>], undefined>, undefined>;
        }, undefined>, never>;
        readonly oneTimeAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
            readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                readonly address: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
                readonly appearanceId: valibot.NumberSchema<undefined>;
            }, undefined>, undefined>;
            readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                readonly accountAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>, undefined>, never>;
        }, undefined>, valibot.CheckAction<{
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    curve: "curve25519" | "secp256k1";
                    publicKey: string;
                    signature: string;
                };
            }[] | undefined;
        }, "missing challenge or proofs">]>, never>;
        readonly ongoingAccounts: valibot.OptionalSchema<valibot.SchemaWithPipe<[valibot.ObjectSchema<{
            readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                readonly address: valibot.StringSchema<undefined>;
                readonly label: valibot.StringSchema<undefined>;
                readonly appearanceId: valibot.NumberSchema<undefined>;
            }, undefined>, undefined>;
            readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
            readonly proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                readonly accountAddress: valibot.StringSchema<undefined>;
                readonly proof: valibot.ObjectSchema<{
                    readonly publicKey: valibot.StringSchema<undefined>;
                    readonly signature: valibot.StringSchema<undefined>;
                    readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
                }, undefined>;
            }, undefined>, undefined>, never>;
        }, undefined>, valibot.CheckAction<{
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    curve: "curve25519" | "secp256k1";
                    publicKey: string;
                    signature: string;
                };
            }[] | undefined;
        }, "missing challenge or proofs">]>, never>;
        readonly oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
                readonly familyName: valibot.StringSchema<undefined>;
                readonly nickname: valibot.StringSchema<undefined>;
                readonly givenNames: valibot.StringSchema<undefined>;
            }, undefined>, never>;
            readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
            readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        }, undefined>, never>;
        readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly name: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
                readonly familyName: valibot.StringSchema<undefined>;
                readonly nickname: valibot.StringSchema<undefined>;
                readonly givenNames: valibot.StringSchema<undefined>;
            }, undefined>, never>;
            readonly emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
            readonly phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        }, undefined>, never>;
    }, undefined>], undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"transaction", undefined>;
        readonly send: valibot.ObjectSchema<{
            readonly transactionIntentHash: valibot.StringSchema<undefined>;
        }, undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly discriminator: valibot.LiteralSchema<"preAuthorizationResponse", undefined>;
        readonly response: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly expirationTimestamp: valibot.NumberSchema<undefined>;
            readonly subintentHash: valibot.StringSchema<undefined>;
            readonly signedPartialTransaction: valibot.StringSchema<undefined>;
        }, undefined>, never>;
    }, undefined>], undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly discriminator: valibot.LiteralSchema<"failure", undefined>;
    readonly interactionId: valibot.StringSchema<undefined>;
    readonly error: valibot.StringSchema<undefined>;
    readonly message: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
}, undefined>], undefined>], undefined>;
declare const eventType: {
    readonly outgoingMessage: "radix#chromeExtension#send";
    readonly incomingMessage: "radix#chromeExtension#receive";
};
type CallbackFns = {
    eventCallback: (messageEvent: MessageLifeCycleEvent['eventType']) => void;
    requestControl: (api: {
        cancelRequest: () => ResultAsync<'requestCancelSuccess', 'requestCancelFail'>;
        getRequest: () => WalletInteraction;
    }) => void;
};
declare const Types: valibot.UnionSchema<[valibot.LiteralSchema<"offer", undefined>, valibot.LiteralSchema<"answer", undefined>, valibot.LiteralSchema<"iceCandidate", undefined>, valibot.LiteralSchema<"iceCandidates", undefined>], undefined>;
declare const Sources: valibot.UnionSchema<[valibot.LiteralSchema<"wallet", undefined>, valibot.LiteralSchema<"extension", undefined>], undefined>;
declare const SignalingServerMessage: valibot.ObjectSchema<{
    readonly requestId: valibot.StringSchema<undefined>;
    readonly targetClientId: valibot.StringSchema<undefined>;
    readonly encryptedPayload: valibot.StringSchema<undefined>;
    readonly source: valibot.OptionalSchema<valibot.UnionSchema<[valibot.LiteralSchema<"wallet", undefined>, valibot.LiteralSchema<"extension", undefined>], undefined>, never>;
    readonly connectionId: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
}, undefined>;
declare const AnswerIO: valibot.ObjectSchema<{
    readonly method: valibot.LiteralSchema<"answer", undefined>;
    readonly payload: valibot.ObjectSchema<{
        readonly sdp: valibot.StringSchema<undefined>;
    }, undefined>;
    readonly requestId: valibot.StringSchema<undefined>;
    readonly targetClientId: valibot.StringSchema<undefined>;
    readonly encryptedPayload: valibot.StringSchema<undefined>;
    readonly source: valibot.OptionalSchema<valibot.UnionSchema<[valibot.LiteralSchema<"wallet", undefined>, valibot.LiteralSchema<"extension", undefined>], undefined>, never>;
    readonly connectionId: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
}, undefined>;
declare const OfferIO: valibot.ObjectSchema<{
    readonly method: valibot.LiteralSchema<"offer", undefined>;
    readonly payload: valibot.ObjectSchema<{
        readonly sdp: valibot.StringSchema<undefined>;
    }, undefined>;
    readonly requestId: valibot.StringSchema<undefined>;
    readonly targetClientId: valibot.StringSchema<undefined>;
    readonly encryptedPayload: valibot.StringSchema<undefined>;
    readonly source: valibot.OptionalSchema<valibot.UnionSchema<[valibot.LiteralSchema<"wallet", undefined>, valibot.LiteralSchema<"extension", undefined>], undefined>, never>;
    readonly connectionId: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
}, undefined>;
declare const IceCandidatePayloadIO: valibot.ObjectSchema<{
    readonly candidate: valibot.StringSchema<undefined>;
    readonly sdpMid: valibot.StringSchema<undefined>;
    readonly sdpMLineIndex: valibot.NumberSchema<undefined>;
}, undefined>;
declare const IceCandidateIO: valibot.ObjectSchema<{
    readonly method: valibot.LiteralSchema<"iceCandidate", undefined>;
    readonly payload: valibot.ObjectSchema<{
        readonly candidate: valibot.StringSchema<undefined>;
        readonly sdpMid: valibot.StringSchema<undefined>;
        readonly sdpMLineIndex: valibot.NumberSchema<undefined>;
    }, undefined>;
    readonly requestId: valibot.StringSchema<undefined>;
    readonly targetClientId: valibot.StringSchema<undefined>;
    readonly encryptedPayload: valibot.StringSchema<undefined>;
    readonly source: valibot.OptionalSchema<valibot.UnionSchema<[valibot.LiteralSchema<"wallet", undefined>, valibot.LiteralSchema<"extension", undefined>], undefined>, never>;
    readonly connectionId: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
}, undefined>;
declare const IceCandidatesIO: valibot.ObjectSchema<{
    readonly method: valibot.LiteralSchema<"iceCandidates", undefined>;
    readonly payload: valibot.ArraySchema<valibot.ObjectSchema<{
        readonly candidate: valibot.StringSchema<undefined>;
        readonly sdpMid: valibot.StringSchema<undefined>;
        readonly sdpMLineIndex: valibot.NumberSchema<undefined>;
    }, undefined>, undefined>;
    readonly requestId: valibot.StringSchema<undefined>;
    readonly targetClientId: valibot.StringSchema<undefined>;
    readonly encryptedPayload: valibot.StringSchema<undefined>;
    readonly source: valibot.OptionalSchema<valibot.UnionSchema<[valibot.LiteralSchema<"wallet", undefined>, valibot.LiteralSchema<"extension", undefined>], undefined>, never>;
    readonly connectionId: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
}, undefined>;
type Answer = InferOutput<typeof AnswerIO>;
type Offer = InferOutput<typeof OfferIO>;
type IceCandidate = InferOutput<typeof IceCandidateIO>;
type IceCandidates = InferOutput<typeof IceCandidatesIO>;
type MessagePayloadTypes = InferOutput<typeof Types>;
type MessageSources = InferOutput<typeof Sources>;
type DataTypes = Answer | IceCandidate | Offer | IceCandidates;
type Confirmation = {
    info: 'confirmation';
    requestId: DataTypes['requestId'];
};
type RemoteData<T extends DataTypes = DataTypes> = {
    info: 'remoteData';
    remoteClientId: string;
    requestId: T['requestId'];
    data: T;
};
type RemoteClientDisconnected = {
    info: 'remoteClientDisconnected';
    remoteClientId: string;
};
type RemoteClientJustConnected = {
    info: 'remoteClientJustConnected';
    remoteClientId: string;
};
type RemoteClientIsAlreadyConnected = {
    info: 'remoteClientIsAlreadyConnected';
    remoteClientId: string;
};
type MissingRemoteClientError = {
    info: 'missingRemoteClientError';
    requestId: DataTypes['requestId'];
};
type InvalidMessageError = {
    info: 'invalidMessageError';
    error: string;
    data: string;
};
type ValidationError = {
    info: 'validationError';
    requestId: DataTypes['requestId'];
    error: ValiError<any>;
};
type SignalingServerResponse = Confirmation | RemoteData | RemoteClientJustConnected | RemoteClientIsAlreadyConnected | RemoteClientDisconnected | MissingRemoteClientError | InvalidMessageError | ValidationError;
type SignalingServerErrorResponse = RemoteClientDisconnected | MissingRemoteClientError | InvalidMessageError | ValidationError;

type ExponentialBackoffInput = {
    multiplier?: number;
    maxDelayTime?: number;
    timeout?: number | Date;
    interval?: number;
};
type ExponentialBackoff = typeof ExponentialBackoff;
declare const ExponentialBackoff: ({ maxDelayTime, multiplier, timeout, interval, }?: ExponentialBackoffInput) => {
    trigger: Subject<void>;
    withBackoff$: Observable<Result<number, {
        error: string;
    }>>;
    stop: () => void;
};

declare const fetchWrapper: <R = unknown, ER = unknown>(fetchable: ReturnType<typeof fetch>) => ResultAsync<{
    status: number;
    data: R;
}, {
    status: number;
    error?: Error;
    reason: string;
    data?: ER;
}>;

type Logger = ReturnType<typeof Logger>;
declare const Logger: (minLevel?: number) => Logger$1<unknown>;

declare const parseJSON: <T = Record<string, any>>(text: string) => Result<T, Error>;

declare const removeUndefined: <T>(input: T) => neverthrow.Result<T, Error>;

declare const stringify: (input: any) => Result<string, Error>;

declare const typedError: <E = Error>(error: unknown) => E;

type SdkError = {
    error: string;
    interactionId: string;
    message?: string;
    jsError?: unknown;
};
declare const SdkError: (error: string, interactionId: string, message?: string, jsError?: unknown) => SdkError;

declare const unwrapObservable: (input: Observable<Result<any, SdkError>>) => ResultAsync<any, SdkError>;

declare const validateWalletResponse: (walletResponse: unknown) => Result<WalletInteractionResponse, SdkError>;

declare const generateRolaChallenge: () => string;

declare const validateRolaChallenge: (challenge?: unknown) => boolean;

type ConnectButtonStatus = (typeof ConnectButtonStatus)[keyof typeof ConnectButtonStatus];
declare const ConnectButtonStatus: {
    readonly pending: "pending";
    readonly success: "success";
    readonly default: "default";
    readonly error: "error";
};
type ConnectButtonModuleOutput = {
    status$: Observable<RadixButtonStatus>;
    onConnect$: Observable<{
        challenge: string;
    } | undefined>;
    onDisconnect$: Observable<void>;
    onUpdateSharedAccounts$: Observable<void>;
    onShowPopover$: Observable<void>;
    onCancelRequestItem$: Observable<string>;
    onLinkClick$: Observable<{
        type: 'account' | 'transaction' | 'showQrCode' | 'setupGuide' | 'getWallet' | 'subintent';
        data: string;
    }>;
    setMode: (value: 'light' | 'dark') => void;
    setTheme: (value: RadixButtonTheme) => void;
    setActiveTab: (value: 'sharing' | 'requests') => void;
    setIsMobile: (value: boolean) => void;
    setIsWalletLinked: (value: boolean) => void;
    setIsExtensionAvailable: (value: boolean) => void;
    setConnected: (value: boolean) => void;
    setLoggedInTimestamp: (value: string) => void;
    setRequestItems: (value: RequestItem[]) => void;
    setAccounts: (value: Account$1[]) => void;
    setPersonaData: (value: {
        value: string;
        field: string;
    }[]) => void;
    setPersonaLabel: (value: string) => void;
    setDappName: (value: string) => void;
    destroy: () => void;
    disconnect: () => void;
};

type EnvironmentModule = ReturnType<typeof EnvironmentModule>;
declare const EnvironmentModule: () => {
    readonly globalThis: typeof globalThis;
    isMobile: (userAgent?: string) => boolean;
    isTMA: () => boolean;
    isBrowser: () => boolean;
};

type ConnectButtonSubjects = ReturnType<typeof ConnectButtonSubjects>;
declare const ConnectButtonSubjects: (input: {
    providers: {
        environmentModule: EnvironmentModule;
    };
}) => {
    onConnect: Subject<{
        challenge: string;
    } | undefined>;
    onDisconnect: Subject<void>;
    onUpdateSharedAccounts: Subject<void>;
    connected: ReplaySubject<boolean>;
    requestItems: BehaviorSubject<RequestItem[]>;
    onCancelRequestItem: Subject<string>;
    onIgnoreTransactionItem: Subject<string>;
    accounts: BehaviorSubject<Account$1[]>;
    onShowPopover: Subject<void>;
    status: BehaviorSubject<ConnectButtonStatus>;
    loggedInTimestamp: BehaviorSubject<string>;
    isMobile: BehaviorSubject<boolean>;
    isWalletLinked: BehaviorSubject<boolean>;
    showPopoverMenu: BehaviorSubject<boolean>;
    isExtensionAvailable: BehaviorSubject<boolean>;
    fullWidth: BehaviorSubject<boolean>;
    activeTab: BehaviorSubject<"sharing" | "requests">;
    mode: BehaviorSubject<"light" | "dark">;
    theme: BehaviorSubject<"radix-blue" | "black" | "white-with-outline" | "white" | "custom">;
    avatarUrl: BehaviorSubject<string>;
    personaLabel: BehaviorSubject<string>;
    personaData: BehaviorSubject<{
        value: string;
        field: string;
    }[]>;
    dAppName: BehaviorSubject<string>;
    onLinkClick: Subject<{
        type: 'account' | 'transaction' | 'setupGuide' | 'showQrCode' | 'getWallet' | 'subintent';
        data: string;
    }>;
};

type KeyPairProvider = (privateKeyHex?: string) => {
    getPrivateKey: () => string;
    x25519: {
        getPublicKey: () => string;
        calculateSharedSecret: (publicKeyHex: string, dAppDefinitionAddress: string) => Result<string, Error>;
    };
    ed25519: {
        getPublicKey: () => string;
        sign: (messageHex: string) => Result<string, Error>;
    };
};
type Curve25519 = ReturnType<typeof Curve25519>;
declare const Curve25519: KeyPairProvider;

declare const blake2b: (input: Buffer) => Result<Buffer, Error>;

type AccountsRequestBuilder = {
    atLeast: (n: number) => AccountsRequestBuilder;
    exactly: (n: number) => AccountsRequestBuilder;
    withProof: (value?: boolean) => AccountsRequestBuilder;
    reset: (value?: boolean) => AccountsRequestBuilder;
};
type OneTimeAccountsRequestBuilder = {
    atLeast: (n: number) => OneTimeAccountsRequestBuilder;
    exactly: (n: number) => OneTimeAccountsRequestBuilder;
    withProof: (value?: boolean) => OneTimeAccountsRequestBuilder;
};
type AccountsDataRequest = InferOutput<typeof AccountsDataRequestSchema>;
declare const AccountsDataRequestSchema: valibot.ObjectSchema<{
    readonly numberOfAccounts: valibot.ObjectSchema<{
        readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
        readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
    }, undefined>;
    readonly withProof: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
    readonly reset: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
}, undefined>;

type PersonaRequestBuilder = {
    withProof: (value?: boolean) => PersonaRequestBuilder;
};
type PersonaRequest = InferOutput<typeof schema$1>;
declare const schema$1: valibot.ObjectSchema<{
    readonly withProof: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
}, undefined>;

type PersonaDataRequestBuilder = {
    fullName: (value?: boolean) => PersonaDataRequestBuilder;
    emailAddresses: (value?: boolean) => PersonaDataRequestBuilder;
    phoneNumbers: (value?: boolean) => PersonaDataRequestBuilder;
    reset: (value?: boolean) => PersonaDataRequestBuilder;
};
type OneTimePersonaDataRequestBuilder = {
    fullName: (value?: boolean) => PersonaDataRequestBuilder;
    emailAddresses: (value?: boolean) => PersonaDataRequestBuilder;
    phoneNumbers: (value?: boolean) => PersonaDataRequestBuilder;
};
type PersonaDataRequest = InferOutput<typeof PersonaDataRequestSchema>;
declare const PersonaDataRequestSchema: Omit<valibot.ObjectSchema<{
    readonly fullName: valibot.BooleanSchema<undefined>;
    readonly emailAddresses: valibot.ObjectSchema<{
        readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
        readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
    }, undefined>;
    readonly phoneNumbers: valibot.ObjectSchema<{
        readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
        readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
    }, undefined>;
    readonly reset: valibot.BooleanSchema<undefined>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly fullName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
        readonly emailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly phoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly reset: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
    };
    readonly _run: (dataset: valibot.Dataset<unknown, never>, config: valibot.Config<valibot.BaseIssue<unknown>>) => valibot.Dataset<{
        emailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        phoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        reset?: boolean | undefined;
        fullName?: boolean | undefined;
    }, valibot.NumberIssue | valibot.ObjectIssue | valibot.LiteralIssue | valibot.UnionIssue<valibot.LiteralIssue> | valibot.MinValueIssue<number, 0> | valibot.BooleanIssue>;
    readonly _types?: {
        readonly input: {
            emailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            phoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            reset?: boolean | undefined;
            fullName?: boolean | undefined;
        };
        readonly output: {
            emailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            phoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            reset?: boolean | undefined;
            fullName?: boolean | undefined;
        };
        readonly issue: valibot.NumberIssue | valibot.ObjectIssue | valibot.LiteralIssue | valibot.UnionIssue<valibot.LiteralIssue> | valibot.MinValueIssue<number, 0> | valibot.BooleanIssue;
    } | undefined;
};

type ProofOfOwnershipRequestBuilder = {
    accounts: (value: string[]) => ProofOfOwnershipRequestBuilder;
    identity: (value: string) => ProofOfOwnershipRequestBuilder;
};
type ProofOfOwnershipRequest = InferOutput<typeof schema>;
declare const schema: valibot.ObjectSchema<{
    readonly accountAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
    readonly identityAddress: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
}, undefined>;

type DataRequestBuilderItem = AccountsRequestBuilder | PersonaDataRequestBuilder | PersonaRequestBuilder | ConfigRequestBuilder;
type OneTimeDataRequestBuilderItem = OneTimeAccountsRequestBuilder | OneTimePersonaDataRequestBuilder | ProofOfOwnershipRequestBuilder;
type DataRequestState = Partial<{
    accounts: AccountsDataRequest;
    personaData: PersonaDataRequest;
    persona: PersonaRequest;
    proofOfOwnership: ProofOfOwnershipRequest;
}>;
type ConfigRequestBuilder = {};
declare const config: (data: DataRequestState) => {
    _toObject: () => {
        accounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            reset?: boolean | undefined;
            withProof?: boolean | undefined;
        } | undefined;
        personaData?: {
            emailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            phoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            reset?: boolean | undefined;
            fullName?: boolean | undefined;
        } | undefined;
        persona?: {
            withProof?: boolean | undefined;
        } | undefined;
        proofOfOwnership?: {
            identityAddress?: string | undefined;
            accountAddresses?: string[] | undefined;
        } | undefined;
    };
};
type DataRequestBuilder = {
    accounts: () => AccountsRequestBuilder;
    personaData: (input?: PersonaDataRequest) => PersonaDataRequestBuilder;
    persona: (input?: PersonaRequest) => PersonaRequestBuilder;
    config: (input: DataRequestState) => ConfigRequestBuilder;
};
declare const DataRequestBuilder: DataRequestBuilder;
type OneTimeDataRequestBuilder = {
    accounts: () => OneTimeAccountsRequestBuilder;
    personaData: (input?: PersonaDataRequest) => OneTimePersonaDataRequestBuilder;
    proofOfOwnership: () => ProofOfOwnershipRequestBuilder;
};
declare const OneTimeDataRequestBuilder: OneTimeDataRequestBuilder;

declare const proofType: {
    readonly persona: "persona";
    readonly account: "account";
};
type SignedChallengePersona = InferOutput<typeof SignedChallengePersona>;
declare const SignedChallengePersona: valibot.ObjectSchema<{
    readonly challenge: valibot.StringSchema<undefined>;
    readonly proof: valibot.ObjectSchema<{
        readonly publicKey: valibot.StringSchema<undefined>;
        readonly signature: valibot.StringSchema<undefined>;
        readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
    }, undefined>;
    readonly address: valibot.StringSchema<undefined>;
    readonly type: valibot.LiteralSchema<"persona", undefined>;
}, undefined>;
type SignedChallengeAccount = InferOutput<typeof SignedChallengeAccount>;
declare const SignedChallengeAccount: valibot.ObjectSchema<{
    readonly challenge: valibot.StringSchema<undefined>;
    readonly proof: valibot.ObjectSchema<{
        readonly publicKey: valibot.StringSchema<undefined>;
        readonly signature: valibot.StringSchema<undefined>;
        readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
    }, undefined>;
    readonly address: valibot.StringSchema<undefined>;
    readonly type: valibot.LiteralSchema<"account", undefined>;
}, undefined>;
type SignedChallenge = InferOutput<typeof SignedChallenge>;
declare const SignedChallenge: valibot.VariantSchema<"type", [valibot.ObjectSchema<{
    readonly challenge: valibot.StringSchema<undefined>;
    readonly proof: valibot.ObjectSchema<{
        readonly publicKey: valibot.StringSchema<undefined>;
        readonly signature: valibot.StringSchema<undefined>;
        readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
    }, undefined>;
    readonly address: valibot.StringSchema<undefined>;
    readonly type: valibot.LiteralSchema<"persona", undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly challenge: valibot.StringSchema<undefined>;
    readonly proof: valibot.ObjectSchema<{
        readonly publicKey: valibot.StringSchema<undefined>;
        readonly signature: valibot.StringSchema<undefined>;
        readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
    }, undefined>;
    readonly address: valibot.StringSchema<undefined>;
    readonly type: valibot.LiteralSchema<"account", undefined>;
}, undefined>], undefined>;
declare const WalletDataPersonaDataFullName: valibot.ObjectSchema<{
    readonly entry: valibot.LiteralSchema<"fullName", undefined>;
    readonly fields: valibot.ObjectSchema<{
        readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
        readonly familyName: valibot.StringSchema<undefined>;
        readonly nickname: valibot.StringSchema<undefined>;
        readonly givenNames: valibot.StringSchema<undefined>;
    }, undefined>;
}, undefined>;
declare const WalletDataPersonaDataEmailAddresses: valibot.ObjectSchema<{
    readonly entry: valibot.LiteralSchema<"emailAddresses", undefined>;
    readonly fields: valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>;
}, undefined>;
declare const WalletDataPersonaDataPhoneNumbersAddresses: valibot.ObjectSchema<{
    readonly entry: valibot.LiteralSchema<"phoneNumbers", undefined>;
    readonly fields: valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>;
}, undefined>;
type WalletDataPersonaData = InferOutput<typeof WalletDataPersonaData>;
declare const WalletDataPersonaData: valibot.VariantSchema<"entry", [valibot.ObjectSchema<{
    readonly entry: valibot.LiteralSchema<"fullName", undefined>;
    readonly fields: valibot.ObjectSchema<{
        readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
        readonly familyName: valibot.StringSchema<undefined>;
        readonly nickname: valibot.StringSchema<undefined>;
        readonly givenNames: valibot.StringSchema<undefined>;
    }, undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly entry: valibot.LiteralSchema<"emailAddresses", undefined>;
    readonly fields: valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly entry: valibot.LiteralSchema<"phoneNumbers", undefined>;
    readonly fields: valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>;
}, undefined>], undefined>;
type WalletData = InferOutput<typeof WalletData>;
declare const WalletData: valibot.ObjectSchema<{
    readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
        readonly address: valibot.StringSchema<undefined>;
        readonly label: valibot.StringSchema<undefined>;
        readonly appearanceId: valibot.NumberSchema<undefined>;
    }, undefined>, undefined>;
    readonly personaData: valibot.ArraySchema<valibot.VariantSchema<"entry", [valibot.ObjectSchema<{
        readonly entry: valibot.LiteralSchema<"fullName", undefined>;
        readonly fields: valibot.ObjectSchema<{
            readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
            readonly familyName: valibot.StringSchema<undefined>;
            readonly nickname: valibot.StringSchema<undefined>;
            readonly givenNames: valibot.StringSchema<undefined>;
        }, undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly entry: valibot.LiteralSchema<"emailAddresses", undefined>;
        readonly fields: valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly entry: valibot.LiteralSchema<"phoneNumbers", undefined>;
        readonly fields: valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>;
    }, undefined>], undefined>, undefined>;
    readonly persona: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly identityAddress: valibot.StringSchema<undefined>;
        readonly label: valibot.StringSchema<undefined>;
    }, undefined>, never>;
    readonly proofs: valibot.ArraySchema<valibot.VariantSchema<"type", [valibot.ObjectSchema<{
        readonly challenge: valibot.StringSchema<undefined>;
        readonly proof: valibot.ObjectSchema<{
            readonly publicKey: valibot.StringSchema<undefined>;
            readonly signature: valibot.StringSchema<undefined>;
            readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
        }, undefined>;
        readonly address: valibot.StringSchema<undefined>;
        readonly type: valibot.LiteralSchema<"persona", undefined>;
    }, undefined>, valibot.ObjectSchema<{
        readonly challenge: valibot.StringSchema<undefined>;
        readonly proof: valibot.ObjectSchema<{
            readonly publicKey: valibot.StringSchema<undefined>;
            readonly signature: valibot.StringSchema<undefined>;
            readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
        }, undefined>;
        readonly address: valibot.StringSchema<undefined>;
        readonly type: valibot.LiteralSchema<"account", undefined>;
    }, undefined>], undefined>, undefined>;
}, undefined>;
type SharedData = InferOutput<typeof SharedData>;
declare const SharedData: valibot.ObjectSchema<{
    readonly persona: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly proof: valibot.BooleanSchema<undefined>;
    }, undefined>, never>;
    readonly ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly numberOfAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly proof: valibot.BooleanSchema<undefined>;
    }, undefined>, never>;
    readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
        readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
    }, undefined>, never>;
}, undefined>;
type RdtState = InferOutput<typeof RdtState>;
declare const RdtState: valibot.ObjectSchema<{
    readonly loggedInTimestamp: valibot.StringSchema<undefined>;
    readonly walletData: valibot.ObjectSchema<{
        readonly accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            readonly address: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
            readonly appearanceId: valibot.NumberSchema<undefined>;
        }, undefined>, undefined>;
        readonly personaData: valibot.ArraySchema<valibot.VariantSchema<"entry", [valibot.ObjectSchema<{
            readonly entry: valibot.LiteralSchema<"fullName", undefined>;
            readonly fields: valibot.ObjectSchema<{
                readonly variant: valibot.UnionSchema<[valibot.LiteralSchema<"eastern", undefined>, valibot.LiteralSchema<"western", undefined>], undefined>;
                readonly familyName: valibot.StringSchema<undefined>;
                readonly nickname: valibot.StringSchema<undefined>;
                readonly givenNames: valibot.StringSchema<undefined>;
            }, undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly entry: valibot.LiteralSchema<"emailAddresses", undefined>;
            readonly fields: valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly entry: valibot.LiteralSchema<"phoneNumbers", undefined>;
            readonly fields: valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>;
        }, undefined>], undefined>, undefined>;
        readonly persona: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly identityAddress: valibot.StringSchema<undefined>;
            readonly label: valibot.StringSchema<undefined>;
        }, undefined>, never>;
        readonly proofs: valibot.ArraySchema<valibot.VariantSchema<"type", [valibot.ObjectSchema<{
            readonly challenge: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
            readonly address: valibot.StringSchema<undefined>;
            readonly type: valibot.LiteralSchema<"persona", undefined>;
        }, undefined>, valibot.ObjectSchema<{
            readonly challenge: valibot.StringSchema<undefined>;
            readonly proof: valibot.ObjectSchema<{
                readonly publicKey: valibot.StringSchema<undefined>;
                readonly signature: valibot.StringSchema<undefined>;
                readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
            }, undefined>;
            readonly address: valibot.StringSchema<undefined>;
            readonly type: valibot.LiteralSchema<"account", undefined>;
        }, undefined>], undefined>, undefined>;
    }, undefined>;
    readonly sharedData: valibot.ObjectSchema<{
        readonly persona: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly proof: valibot.BooleanSchema<undefined>;
        }, undefined>, never>;
        readonly ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly numberOfAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
            }, undefined>, never>;
            readonly proof: valibot.BooleanSchema<undefined>;
        }, undefined>, never>;
        readonly ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
            readonly numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
            }, undefined>, never>;
            readonly numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
                readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
            }, undefined>, never>;
        }, undefined>, never>;
    }, undefined>;
}, undefined>;
declare const walletDataDefault: {
    accounts: never[];
    personaData: never[];
    proofs: never[];
    persona: undefined;
};

declare const canDataRequestBeResolvedByRdtState: (dataRequest: WalletUnauthorizedRequestItems | WalletAuthorizedRequestItems, state: RdtState) => boolean;

type NetworkId = number;
type PartitionKey = 'sessions' | 'identities' | 'requests' | 'state' | 'walletResponses' | 'connectorExtension';
type dAppDefinitionAddress = string;
type StorageChange<T> = {
    key: string;
    partition: string;
    newValue: Record<string, T> | undefined;
    oldValue: Record<string, T> | undefined;
};
type StorageModule<T extends object = any> = ReturnType<typeof LocalStorageModule<T>>;
declare const LocalStorageModule: <T extends object = any>(storageKey: `rdt:${dAppDefinitionAddress}:${NetworkId}` | `rdt:${dAppDefinitionAddress}:${NetworkId}${string}`, { providers, }: {
    providers: {
        environmentModule: EnvironmentModule;
    };
}) => {
    getItems: () => ResultAsync<Record<string, T>, Error>;
    getItemById: (id: string) => ResultAsync<T | undefined, Error>;
    removeItemById: (id: string) => ResultAsync<void, Error>;
    patchItem: (id: string, patch: Partial<T>) => ResultAsync<void, Error>;
    setItems: (item: Record<string, T>) => ResultAsync<void, Error>;
    getItemList: () => ResultAsync<T[], Error>;
    getPartition: (partitionKey: PartitionKey) => any;
    setState: (newValue: T) => ResultAsync<void, Error>;
    getState: () => ResultAsync<T | undefined, Error>;
    patchState: (newValue: Partial<T>) => ResultAsync<void, {
        reason: string;
    }>;
    clear: () => ResultAsync<unknown, Error>;
    storage$: rxjs.Observable<StorageChange<T>>;
};

type StateModule = ReturnType<typeof StateModule>;
declare const StateModule: (input: {
    logger?: Logger;
    providers: {
        storageModule: StorageModule<RdtState>;
    };
}) => {
    setState: (state: RdtState) => ResultAsync<void, Error>;
    patchState: (state: Partial<RdtState>) => ResultAsync<void, Error>;
    getState: () => ResultAsync<RdtState, never>;
    walletData$: rxjs.Observable<{
        proofs: ({
            address: string;
            type: "persona";
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
            challenge: string;
        } | {
            address: string;
            type: "account";
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
            challenge: string;
        })[];
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        personaData: ({
            entry: "fullName";
            fields: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            };
        } | {
            entry: "emailAddresses";
            fields: string[];
        } | {
            entry: "phoneNumbers";
            fields: string[];
        })[];
        persona?: {
            label: string;
            identityAddress: string;
        } | undefined;
    }>;
    emitWalletData: () => void;
    getWalletData: () => {
        proofs: ({
            address: string;
            type: "persona";
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
            challenge: string;
        } | {
            address: string;
            type: "account";
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
            challenge: string;
        })[];
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        personaData: ({
            entry: "fullName";
            fields: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            };
        } | {
            entry: "emailAddresses";
            fields: string[];
        } | {
            entry: "phoneNumbers";
            fields: string[];
        })[];
        persona?: {
            label: string;
            identityAddress: string;
        } | undefined;
    } | undefined;
    reset: () => ResultAsync<void, Error>;
    storage$: rxjs.Observable<StorageChange<{
        loggedInTimestamp: string;
        walletData: {
            proofs: ({
                address: string;
                type: "persona";
                proof: {
                    curve: "curve25519" | "secp256k1";
                    publicKey: string;
                    signature: string;
                };
                challenge: string;
            } | {
                address: string;
                type: "account";
                proof: {
                    curve: "curve25519" | "secp256k1";
                    publicKey: string;
                    signature: string;
                };
                challenge: string;
            })[];
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            personaData: ({
                entry: "fullName";
                fields: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                };
            } | {
                entry: "emailAddresses";
                fields: string[];
            } | {
                entry: "phoneNumbers";
                fields: string[];
            })[];
            persona?: {
                label: string;
                identityAddress: string;
            } | undefined;
        };
        sharedData: {
            persona?: {
                proof: boolean;
            } | undefined;
            ongoingAccounts?: {
                proof: boolean;
                numberOfAccounts?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        };
    }>>;
    destroy: () => void;
};

declare const toWalletRequest: ({ dataRequestState, isConnect, challenge, oneTime, walletData, }: {
    dataRequestState: DataRequestState;
    isConnect: boolean;
    oneTime: boolean;
    challenge?: string;
    walletData: WalletData;
}) => neverthrow.Result<{
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
} | {
    discriminator: "authorizedRequest";
    auth: {
        identityAddress: string;
        discriminator: "usePersona";
    } | {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    };
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
    reset?: {
        accounts: boolean;
        personaData: boolean;
    } | undefined;
    proofOfOwnership?: {
        challenge: string;
        identityAddress?: string | undefined;
        accountAddresses?: string[] | undefined;
    } | undefined;
    ongoingAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    ongoingPersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
}, never>;

type TransformRdtDataRequestToWalletRequestInput = InferOutput<typeof TransformRdtDataRequestToWalletRequestInput>;
declare const TransformRdtDataRequestToWalletRequestInput: valibot.ObjectSchema<{
    readonly proofOfOwnership: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly accountAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, never>;
        readonly identityAddress: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
    }, undefined>, never>;
    readonly accounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly numberOfAccounts: valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>;
        readonly reset: valibot.BooleanSchema<undefined>;
        readonly oneTime: valibot.BooleanSchema<undefined>;
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
    }, undefined>, never>;
    readonly personaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly fullName: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
        readonly phoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly emailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly quantifier: valibot.UnionSchema<[valibot.LiteralSchema<"exactly", undefined>, valibot.LiteralSchema<"atLeast", undefined>], undefined>;
            readonly quantity: valibot.SchemaWithPipe<[valibot.NumberSchema<undefined>, valibot.MinValueAction<number, 0, "The number must be at least 0.">]>;
        }, undefined>, never>;
        readonly reset: valibot.BooleanSchema<undefined>;
        readonly oneTime: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, never>;
    }, undefined>, never>;
    readonly persona: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly identityAddress: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly label: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
        readonly challenge: valibot.OptionalSchema<valibot.StringSchema<undefined>, never>;
    }, undefined>, never>;
}, undefined>;
declare const transformRdtDataRequestToWalletRequest: (isConnect: boolean, input: TransformRdtDataRequestToWalletRequestInput) => Result<WalletUnauthorizedRequestItems | WalletAuthorizedRequestItems, never>;

declare const transformWalletRequestToSharedData: (walletInteraction: WalletInteraction, sharedData: SharedData) => SharedData;
declare const transformSharedDataToDataRequestState: (sharedData: SharedData) => DataRequestState;

type WalletDataRequestResponse = WalletAuthorizedRequestResponseItems | WalletUnauthorizedRequestResponseItems;
declare const transformWalletResponseToRdtWalletData: (response: WalletDataRequestResponse) => ResultAsync<WalletData, never>;

declare const transformWalletDataToConnectButton: (walletData: WalletData) => {
    accounts: {
        address: string;
        label: string;
        appearanceId: number;
    }[];
    personaLabel: string;
    connected: boolean;
    personaData: {
        value: string;
        field: string;
    }[];
};

type DataRequestStateModule = ReturnType<typeof DataRequestStateModule>;
declare const DataRequestStateModule: (initialState: DataRequestState) => {
    reset: () => void;
    setState: (...items: DataRequestBuilderItem[]) => void;
    getState: () => Partial<{
        accounts: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            reset?: boolean | undefined;
            withProof?: boolean | undefined;
        };
        personaData: {
            emailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            phoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            reset?: boolean | undefined;
            fullName?: boolean | undefined;
        };
        persona: {
            withProof?: boolean | undefined;
        };
        proofOfOwnership: {
            identityAddress?: string | undefined;
            accountAddresses?: string[] | undefined;
        };
    }>;
    patchState: (...items: DataRequestBuilderItem[]) => void;
    removeState: (...keys: (keyof DataRequestState)[]) => void;
    toDataRequestState: (...items: unknown[]) => DataRequestState;
    state$: rxjs.Observable<Partial<{
        accounts: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            reset?: boolean | undefined;
            withProof?: boolean | undefined;
        };
        personaData: {
            emailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            phoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            reset?: boolean | undefined;
            fullName?: boolean | undefined;
        };
        persona: {
            withProof?: boolean | undefined;
        };
        proofOfOwnership: {
            identityAddress?: string | undefined;
            accountAddresses?: string[] | undefined;
        };
    }>>;
};

declare const IdentityKind: {
    readonly dApp: "dApp";
};
type IdentityKind = (typeof IdentityKind)[keyof typeof IdentityKind];
type IdentitySecret = {
    secret: string;
    createdAt: number;
};
type IdentityStore = {
    [IdentityKind.dApp]: IdentitySecret;
};
type IdentityModule = ReturnType<typeof IdentityModule>;
declare const IdentityModule: (input: {
    logger?: Logger;
    dAppDefinitionAddress: string;
    providers: {
        storageModule: StorageModule<IdentitySecret>;
        KeyPairModule: KeyPairProvider;
    };
}) => {
    get: (kind: IdentityKind) => ResultAsync<{
        getPrivateKey: () => string;
        x25519: {
            getPublicKey: () => string;
            calculateSharedSecret: (publicKeyHex: string, dAppDefinitionAddress: string) => neverthrow.Result<string, Error>;
        };
        ed25519: {
            getPublicKey: () => string;
            sign: (messageHex: string) => neverthrow.Result<string, Error>;
        };
    }, {
        reason: string;
        jsError: Error;
    }>;
    deriveSharedSecret: (kind: IdentityKind, publicKey: string) => ResultAsync<string, {
        reason: string;
    } | {
        reason: string;
    }>;
    createSignature: ({ kind, interactionId, dAppDefinitionAddress, origin, }: {
        kind: IdentityKind;
        interactionId: string;
        dAppDefinitionAddress: string;
        origin: string;
    }) => ResultAsync<{
        signature: string;
        publicKey: string;
    }, {
        reason: string;
        jsError: Error;
    }>;
};

type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus];
declare const TransactionStatus: {
    readonly Unknown: "Unknown";
    readonly CommittedSuccess: "CommittedSuccess";
    readonly CommittedFailure: "CommittedFailure";
    readonly Pending: "Pending";
    readonly Rejected: "Rejected";
};
type SubintentStatus = Extract<TransactionStatus, 'CommittedSuccess' | 'Unknown'>;
type MetadataStringValue = {
    type: 'String';
    value: string;
};
type MetadataTypedValue = {
    type: 'String';
} & MetadataStringValue;
type EntityMetadataItemValue = {
    typed: MetadataTypedValue;
};
type EntityMetadataItem = {
    key: string;
    value: EntityMetadataItemValue;
    is_locked: boolean;
    last_updated_at_state_version: number;
};
type TransactionStatusResponse = {
    status: TransactionStatus;
};
declare const RadixNetwork: {
    readonly Mainnet: 1;
    readonly Stokenet: 2;
    readonly Gilganet: 32;
    readonly Enkinet: 33;
    readonly Hammunet: 34;
    readonly Nergalnet: 35;
    readonly Mardunet: 36;
    readonly Dumunet: 37;
};
type NetworkConfig = {
    networkName: string;
    networkId: (typeof RadixNetwork)[keyof typeof RadixNetwork];
    gatewayUrl: string;
    dashboardUrl: string;
};
declare const RadixNetworkConfig: Record<string, NetworkConfig>;
declare const RadixNetworkConfigById: Record<number, NetworkConfig>;

type GatewayApiService = ReturnType<typeof GatewayApiService>;
declare const GatewayApiService: ({ basePath, applicationName, applicationVersion, applicationDappDefinitionAddress, }: GatewayApiClientConfig) => {
    getSubintentStatus: (subintentHash: string) => neverthrow.ResultAsync<{
        subintent_status: SubintentStatus;
        finalized_at_transaction_intent_hash: string;
    }, {
        status: number;
        error?: Error | undefined;
        reason: string;
        data?: unknown;
    }>;
    getTransactionStatus: (transactionIntentHash: string) => neverthrow.ResultAsync<{
        status: TransactionStatus;
    }, {
        status: number;
        error?: Error | undefined;
        reason: string;
        data?: unknown;
    }>;
    getEntityMetadataPage: (address: string) => neverthrow.ResultAsync<{
        items: EntityMetadataItem[];
    }, {
        status: number;
        error?: Error | undefined;
        reason: string;
        data?: unknown;
    }>;
};

type GatewayModule = ReturnType<typeof GatewayModule>;
declare const GatewayModule: (input: {
    clientConfig: GatewayApiClientConfig;
    logger?: Logger;
    retryConfig?: ExponentialBackoffInput;
    providers?: {
        gatewayApiService?: GatewayApiService;
    };
}) => {
    readonly pollSubintentStatus: (subintentHash: string, expirationTimestamp: number) => {
        stop: () => void;
        result: ResultAsync<{
            subintentStatus: SubintentStatus;
            transactionIntentHash: string;
        }, SdkError>;
    };
    readonly pollTransactionStatus: (transactionIntentHash: string) => ResultAsync<TransactionStatus, SdkError>;
    readonly gatewayApi: {
        getSubintentStatus: (subintentHash: string) => ResultAsync<{
            subintent_status: SubintentStatus;
            finalized_at_transaction_intent_hash: string;
        }, {
            status: number;
            error?: Error | undefined;
            reason: string;
            data?: unknown;
        }>;
        getTransactionStatus: (transactionIntentHash: string) => ResultAsync<{
            status: TransactionStatus;
        }, {
            status: number;
            error?: Error | undefined;
            reason: string;
            data?: unknown;
        }>;
        getEntityMetadataPage: (address: string) => ResultAsync<{
            items: EntityMetadataItem[];
        }, {
            status: number;
            error?: Error | undefined;
            reason: string;
            data?: unknown;
        }>;
    };
    readonly configuration: GatewayApiClientConfig;
};

type RequestItemModuleInput = {
    logger?: Logger;
    providers: {
        gatewayModule: GatewayModule;
        storageModule: StorageModule<RequestItem>;
    };
};
type RequestItemModule = ReturnType<typeof RequestItemModule>;
declare const RequestItemModule: (input: RequestItemModuleInput) => {
    add: (value: {
        type: RequestItem['type'];
        walletInteraction: WalletInteraction;
        isOneTimeRequest: boolean;
    }, onSignal?: (signalValue: string) => void) => ResultAsync<RequestItem, Error>;
    cancel: (id: string) => ResultAsync<void, Error>;
    updateStatus: ({ id, status, error, transactionIntentHash, metadata, walletData, walletResponse, }: {
        id: string;
        status: RequestStatusTypes;
        error?: string;
        transactionIntentHash?: string;
        walletData?: WalletData;
        walletResponse?: any;
        metadata?: Record<string, string | number | boolean>;
    }) => ResultAsync<void, {
        reason: string;
    }>;
    patch: (id: string, partialValue: Partial<RequestItem>) => ResultAsync<void, Error>;
    getAndRemoveSignal: (interactionId: string) => ((val: string) => void) | undefined;
    getById: (id: string) => ResultAsync<RequestItem | undefined, Error>;
    getPendingCommit: () => ResultAsync<RequestItem[], Error>;
    getPending: () => ResultAsync<RequestItem[], Error>;
    requests$: rxjs.Observable<RequestItem[]>;
    clear: () => ResultAsync<unknown, Error>;
    destroy: () => void;
};

type Session = {
    sessionId: string;
    createdAt: number;
};
type SessionModule = ReturnType<typeof SessionModule>;
declare const SessionModule: (input: {
    providers: {
        storageModule: StorageModule<Session>;
    };
}) => {
    getCurrentSession: () => ResultAsync<Session, {
        reason: string;
        jsError: Error;
    }>;
    getSession: () => ResultAsync<Session | undefined, {
        reason: string;
        jsError: Error;
    }>;
    store: StorageModule<Session>;
    getSessionById: (sessionId: string) => ResultAsync<Session | undefined, {
        reason: string;
        jsError: Error;
    }>;
    patchSession: (sessionId: string, value: Partial<Session>) => ResultAsync<void, {
        reason: string;
        jsError: Error;
    }>;
};

type ConnectorExtensionSubjects = ReturnType<typeof ConnectorExtensionSubjects>;
declare const ConnectorExtensionSubjects: () => {
    outgoingMessageSubject: Subject<{
        metadata: {
            version: 2;
            networkId: number;
            dAppDefinitionAddress: string;
            origin: string;
        };
        interactionId: string;
        items: {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            };
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            reset?: {
                accounts: boolean;
                personaData: boolean;
            } | undefined;
            proofOfOwnership?: {
                challenge: string;
                identityAddress?: string | undefined;
                accountAddresses?: string[] | undefined;
            } | undefined;
            ongoingAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "transaction";
            send: {
                transactionManifest: string;
                version: number;
                message?: string | undefined;
                blobs?: string[] | undefined;
            };
        } | {
            discriminator: "cancelRequest";
        } | {
            discriminator: "preAuthorizationRequest";
            request?: {
                discriminator: "subintent";
                version: number;
                expiration: {
                    discriminator: "expireAtTime";
                    unixTimestampSeconds: number;
                } | {
                    discriminator: "expireAfterDelay";
                    expireAfterSeconds: number;
                };
                manifestVersion: number;
                subintentManifest: string;
                message?: string | undefined;
                blobs?: string[] | undefined;
            } | undefined;
        };
    } | {
        discriminator: "extensionStatus";
        interactionId: string;
    } | {
        discriminator: "openPopup";
        interactionId: string;
    } | {
        discriminator: "walletInteraction";
        interactionId: string;
        interaction: {
            metadata: {
                version: 2;
                networkId: number;
                dAppDefinitionAddress: string;
                origin: string;
            };
            interactionId: string;
            items: {
                discriminator: "unauthorizedRequest";
                oneTimeAccounts?: {
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                    challenge?: string | undefined;
                } | undefined;
                oneTimePersonaData?: {
                    isRequestingName?: boolean | undefined;
                    numberOfRequestedEmailAddresses?: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    } | undefined;
                    numberOfRequestedPhoneNumbers?: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    } | undefined;
                } | undefined;
            } | {
                discriminator: "authorizedRequest";
                auth: {
                    identityAddress: string;
                    discriminator: "usePersona";
                } | {
                    discriminator: "loginWithoutChallenge";
                } | {
                    challenge: string;
                    discriminator: "loginWithChallenge";
                };
                oneTimeAccounts?: {
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                    challenge?: string | undefined;
                } | undefined;
                oneTimePersonaData?: {
                    isRequestingName?: boolean | undefined;
                    numberOfRequestedEmailAddresses?: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    } | undefined;
                    numberOfRequestedPhoneNumbers?: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    } | undefined;
                } | undefined;
                reset?: {
                    accounts: boolean;
                    personaData: boolean;
                } | undefined;
                proofOfOwnership?: {
                    challenge: string;
                    identityAddress?: string | undefined;
                    accountAddresses?: string[] | undefined;
                } | undefined;
                ongoingAccounts?: {
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                    challenge?: string | undefined;
                } | undefined;
                ongoingPersonaData?: {
                    isRequestingName?: boolean | undefined;
                    numberOfRequestedEmailAddresses?: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    } | undefined;
                    numberOfRequestedPhoneNumbers?: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    } | undefined;
                } | undefined;
            } | {
                discriminator: "transaction";
                send: {
                    transactionManifest: string;
                    version: number;
                    message?: string | undefined;
                    blobs?: string[] | undefined;
                };
            } | {
                discriminator: "cancelRequest";
            } | {
                discriminator: "preAuthorizationRequest";
                request?: {
                    discriminator: "subintent";
                    version: number;
                    expiration: {
                        discriminator: "expireAtTime";
                        unixTimestampSeconds: number;
                    } | {
                        discriminator: "expireAfterDelay";
                        expireAfterSeconds: number;
                    };
                    manifestVersion: number;
                    subintentManifest: string;
                    message?: string | undefined;
                    blobs?: string[] | undefined;
                } | undefined;
            };
        };
        sessionId?: string | undefined;
    } | {
        metadata: {
            version: 2;
            networkId: number;
            dAppDefinitionAddress: string;
            origin: string;
        };
        discriminator: "cancelWalletInteraction";
        interactionId: string;
    }>;
    incomingMessageSubject: Subject<{
        discriminator: "success";
        interactionId: string;
        items: {
            discriminator: "transaction";
            send: {
                transactionIntentHash: string;
            };
        } | {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
                challenge?: string | undefined;
                proofs?: {
                    accountAddress: string;
                    proof: {
                        curve: "curve25519" | "secp256k1";
                        publicKey: string;
                        signature: string;
                    };
                }[] | undefined;
            } | undefined;
            oneTimePersonaData?: {
                name?: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                } | undefined;
                emailAddresses?: string[] | undefined;
                phoneNumbers?: string[] | undefined;
            } | undefined;
        } | {
            discriminator: "preAuthorizationResponse";
            response?: {
                expirationTimestamp: number;
                subintentHash: string;
                signedPartialTransaction: string;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                persona: {
                    label: string;
                    identityAddress: string;
                };
                discriminator: "loginWithoutChallenge";
            } | {
                proof: {
                    curve: "curve25519" | "secp256k1";
                    publicKey: string;
                    signature: string;
                };
                challenge: string;
                persona: {
                    label: string;
                    identityAddress: string;
                };
                discriminator: "loginWithChallenge";
            } | {
                persona: {
                    label: string;
                    identityAddress: string;
                };
                discriminator: "usePersona";
            };
            oneTimeAccounts?: {
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
                challenge?: string | undefined;
                proofs?: {
                    accountAddress: string;
                    proof: {
                        curve: "curve25519" | "secp256k1";
                        publicKey: string;
                        signature: string;
                    };
                }[] | undefined;
            } | undefined;
            oneTimePersonaData?: {
                name?: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                } | undefined;
                emailAddresses?: string[] | undefined;
                phoneNumbers?: string[] | undefined;
            } | undefined;
            proofOfOwnership?: {
                challenge: string;
                proofs: ({
                    accountAddress: string;
                    proof: {
                        curve: "curve25519" | "secp256k1";
                        publicKey: string;
                        signature: string;
                    };
                } | {
                    proof: {
                        curve: "curve25519" | "secp256k1";
                        publicKey: string;
                        signature: string;
                    };
                    identityAddress: string;
                })[];
            } | undefined;
            ongoingAccounts?: {
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
                challenge?: string | undefined;
                proofs?: {
                    accountAddress: string;
                    proof: {
                        curve: "curve25519" | "secp256k1";
                        publicKey: string;
                        signature: string;
                    };
                }[] | undefined;
            } | undefined;
            ongoingPersonaData?: {
                name?: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                } | undefined;
                emailAddresses?: string[] | undefined;
                phoneNumbers?: string[] | undefined;
            } | undefined;
        };
    } | {
        error: string;
        discriminator: "failure";
        interactionId: string;
        message?: string | undefined;
    } | {
        interactionId: string;
        eventType: "extensionStatus";
        isWalletLinked: boolean;
        isExtensionAvailable: boolean;
        canHandleSessions?: boolean | undefined;
    } | {
        interactionId: string;
        eventType: "extensionStatus" | "receivedByExtension" | "receivedByWallet" | "requestCancelSuccess" | "requestCancelFail";
    }>;
    responseSubject: Subject<{
        discriminator: "success";
        interactionId: string;
        items: {
            discriminator: "transaction";
            send: {
                transactionIntentHash: string;
            };
        } | {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
                challenge?: string | undefined;
                proofs?: {
                    accountAddress: string;
                    proof: {
                        curve: "curve25519" | "secp256k1";
                        publicKey: string;
                        signature: string;
                    };
                }[] | undefined;
            } | undefined;
            oneTimePersonaData?: {
                name?: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                } | undefined;
                emailAddresses?: string[] | undefined;
                phoneNumbers?: string[] | undefined;
            } | undefined;
        } | {
            discriminator: "preAuthorizationResponse";
            response?: {
                expirationTimestamp: number;
                subintentHash: string;
                signedPartialTransaction: string;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                persona: {
                    label: string;
                    identityAddress: string;
                };
                discriminator: "loginWithoutChallenge";
            } | {
                proof: {
                    curve: "curve25519" | "secp256k1";
                    publicKey: string;
                    signature: string;
                };
                challenge: string;
                persona: {
                    label: string;
                    identityAddress: string;
                };
                discriminator: "loginWithChallenge";
            } | {
                persona: {
                    label: string;
                    identityAddress: string;
                };
                discriminator: "usePersona";
            };
            oneTimeAccounts?: {
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
                challenge?: string | undefined;
                proofs?: {
                    accountAddress: string;
                    proof: {
                        curve: "curve25519" | "secp256k1";
                        publicKey: string;
                        signature: string;
                    };
                }[] | undefined;
            } | undefined;
            oneTimePersonaData?: {
                name?: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                } | undefined;
                emailAddresses?: string[] | undefined;
                phoneNumbers?: string[] | undefined;
            } | undefined;
            proofOfOwnership?: {
                challenge: string;
                proofs: ({
                    accountAddress: string;
                    proof: {
                        curve: "curve25519" | "secp256k1";
                        publicKey: string;
                        signature: string;
                    };
                } | {
                    proof: {
                        curve: "curve25519" | "secp256k1";
                        publicKey: string;
                        signature: string;
                    };
                    identityAddress: string;
                })[];
            } | undefined;
            ongoingAccounts?: {
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
                challenge?: string | undefined;
                proofs?: {
                    accountAddress: string;
                    proof: {
                        curve: "curve25519" | "secp256k1";
                        publicKey: string;
                        signature: string;
                    };
                }[] | undefined;
            } | undefined;
            ongoingPersonaData?: {
                name?: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                } | undefined;
                emailAddresses?: string[] | undefined;
                phoneNumbers?: string[] | undefined;
            } | undefined;
        };
    } | {
        error: string;
        discriminator: "failure";
        interactionId: string;
        message?: string | undefined;
    }>;
    messageLifeCycleEventSubject: Subject<{
        interactionId: string;
        eventType: "extensionStatus" | "receivedByExtension" | "receivedByWallet" | "requestCancelSuccess" | "requestCancelFail";
    }>;
};

type WalletResponseResolverInput = {
    walletInteraction: WalletInteraction;
    walletInteractionResponse: WalletInteractionResponse;
    requestItem: RequestItem;
};
type WalletResponseResolver = (input: WalletResponseResolverInput) => ResultAsync<undefined, SdkError>;

type RequestResolverModule = ReturnType<typeof RequestResolverModule>;
declare const RequestResolverModule: (input: {
    logger?: Logger;
    providers: {
        storageModule: StorageModule;
        requestItemModule: RequestItemModule;
        resolvers: WalletResponseResolver[];
    };
}) => {
    waitForWalletResponse: (interactionId: string) => ResultAsync<RequestItem, never>;
    getPendingRequestById: (interactionId: string) => ResultAsync<RequestItem, SdkError>;
    getPendingRequestIds: () => ResultAsync<string[], "PendingItemsNotFound">;
    markRequestAsSent: (interactionId: string) => ResultAsync<void, Error>;
    addWalletResponses: (responses: WalletInteractionResponse[]) => ResultAsync<void, node_modules_tslog_dist_types_interfaces.ILogObjMeta | undefined>;
    getWalletResponseById: (interactionId: string) => ResultAsync<WalletInteractionResponse | undefined, SdkError>;
    destroy: () => void;
};

type ConnectorExtensionModule = ReturnType<typeof ConnectorExtensionModule>;
declare const ConnectorExtensionModule: (input: {
    subjects?: ConnectorExtensionSubjects;
    logger?: Logger;
    extensionDetectionTime?: number;
    providers: {
        environmentModule: EnvironmentModule;
        requestResolverModule: RequestResolverModule;
        storageModule: StorageModule<{
            sessionId?: string;
        }>;
    };
}) => {
    id: "connector-extension";
    isSupported: () => boolean;
    send: (walletInteraction: WalletInteraction, callbackFns: Partial<CallbackFns>) => ResultAsync<WalletInteractionResponse, SdkError>;
    isAvailable$: rxjs.Observable<boolean>;
    isLinked$: rxjs.Observable<boolean>;
    showQrCode: () => void;
    disconnect: () => void;
    destroy: () => void;
};

type DeepLinkModule = ReturnType<typeof DeepLinkModule>;
declare const DeepLinkModule: (input: {
    logger?: Logger;
    walletUrl: string;
    providers: {
        environmentModule: EnvironmentModule;
    };
}) => {
    deepLinkToWallet: (values: Record<string, string>) => ResultAsync<undefined, SdkError>;
};

type SealedBoxProps = {
    iv: Buffer;
    authTag: Buffer;
    combined: Buffer;
    ciphertext: Buffer;
    ciphertextAndAuthTag: Buffer;
};

type EncryptionModule = ReturnType<typeof EncryptionModule>;
declare const EncryptionModule: () => {
    encrypt: (data: Buffer, encryptionKey: Buffer, iv?: Buffer) => ResultAsync<Omit<SealedBoxProps, 'ciphertextAndAuthTag' | 'authTag'>, Error>;
    decrypt: (data: Buffer, encryptionKey: Buffer, iv: Buffer) => ResultAsync<Buffer, Error>;
    createIV: () => Buffer;
};

type RadixConnectRelayModule = ReturnType<typeof RadixConnectRelayModule>;
declare const RadixConnectRelayModule: (input: {
    baseUrl: string;
    logger?: Logger;
    walletUrl: string;
    dAppDefinitionAddress: string;
    providers: {
        storageModule: StorageModule;
        requestResolverModule: RequestResolverModule;
        environmentModule: EnvironmentModule;
        encryptionModule?: EncryptionModule;
        identityModule?: IdentityModule;
        sessionModule?: SessionModule;
        deepLinkModule?: DeepLinkModule;
    };
}) => TransportProvider;

type WalletRequestSdkInput = {
    networkId: number;
    dAppDefinitionAddress: string;
    logger?: Logger;
    origin?: string;
    requestInterceptor?: (walletInteraction: WalletInteraction) => Promise<WalletInteraction>;
    providers: {
        transports: TransportProvider[];
        interactionIdFactory?: () => string;
        environmentModule: EnvironmentModule;
    };
};
type WalletRequestSdk = ReturnType<typeof WalletRequestSdk>;
declare const WalletRequestSdk: (input: WalletRequestSdkInput) => {
    sendInteraction: ({ interactionId, items, }: {
        interactionId?: string;
        items: WalletInteraction['items'];
    }, callbackFns?: Partial<CallbackFns>) => ResultAsync<WalletInteractionSuccessResponse, SdkError | WalletInteractionFailureResponse>;
    createWalletInteraction: (items: WalletInteractionItems, interactionId?: string) => WalletInteraction;
    getTransport: (interactionId: string) => Result<TransportProvider, SdkError>;
};

declare const generateGatewayApiConfig: ({ networkId, dAppDefinitionAddress, gatewayBaseUrl, applicationName, applicationVersion, }: {
    networkId: number;
    dAppDefinitionAddress: string;
    gatewayBaseUrl?: string;
    applicationName?: string;
    applicationVersion?: string;
}) => {
    basePath: string;
    applicationName: string;
    applicationVersion: string;
    applicationDappDefinitionAddress: string;
};

type PreauthorizationPollingModuleInput = {
    logger?: Logger;
    providers: {
        gatewayModule: GatewayModule;
        requestItemModule: RequestItemModule;
        ignoreTransactionSubject: Subject<string>;
    };
};
type PreauthorizationPollingModule = ReturnType<typeof PreauthorizationPollingModule>;
declare const PreauthorizationPollingModule: (input: PreauthorizationPollingModuleInput) => {
    destroy: () => void;
};

type WalletRequestModule = ReturnType<typeof WalletRequestModule>;
declare const WalletRequestModule: (input: {
    logger?: Logger;
    origin?: string;
    networkId: number;
    useCache: boolean;
    requestInterceptor?: (input: WalletInteraction) => Promise<WalletInteraction>;
    dAppDefinitionAddress: string;
    providers: {
        stateModule: StateModule;
        storageModule: StorageModule;
        gatewayModule: GatewayModule;
        environmentModule: EnvironmentModule;
        transports?: TransportProvider[];
        dataRequestStateModule?: DataRequestStateModule;
        requestItemModule?: RequestItemModule;
        walletRequestSdk?: WalletRequestSdk;
        requestResolverModule?: RequestResolverModule;
        preauthorizationPollingModule?: PreauthorizationPollingModule;
    };
}) => {
    sendRequest: (input: {
        isConnect: boolean;
        oneTime: boolean;
    }) => ResultAsync<{
        proofs: ({
            address: string;
            type: "persona";
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
            challenge: string;
        } | {
            address: string;
            type: "account";
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
            challenge: string;
        })[];
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        personaData: ({
            entry: "fullName";
            fields: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            };
        } | {
            entry: "emailAddresses";
            fields: string[];
        } | {
            entry: "phoneNumbers";
            fields: string[];
        })[];
        persona?: {
            label: string;
            identityAddress: string;
        } | undefined;
    }, WalletDataRequestError>;
    sendTransaction: (value: SendTransactionInput) => ResultAsync<{
        transactionIntentHash: string;
        status: TransactionStatus;
    }, SdkError>;
    sendPreAuthorizationRequest: (value: SendPreAuthorizationRequestInput) => ResultAsync<SubintentResponseItem, SdkError>;
    cancelRequest: (id: string) => void;
    ignoreTransaction: (id: string) => void;
    requestItemModule: {
        add: (value: {
            type: "dataRequest" | "proofRequest" | "loginRequest" | "sendTransaction" | "preAuthorizationRequest";
            walletInteraction: {
                metadata: {
                    version: 2;
                    networkId: number;
                    dAppDefinitionAddress: string;
                    origin: string;
                };
                interactionId: string;
                items: {
                    discriminator: "unauthorizedRequest";
                    oneTimeAccounts?: {
                        numberOfAccounts: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        };
                        challenge?: string | undefined;
                    } | undefined;
                    oneTimePersonaData?: {
                        isRequestingName?: boolean | undefined;
                        numberOfRequestedEmailAddresses?: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        } | undefined;
                        numberOfRequestedPhoneNumbers?: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        } | undefined;
                    } | undefined;
                } | {
                    discriminator: "authorizedRequest";
                    auth: {
                        identityAddress: string;
                        discriminator: "usePersona";
                    } | {
                        discriminator: "loginWithoutChallenge";
                    } | {
                        challenge: string;
                        discriminator: "loginWithChallenge";
                    };
                    oneTimeAccounts?: {
                        numberOfAccounts: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        };
                        challenge?: string | undefined;
                    } | undefined;
                    oneTimePersonaData?: {
                        isRequestingName?: boolean | undefined;
                        numberOfRequestedEmailAddresses?: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        } | undefined;
                        numberOfRequestedPhoneNumbers?: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        } | undefined;
                    } | undefined;
                    reset?: {
                        accounts: boolean;
                        personaData: boolean;
                    } | undefined;
                    proofOfOwnership?: {
                        challenge: string;
                        identityAddress?: string | undefined;
                        accountAddresses?: string[] | undefined;
                    } | undefined;
                    ongoingAccounts?: {
                        numberOfAccounts: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        };
                        challenge?: string | undefined;
                    } | undefined;
                    ongoingPersonaData?: {
                        isRequestingName?: boolean | undefined;
                        numberOfRequestedEmailAddresses?: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        } | undefined;
                        numberOfRequestedPhoneNumbers?: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        } | undefined;
                    } | undefined;
                } | {
                    discriminator: "transaction";
                    send: {
                        transactionManifest: string;
                        version: number;
                        message?: string | undefined;
                        blobs?: string[] | undefined;
                    };
                } | {
                    discriminator: "cancelRequest";
                } | {
                    discriminator: "preAuthorizationRequest";
                    request?: {
                        discriminator: "subintent";
                        version: number;
                        expiration: {
                            discriminator: "expireAtTime";
                            unixTimestampSeconds: number;
                        } | {
                            discriminator: "expireAfterDelay";
                            expireAfterSeconds: number;
                        };
                        manifestVersion: number;
                        subintentManifest: string;
                        message?: string | undefined;
                        blobs?: string[] | undefined;
                    } | undefined;
                };
            };
            isOneTimeRequest: boolean;
        }, onSignal?: ((signalValue: string) => void) | undefined) => ResultAsync<RequestItem, Error>;
        cancel: (id: string) => ResultAsync<void, Error>;
        updateStatus: ({ id, status, error, transactionIntentHash, metadata, walletData, walletResponse, }: {
            id: string;
            status: "pending" | "success" | "fail" | "ignored" | "timedOut" | "cancelled" | "pendingCommit";
            error?: string | undefined;
            transactionIntentHash?: string | undefined;
            walletData?: {
                proofs: ({
                    address: string;
                    type: "persona";
                    proof: {
                        curve: "curve25519" | "secp256k1";
                        publicKey: string;
                        signature: string;
                    };
                    challenge: string;
                } | {
                    address: string;
                    type: "account";
                    proof: {
                        curve: "curve25519" | "secp256k1";
                        publicKey: string;
                        signature: string;
                    };
                    challenge: string;
                })[];
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
                personaData: ({
                    entry: "fullName";
                    fields: {
                        variant: "western" | "eastern";
                        familyName: string;
                        nickname: string;
                        givenNames: string;
                    };
                } | {
                    entry: "emailAddresses";
                    fields: string[];
                } | {
                    entry: "phoneNumbers";
                    fields: string[];
                })[];
                persona?: {
                    label: string;
                    identityAddress: string;
                } | undefined;
            } | undefined;
            walletResponse?: any;
            metadata?: Record<string, string | number | boolean> | undefined;
        }) => ResultAsync<void, {
            reason: string;
        }>;
        patch: (id: string, partialValue: Partial<RequestItem>) => ResultAsync<void, Error>;
        getAndRemoveSignal: (interactionId: string) => ((val: string) => void) | undefined;
        getById: (id: string) => ResultAsync<RequestItem | undefined, Error>;
        getPendingCommit: () => ResultAsync<RequestItem[], Error>;
        getPending: () => ResultAsync<RequestItem[], Error>;
        requests$: rxjs.Observable<RequestItem[]>;
        clear: () => ResultAsync<unknown, Error>;
        destroy: () => void;
    };
    provideChallengeGenerator: (fn: () => Promise<string>) => void;
    provideDataRequestControl: (fn: (walletData: WalletData) => Promise<any>) => void;
    provideConnectResponseCallback: (fn: (result: AwaitedWalletDataRequestResult) => any) => void;
    sendOneTimeRequest: (...items: DataRequestBuilderItem[]) => WalletDataRequestResult;
    setRequestDataState: (...items: DataRequestBuilderItem[]) => {
        sendRequest: () => WalletDataRequestResult;
    };
    getPendingRequests: () => ResultAsync<RequestItem[], Error>;
    getTransport: () => TransportProvider | undefined;
    updateSharedAccounts: () => ResultAsync<{
        proofs: ({
            address: string;
            type: "persona";
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
            challenge: string;
        } | {
            address: string;
            type: "account";
            proof: {
                curve: "curve25519" | "secp256k1";
                publicKey: string;
                signature: string;
            };
            challenge: string;
        })[];
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        personaData: ({
            entry: "fullName";
            fields: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            };
        } | {
            entry: "emailAddresses";
            fields: string[];
        } | {
            entry: "phoneNumbers";
            fields: string[];
        })[];
        persona?: {
            label: string;
            identityAddress: string;
        } | undefined;
    }, WalletDataRequestError | {
        error: string;
        message: string;
        jsError: never;
    }>;
    dataRequestStateModule: {
        reset: () => void;
        setState: (...items: DataRequestBuilderItem[]) => void;
        getState: () => Partial<{
            accounts: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                reset?: boolean | undefined;
                withProof?: boolean | undefined;
            };
            personaData: {
                emailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                phoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                reset?: boolean | undefined;
                fullName?: boolean | undefined;
            };
            persona: {
                withProof?: boolean | undefined;
            };
            proofOfOwnership: {
                identityAddress?: string | undefined;
                accountAddresses?: string[] | undefined;
            };
        }>;
        patchState: (...items: DataRequestBuilderItem[]) => void;
        removeState: (...keys: ("accounts" | "personaData" | "persona" | "proofOfOwnership")[]) => void;
        toDataRequestState: (...items: unknown[]) => Partial<{
            accounts: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                reset?: boolean | undefined;
                withProof?: boolean | undefined;
            };
            personaData: {
                emailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                phoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                reset?: boolean | undefined;
                fullName?: boolean | undefined;
            };
            persona: {
                withProof?: boolean | undefined;
            };
            proofOfOwnership: {
                identityAddress?: string | undefined;
                accountAddresses?: string[] | undefined;
            };
        }>;
        state$: rxjs.Observable<Partial<{
            accounts: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                reset?: boolean | undefined;
                withProof?: boolean | undefined;
            };
            personaData: {
                emailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                phoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                reset?: boolean | undefined;
                fullName?: boolean | undefined;
            };
            persona: {
                withProof?: boolean | undefined;
            };
            proofOfOwnership: {
                identityAddress?: string | undefined;
                accountAddresses?: string[] | undefined;
            };
        }>>;
    };
    interactionStatusChange$: rxjs.Observable<"pending" | "success" | "fail">;
    requestItems$: rxjs.Observable<RequestItem[]>;
    disconnect: () => void;
    destroy: () => void;
};

type BuildableSubintentRequest = {
    toRequestItem: () => SubintentRequestItem;
    getOnSubmittedSuccessFn?: () => (transactionIntentHash: string) => void;
};
/**
 * A builder function for creating a SubintentRequest.
 *
 * @returns An object with methods to configure and build a SubintentRequestItem.
 *
 * @example
 * const builder = SubintentRequestBuilder();
 * const requestItem = builder
 *   .manifest('some-manifest')
 *   .setExpiration('atTime', 1234567890)
 *   .addBlobs('blob1', 'blob2')
 *   .message('This is a message')
 *   .onSubmittedSuccess((transactionIntentHash) => console.log('Submitted successfully', transactionIntentHash))
 */
declare const SubintentRequestBuilder: () => {
    manifest: (value: string) => {
        setExpiration: (type: 'atTime' | 'afterDelay', value: number) => {
            readonly addBlobs: (...blobs: string[]) => any;
            readonly message: (message: string) => any;
            readonly toRequestItem: () => {
                discriminator: "subintent";
                version: number;
                expiration: {
                    discriminator: "expireAtTime";
                    unixTimestampSeconds: number;
                } | {
                    discriminator: "expireAfterDelay";
                    expireAfterSeconds: number;
                };
                manifestVersion: number;
                subintentManifest: string;
                message?: string | undefined;
                blobs?: string[] | undefined;
            };
            readonly onSubmittedSuccess: (callback: (transactionIntentHash: string) => void) => any;
            readonly getOnSubmittedSuccessFn: () => (transactionIntentHash: string) => void;
        };
    };
    rawConfig: (rawConfig: Omit<SubintentRequestItem, 'discriminator'>) => {
        toRequestItem: () => {
            discriminator: "subintent";
            version: number;
            expiration: {
                discriminator: "expireAtTime";
                unixTimestampSeconds: number;
            } | {
                discriminator: "expireAfterDelay";
                expireAfterSeconds: number;
            };
            manifestVersion: number;
            subintentManifest: string;
            message?: string | undefined;
            blobs?: string[] | undefined;
        };
    };
};

type ConnectButtonModuleInput = {
    networkId: number;
    environment?: string;
    dAppDefinitionAddress?: string;
    onConnect?: (done: (input?: {
        challenge: string;
    }) => void) => void;
    subjects?: ConnectButtonSubjects;
    logger?: Logger;
    onDisconnect?: () => void;
    explorer?: ExplorerConfig;
    providers: {
        stateModule: StateModule;
        gatewayModule: GatewayModule;
        environmentModule: EnvironmentModule;
        walletRequestModule: WalletRequestModule;
    };
};
type ConnectButtonModule = ReturnType<typeof ConnectButtonModule>;
declare const ConnectButtonModule: (input: ConnectButtonModuleInput) => ConnectButtonModuleOutput;

declare const parseSignedChallenge: (value: SignedChallenge) => valibot.SafeParseResult<valibot.VariantSchema<"type", [valibot.ObjectSchema<{
    readonly challenge: valibot.StringSchema<undefined>;
    readonly proof: valibot.ObjectSchema<{
        readonly publicKey: valibot.StringSchema<undefined>;
        readonly signature: valibot.StringSchema<undefined>;
        readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
    }, undefined>;
    readonly address: valibot.StringSchema<undefined>;
    readonly type: valibot.LiteralSchema<"persona", undefined>;
}, undefined>, valibot.ObjectSchema<{
    readonly challenge: valibot.StringSchema<undefined>;
    readonly proof: valibot.ObjectSchema<{
        readonly publicKey: valibot.StringSchema<undefined>;
        readonly signature: valibot.StringSchema<undefined>;
        readonly curve: valibot.UnionSchema<[valibot.LiteralSchema<"curve25519", undefined>, valibot.LiteralSchema<"secp256k1", undefined>], undefined>;
    }, undefined>;
    readonly address: valibot.StringSchema<undefined>;
    readonly type: valibot.LiteralSchema<"account", undefined>;
}, undefined>], undefined>>;

type Providers = {
    connectButtonModule: ConnectButtonModule;
    gatewayModule: GatewayModule;
    stateModule: StateModule;
    storageModule: StorageModule;
    environmentModule: EnvironmentModule;
    walletRequestModule: WalletRequestModule;
};
type ExplorerConfig = {
    baseUrl: string;
    transactionPath: string;
    subintentPath: string;
    accountsPath: string;
};
type WalletDataRequest = Parameters<WalletRequestSdk['sendInteraction']>[0];
type WalletRequest = {
    type: 'sendTransaction';
    payload: WalletInteraction;
} | {
    type: 'dataRequest';
    payload: WalletInteraction;
};
type OptionalRadixDappToolkitOptions = {
    logger: Logger;
    onDisconnect: () => void;
    explorer: ExplorerConfig;
    gatewayBaseUrl: string;
    applicationName: string;
    applicationVersion: string;
    useCache: boolean;
    providers: Partial<Providers>;
    requestInterceptor: (input: WalletInteraction) => Promise<WalletInteraction>;
    featureFlags: string[];
};
type RequiredRadixDappToolkitOptions = {
    networkId: number;
} & ({
    dAppDefinitionAddress: string;
    applicationDappDefinitionAddress?: never;
} | {
    dAppDefinitionAddress?: never;
    applicationDappDefinitionAddress: string;
});
type RadixDappToolkitOptions = Partial<OptionalRadixDappToolkitOptions> & RequiredRadixDappToolkitOptions;
type SendTransactionResult = ResultAsync<{
    transactionIntentHash: string;
    status: TransactionStatus;
}, {
    error: string;
    jsError?: unknown;
    message?: string;
    transactionIntentHash?: string;
    status?: TransactionStatus;
}>;
type SendTransactionInput = {
    transactionManifest: string;
    version?: number;
    blobs?: string[];
    message?: string;
    onTransactionId?: (transactionId: string) => void;
};
type SendPreAuthorizationRequestInput = BuildableSubintentRequest;
type ButtonApi = {
    setMode: (value: 'light' | 'dark') => void;
    setTheme: (value: RadixButtonTheme) => void;
    status$: Observable<RadixButtonStatus>;
};
type WalletDataRequestError = {
    error: string;
    message?: string;
    jsError?: unknown;
};
type WalletDataRequestResult = ResultAsync<WalletData, WalletDataRequestError>;
type AwaitedWalletDataRequestResult = Result<WalletData, WalletDataRequestError>;
type WalletApi = {
    getWalletData: () => WalletDataState | undefined;
    walletData$: Observable<WalletDataState>;
    provideChallengeGenerator: (fn: () => Promise<string>) => void;
    provideConnectResponseCallback: (fn: (result: AwaitedWalletDataRequestResult) => void) => void;
    dataRequestControl: (fn: (walletResponse: WalletData) => Promise<any>) => void;
    updateSharedAccounts: () => WalletDataRequestResult;
    sendTransaction: (input: SendTransactionInput) => SendTransactionResult;
    sendPreAuthorizationRequest: (input: SendPreAuthorizationRequestInput) => ResultAsync<{
        signedPartialTransaction: string;
    }, SdkError>;
    setRequestData: (...dataRequestBuilderItem: DataRequestBuilderItem[]) => void;
    sendRequest: () => WalletDataRequestResult;
    sendOneTimeRequest: (...oneTimeDataRequestBuilderItem: OneTimeDataRequestBuilderItem[]) => WalletDataRequestResult;
};
type WalletDataStateAccount = {
    address: string;
    label: string;
    appearanceId: number;
};
type WalletDataStatePersonaData = {
    entry: 'fullName';
    fields: PersonaDataName;
} | {
    entry: 'emailAddresses';
    fields: string[];
} | {
    entry: 'phoneNumbers';
    fields: string[];
};
type WalletDataState = {
    accounts: WalletDataStateAccount[];
    personaData: WalletDataStatePersonaData[];
    proofs: SignedChallenge[];
    persona?: Persona;
};
type TransportProvider = {
    id: string;
    isLinked$?: Observable<boolean>;
    isAvailable$?: Observable<boolean>;
    sessionChange$?: Observable<Session>;
    showQrCode?: () => void;
    isSupported: () => boolean;
    send: (walletInteraction: WalletInteraction, callbackFns: Partial<CallbackFns>) => ResultAsync<WalletInteractionResponse, SdkError>;
    disconnect: () => void;
    destroy: () => void;
};
type GatewayApiClientConfig = {
    basePath: string;
    applicationName: string;
    applicationVersion: string;
    applicationDappDefinitionAddress: string;
};

type RadixDappToolkit = {
    walletApi: WalletApi;
    buttonApi: ButtonApi;
    gatewayApi: {
        clientConfig: GatewayApiClientConfig;
    };
    disconnect: () => void;
    destroy: () => void;
};
declare const RadixDappToolkit: (options: RadixDappToolkitOptions) => RadixDappToolkit;

export { Account, AccountProof, AccountsRequestItem, AccountsRequestResponseItem, type Answer, AnswerIO, AuthLoginRequestItem, AuthLoginRequestResponseItem, AuthLoginWithChallengeRequestItem, AuthLoginWithChallengeRequestResponseItem, AuthLoginWithoutChallengeRequestItem, AuthLoginWithoutChallengeRequestResponseItem, AuthRequestItem, AuthRequestResponseItem, AuthUsePersonaRequestItem, AuthUsePersonaRequestResponseItem, type AwaitedWalletDataRequestResult, type BuildableSubintentRequest, type ButtonApi, type CallbackFns, CancelRequest, CancelWalletInteractionExtensionInteraction, type ConfigRequestBuilder, type Confirmation, ConnectButtonModule, type ConnectButtonModuleInput, type ConnectButtonModuleOutput, ConnectButtonStatus, ConnectButtonSubjects, ConnectorExtensionModule, ConnectorExtensionSubjects, Curve25519, DataRequestBuilder, type DataRequestBuilderItem, type DataRequestState, DataRequestStateModule, type DataTypes, DeepLinkModule, type EntityMetadataItem, type EntityMetadataItemValue, EnvironmentModule, ExpireAfterDelay, ExpireAtTime, type ExplorerConfig, ExponentialBackoff, type ExponentialBackoffInput, ExtensionInteraction, type GatewayApiClientConfig, GatewayApiService, GatewayModule, type IceCandidate, IceCandidateIO, IceCandidatePayloadIO, type IceCandidates, IceCandidatesIO, IdentityKind, IdentityModule, type IdentitySecret, type IdentityStore, IncomingMessage, type InvalidMessageError, type KeyPairProvider, LocalStorageModule, Logger, LoginRequestResponseItem, MessageLifeCycleEvent, MessageLifeCycleExtensionStatusEvent, type MessagePayloadTypes, type MessageSources, Metadata, type MetadataStringValue, type MetadataTypedValue, type MissingRemoteClientError, type NetworkConfig, NumberOfValues, type Offer, OfferIO, OneTimeDataRequestBuilder, type OneTimeDataRequestBuilderItem, OpenPopupExtensionInteraction, type OptionalRadixDappToolkitOptions, Persona, PersonaDataName, PersonaDataNameVariant, PersonaDataRequestItem, PersonaDataRequestResponseItem, PersonaProof, Proof, ProofOfOwnershipRequestItem, ProofOfOwnershipResponseItem, type Providers, RadixConnectRelayModule, RadixDappToolkit, type RadixDappToolkitOptions, RadixNetwork, RadixNetworkConfig, RadixNetworkConfigById, RdtState, type RemoteClientDisconnected, type RemoteClientIsAlreadyConnected, type RemoteClientJustConnected, type RemoteData, RequestItemModule, type RequestItemModuleInput, ResetRequestItem, type SendPreAuthorizationRequestInput, type SendTransactionInput, SendTransactionItem, SendTransactionResponseItem, type SendTransactionResult, type Session, SessionModule, SharedData, type SignalingServerErrorResponse, SignalingServerMessage, type SignalingServerResponse, SignedChallenge, SignedChallengeAccount, SignedChallengePersona, Sources, StateModule, StatusExtensionInteraction, type StorageChange, type StorageModule, SubintentRequestBuilder, SubintentRequestItem, SubintentResponseItem, type SubintentStatus, TransactionStatus, type TransactionStatusResponse, TransformRdtDataRequestToWalletRequestInput, type TransportProvider, type ValidationError, type WalletApi, WalletAuthorizedRequestItems, WalletAuthorizedRequestResponseItems, WalletData, WalletDataPersonaData, WalletDataPersonaDataEmailAddresses, WalletDataPersonaDataFullName, WalletDataPersonaDataPhoneNumbersAddresses, type WalletDataRequest, type WalletDataRequestError, type WalletDataRequestResponse, type WalletDataRequestResult, type WalletDataState, type WalletDataStateAccount, type WalletDataStatePersonaData, WalletInteraction, WalletInteractionExtensionInteraction, WalletInteractionFailureResponse, WalletInteractionItems, WalletInteractionResponse, WalletInteractionResponseItems, WalletInteractionSuccessResponse, WalletPreAuthorizationItems, WalletPreAuthorizationResponseItems, type WalletRequest, WalletRequestItems, WalletRequestModule, WalletRequestResponseItems, WalletRequestSdk, type WalletRequestSdkInput, WalletTransactionItems, WalletTransactionResponseItems, WalletUnauthorizedRequestItems, WalletUnauthorizedRequestResponseItems, blake2b, canDataRequestBeResolvedByRdtState, config, eventType, extensionInteractionDiscriminator, fetchWrapper, generateGatewayApiConfig, generateRolaChallenge, messageLifeCycleEventType, parseJSON, parseSignedChallenge, personaDataFullNameVariant, proofType, removeUndefined, stringify, toWalletRequest, transformRdtDataRequestToWalletRequest, transformSharedDataToDataRequestState, transformWalletDataToConnectButton, transformWalletRequestToSharedData, transformWalletResponseToRdtWalletData, typedError, unwrapObservable, validateRolaChallenge, validateWalletResponse, walletDataDefault };
