var _e=(...t)=>{let r=t.reduce((i,p)=>i+p.length,0),n=new Uint8Array(r),o=0;for(let i of t)n.set(i,o),o+=i.length;return n};var d=t=>{let r=t.startsWith("0x")?t.slice(2):t,n=new Uint8Array(r.length/2);for(let o=0;o<n.length;o++)n[o]=parseInt(r.slice(o*2,o*2+2),16);return n};var l=t=>Array.from(t).map(r=>r.toString(16).padStart(2,"0")).join("");import G from"blakejs";var f=t=>G.blake2bHex(t,void 0,32);import{x25519 as b,ed25519 as S}from"@noble/curves/ed25519";import{hkdf as $}from"@noble/hashes/hkdf";import{sha256 as X}from"@noble/hashes/sha256";var U=(t=b.utils.randomPrivateKey())=>{let r={privateKey:t,publicKey:S.getPublicKey(t),sign:o=>S.sign(o,t)},n={privateKey:t,publicKey:b.getPublicKey(t),calculateSharedSecret:o=>$(X,b.getSharedSecret(t,o.publicKey),o.salt,o.context,o.length)};return{ed25519:r,x25519:n}};import{concatBytes as J}from"@noble/hashes/utils";var j=t=>crypto.subtle.importKey("raw",t,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),E=({data:t,encryptionKey:r,iv:n})=>j(r).then(o=>crypto.subtle.decrypt({name:"AES-GCM",iv:n},o,t)).then(o=>new Uint8Array(o)),rt=(t,r,n=crypto.getRandomValues(new Uint8Array(12)))=>j(r).then(o=>crypto.subtle.encrypt({name:"AES-GCM",iv:n},o,t).then(i=>new Uint8Array(i))).then(o=>({combined:J(n,o),iv:n,cipherText:o}));import{concatBytes as F}from"@noble/hashes/utils";var D=(t,r)=>{let{nonceLength:n=12,authTagLength:o=16}=r??{},i=t.slice(0,n),p=t.slice(n,t.length-o),m=t.slice(t.length-o);return{iv:i,cipherText:p,authTag:m,combined:t,cipherTextAndAuthTag:F(p,m)}};import Q from"crypto";var w=t=>Q.getRandomValues(new Uint8Array(t));import N from"bip39";import{derivePath as Z}from"ed25519-hd-key";var ee={TRANSACTION_SIGNING:1460,AUTHENTICATION_SIGNING:1678,MESSAGE_ENCRYPTION:1391},te={ACCOUNT:525,IDENTITY:618},ft=({networkId:t,keyType:r,entityType:n,index:o=0})=>`m/44'/1022'/${t}'/${te[n]}'/${ee[r]}'/${o}'`,yt=(t=32)=>N.entropyToMnemonic(l(w(t))),gt=async({mnemonic:t,password:r,derivationPath:n})=>N.mnemonicToSeed(t,r).then(o=>o.toString("hex")).then(o=>Z(n,o)).then(o=>o.key.toString("hex"));import{z as e}from"zod";var oe=e.object({address:e.string(),label:e.string(),appearanceId:e.number()}),y=e.object({publicKey:e.string(),signature:e.string(),curve:e.union([e.literal("curve25519"),e.literal("secp256k1")])}),K=e.object({accountAddress:e.string(),proof:y}),ne=e.object({identityAddress:e.string(),proof:y}),re=e.object({challenge:e.string(),identityAddress:e.string().optional(),accountAddresses:e.array(e.string()).optional()}),se=e.object({challenge:e.string(),proofs:e.array(e.union([K,ne]))}),g=e.object({identityAddress:e.string(),label:e.string()}),O={western:"western",eastern:"eastern"},L=e.union([e.literal(O.eastern),e.literal(O.western)]),Wt=e.object({variant:L,familyName:e.string(),nickname:e.string(),givenNames:e.string()}),ie=e.object({quantifier:e.union([e.literal("exactly"),e.literal("atLeast")]),quantity:e.number().min(0,"The number must be at least 0.")}),I=e.object({challenge:e.string().optional(),numberOfAccounts:ie}),q=e.object({accounts:e.array(oe),challenge:e.string().optional(),proofs:e.array(K).optional()}).refine(t=>t.challenge||t?.proofs?!!(t.challenge&&t?.proofs?.length):!0,"missing challenge or proofs"),P=e.object({isRequestingName:e.boolean().optional(),numberOfRequestedEmailAddresses:e.number().min(0).optional(),numberOfRequestedPhoneNumbers:e.number().min(0).optional()}),T=e.object({name:e.object({variant:L,familyName:e.string(),nickname:e.string(),givenNames:e.string()}).optional(),emailAddresses:e.array(e.string()).optional(),phoneNumbers:e.array(e.string()).optional()}),ae=e.object({accounts:e.boolean(),personaData:e.boolean()}),zt=e.object({persona:g,challenge:e.string().optional(),proof:y.optional()}).refine(t=>t.challenge||t.proof?!!(t.challenge&&t.proof):!0,"missing challenge or proof"),pe=e.object({discriminator:e.literal("unauthorizedRequest"),oneTimeAccounts:I.optional(),oneTimePersonaData:P.optional()}),ce=e.object({discriminator:e.literal("usePersona"),identityAddress:e.string()}),le=e.object({discriminator:e.literal("loginWithoutChallenge")}),me=e.object({discriminator:e.literal("loginWithChallenge"),challenge:e.string()}),ue=e.union([le,me]),de=e.union([ce,ue]),fe=e.object({discriminator:e.literal("authorizedRequest"),auth:de,reset:ae.optional(),proofOfOwnership:re.optional(),oneTimeAccounts:I.optional(),ongoingAccounts:I.optional(),oneTimePersonaData:P.optional(),ongoingPersonaData:P.optional()}),ye=e.union([pe,fe]),ge=e.object({transactionManifest:e.string(),version:e.number(),blobs:e.array(e.string()).optional(),message:e.string().optional()}),xe=e.object({discriminator:e.literal("transaction"),send:ge}),Re=e.object({transactionIntentHash:e.string()}),he=e.object({discriminator:e.literal("transaction"),send:Re}),Ae=e.object({discriminator:e.literal("cancelRequest")}),be=e.object({discriminator:e.literal("expireAtTime"),unixTimestampSeconds:e.number()}),Ie=e.object({discriminator:e.literal("expireAfterDelay"),expireAfterSeconds:e.number()}),qe=e.object({discriminator:e.literal("subintent"),version:e.number(),manifestVersion:e.number(),subintentManifest:e.string(),blobs:e.array(e.string()).optional(),message:e.string().optional(),expiration:e.union([be,Ie])}),Pe=e.object({expirationTimestamp:e.number(),subintentHash:e.string(),signedPartialTransaction:e.string()}),Te=e.object({discriminator:e.literal("preAuthorizationRequest"),request:qe.optional()}),Ce=e.union([ye,xe,Ae,Te]),We=e.object({version:e.literal(2),networkId:e.number(),dAppDefinitionAddress:e.string(),origin:e.string()}),St=e.object({interactionId:e.string(),metadata:We,items:Ce}),ze=e.object({discriminator:e.literal("unauthorizedRequest"),oneTimeAccounts:q.optional(),oneTimePersonaData:T.optional()}),Se=e.object({discriminator:e.literal("loginWithoutChallenge"),persona:g}),Ue=e.object({discriminator:e.literal("loginWithChallenge"),persona:g,challenge:e.string(),proof:y}),je=e.object({discriminator:e.literal("preAuthorizationResponse"),response:Pe.optional()}),Ee=e.union([Se,Ue]),De=e.object({discriminator:e.literal("usePersona"),persona:g}),we=e.union([De,Ee]),Ne=e.object({discriminator:e.literal("authorizedRequest"),auth:we,proofOfOwnership:se.optional(),oneTimeAccounts:q.optional(),ongoingAccounts:q.optional(),oneTimePersonaData:T.optional(),ongoingPersonaData:T.optional()}),Oe=e.union([ze,Ne]),Ke=e.union([Oe,he,je]),Le=e.object({discriminator:e.literal("success"),interactionId:e.string(),items:Ke}),ke=e.object({discriminator:e.literal("failure"),interactionId:e.string(),error:e.string(),message:e.string().optional()}),Ut=e.union([Le,ke]);import Me from"base64url";var k=t=>Me.encode(JSON.stringify(t),"utf-8");import{concatBytes as He}from"@noble/hashes/utils";var M=({interactionId:t,dAppDefinitionAddress:r,origin:n})=>{let o=new TextEncoder;return f(He(o.encode("C"),o.encode(t),new Uint8Array([r.length]),o.encode(r),o.encode(n)))};var H=async({encryptedData:t,keyPair:r,salt:n,publicKey:o})=>{let i=new TextEncoder,p=new TextDecoder,m=r.x25519.calculateSharedSecret({publicKey:o,salt:i.encode(n),context:"RCfM",length:32}),{iv:u,cipherTextAndAuthTag:x}=D(d(t)),R=await E({data:x,encryptionKey:m,iv:u}),C=p.decode(R);return JSON.parse(C)};var v=(t,r)=>{let n=M(t),o=r.ed25519.sign(n);return l(o)};var _=t=>({getResponses:n=>fetch(t.baseUrl,{method:"POST",body:JSON.stringify({method:"getResponses",sessionId:n})}).then(o=>o.json()).then(o=>o)});var so=t=>{let{baseUrl:r="https://radix-connect-relay.radixdlt.com",walletUrl:n="radixWallet://connect",sessionId:o=crypto.randomUUID(),privateKey:i,handleRequest:p}=t??{},m=_({baseUrl:`${r}/api/v1`}),u=U(i),x=s=>{let c=new URL(n);return Object.entries(s).forEach(([a,h])=>{c.searchParams.append(a,h)}),c.toString()},R=async({signal:s})=>{let c=[];for(;c.length===0;){if(s?.aborted)throw new Error("Request aborted");try{c=await m.getResponses(o)}catch(a){console.error(a)}await new Promise(a=>setTimeout(a,1e3))}return c[0]};return{sendRequest:async s=>{let a=new AbortController,h=setTimeout(()=>{a.abort("Request timed out after 5 minutes")},3e5),B=v({dAppDefinitionAddress:s.metadata.dAppDefinitionAddress,interactionId:s.interactionId,origin:s.metadata.origin},u),W={sessionId:o,request:k(s),signature:B,publicKey:l(u.x25519.publicKey),identity:l(u.ed25519.publicKey),origin:s.metadata.origin,dAppDefinitionAddress:s.metadata.dAppDefinitionAddress};await p({deepLink:x(W),body:W,abortController:a});let A=await R({signal:a.signal});if(clearTimeout(h),"error"in A)throw new Error(A.error);let{publicKey:V,data:Y}=A,z=await H({encryptedData:Y,keyPair:u,salt:s.metadata.dAppDefinitionAddress,publicKey:V});if(s.interactionId!==z.interactionId)throw new Error("Wallet interaction response does not match request");return z}}};var fo=({transport:t})=>({sendRequest:async n=>t.sendRequest(n)});import{concatBytes as ve}from"@noble/hashes/utils";var ho=({dAppDefinitionAddress:t,origin:r,challenge:n})=>{let o=new TextEncoder;return f(ve(o.encode("R"),d(n),new Uint8Array([t.length]),o.encode(t),o.encode(r)))};export{oe as Account,K as AccountProof,I as AccountsRequestItem,q as AccountsRequestResponseItem,ue as AuthLoginRequestItem,Ee as AuthLoginRequestResponseItem,me as AuthLoginWithChallengeRequestItem,Ue as AuthLoginWithChallengeRequestResponseItem,le as AuthLoginWithoutChallengeRequestItem,Se as AuthLoginWithoutChallengeRequestResponseItem,de as AuthRequestItem,we as AuthRequestResponseItem,ce as AuthUsePersonaRequestItem,De as AuthUsePersonaRequestResponseItem,Ae as CancelRequest,Ie as ExpireAfterDelay,be as ExpireAtTime,zt as LoginRequestResponseItem,We as Metadata,ie as NumberOfValues,g as Persona,Wt as PersonaDataName,L as PersonaDataNameVariant,P as PersonaDataRequestItem,T as PersonaDataRequestResponseItem,ne as PersonaProof,y as Proof,re as ProofOfOwnershipRequestItem,se as ProofOfOwnershipResponseItem,te as RADIX_ENTITY_TYPE,ee as RADIX_KEY_TYPE,ae as ResetRequestItem,ge as SendTransactionItem,Re as SendTransactionResponseItem,qe as SubintentRequestItem,Pe as SubintentResponseItem,fe as WalletAuthorizedRequestItems,Ne as WalletAuthorizedRequestResponseItems,St as WalletInteraction,ke as WalletInteractionFailureResponse,Ce as WalletInteractionItems,Ut as WalletInteractionResponse,Ke as WalletInteractionResponseItems,Le as WalletInteractionSuccessResponse,Te as WalletPreAuthorizationItems,je as WalletPreAuthorizationResponseItems,ye as WalletRequestItems,Oe as WalletRequestResponseItems,xe as WalletTransactionItems,he as WalletTransactionResponseItems,pe as WalletUnauthorizedRequestItems,ze as WalletUnauthorizedRequestResponseItems,k as base64urlEncode,f as blake2b,_e as concat,U as createEd25519KeyPair,M as createMessageHash,fo as createRadixConnectClient,_ as createRadixConnectRelayApiClient,so as createRadixConnectRelayTransport,ho as createRolaMessage,E as decrypt,H as decryptPayload,rt as encrypt,d as fromHex,yt as generateBIP39Mnemonic,ft as getRadixBIP39DerivationPath,gt as mnemonicToPrivateKey,O as personaDataFullNameVariant,v as produceSignature,w as secureRandom,l as toHex,D as transformToSealbox};
